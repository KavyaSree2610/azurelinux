diff -ur protobuf-3.17.3/src/google/protobuf/extension_set_inl.h protobuf-3.17.3-patched/src/google/protobuf/extension_set_inl.h
--- protobuf-3.17.3/src/google/protobuf/extension_set_inl.h	2021-06-08 07:11:10
+++ protobuf-3.17.3-patched/src/google/protobuf/extension_set_inl.h	2024-06-21 10:18:32
@@ -31,9 +31,9 @@
 #ifndef GOOGLE_PROTOBUF_EXTENSION_SET_INL_H__
 #define GOOGLE_PROTOBUF_EXTENSION_SET_INL_H__
 
-#include <google/protobuf/parse_context.h>
 #include <google/protobuf/extension_set.h>
 #include <google/protobuf/metadata_lite.h>
+#include <google/protobuf/parse_context.h>
 
 namespace google {
 namespace protobuf {
@@ -83,7 +83,7 @@
     switch (extension.type) {
 #define HANDLE_VARINT_TYPE(UPPERCASE, CPP_CAMELCASE)                        \
   case WireFormatLite::TYPE_##UPPERCASE: {                                  \
-    uint64 value;                                                           \
+    uint64_t value;                                                         \
     ptr = VarintParse(ptr, &value);                                         \
     GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
     if (extension.is_repeated) {                                            \
@@ -103,7 +103,7 @@
 #undef HANDLE_VARINT_TYPE
 #define HANDLE_SVARINT_TYPE(UPPERCASE, CPP_CAMELCASE, SIZE)                 \
   case WireFormatLite::TYPE_##UPPERCASE: {                                  \
-    uint64 val;                                                             \
+    uint64_t val;                                                             \
     ptr = VarintParse(ptr, &val);                                           \
     GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
     auto value = WireFormatLite::ZigZagDecode##SIZE(val);                   \
@@ -132,16 +132,16 @@
     }                                                                       \
   } break
 
-      HANDLE_FIXED_TYPE(FIXED32, UInt32, uint32);
-      HANDLE_FIXED_TYPE(FIXED64, UInt64, uint64);
-      HANDLE_FIXED_TYPE(SFIXED32, Int32, int32);
-      HANDLE_FIXED_TYPE(SFIXED64, Int64, int64);
+      HANDLE_FIXED_TYPE(FIXED32, UInt32, uint32_t);
+      HANDLE_FIXED_TYPE(FIXED64, UInt64, uint64_t);
+      HANDLE_FIXED_TYPE(SFIXED32, Int32, int32_t);
+      HANDLE_FIXED_TYPE(SFIXED64, Int64, int64_t);
       HANDLE_FIXED_TYPE(FLOAT, Float, float);
       HANDLE_FIXED_TYPE(DOUBLE, Double, double);
 #undef HANDLE_FIXED_TYPE
 
       case WireFormatLite::TYPE_ENUM: {
-        uint64 val;
+        uint64_t val;
         ptr = VarintParse(ptr, &val);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
         int value = val;
@@ -181,7 +181,7 @@
                 : MutableMessage(number, WireFormatLite::TYPE_GROUP,
                                  *extension.message_info.prototype,
                                  extension.descriptor);
-        uint32 tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
+        uint32_t tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
         return ctx->ParseGroup(value, ptr, tag);
       }
 
@@ -203,22 +203,27 @@
 
 template <typename Msg, typename T>
 const char* ExtensionSet::ParseMessageSetItemTmpl(
-    const char* ptr, const Msg* containing_type,
-    internal::InternalMetadata* metadata, internal::ParseContext* ctx) {
+    const char* ptr, const Msg* extendee, internal::InternalMetadata* metadata,
+    internal::ParseContext* ctx) {
   std::string payload;
-  uint32 type_id = 0;
-  bool payload_read = false;
+  uint32_t type_id;
+  enum class State { kNoTag, kHasType, kHasPayload, kDone };
+  State state = State::kNoTag;
+
   while (!ctx->Done(&ptr)) {
-    uint32 tag = static_cast<uint8>(*ptr++);
+    uint32_t tag = static_cast<uint8_t>(*ptr++);
     if (tag == WireFormatLite::kMessageSetTypeIdTag) {
-      uint64 tmp;
+      uint64_t tmp;
       ptr = ParseBigVarint(ptr, &tmp);
       GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-      type_id = tmp;
-      if (payload_read) {
+      if (state == State::kNoTag) {
+        type_id = tmp;
+        state = State::kHasType;
+      } else if (state == State::kHasPayload) {
+        type_id = tmp;
         ExtensionInfo extension;
         bool was_packed_on_wire;
-        if (!FindExtension(2, type_id, containing_type, ctx, &extension,
+        if (!FindExtension(2, type_id, extendee, ctx, &extension,
                            &was_packed_on_wire)) {
           WriteLengthDelimited(type_id, payload,
                                metadata->mutable_unknown_fields<T>());
@@ -241,20 +246,24 @@
           GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
                                          tmp_ctx.EndedAtLimit());
         }
-        type_id = 0;
+        state = State::kDone;
       }
     } else if (tag == WireFormatLite::kMessageSetMessageTag) {
-      if (type_id != 0) {
-        ptr = ParseFieldMaybeLazily(static_cast<uint64>(type_id) * 8 + 2, ptr,
-                                    containing_type, metadata, ctx);
+      if (state == State::kHasType) {
+        ptr = ParseFieldMaybeLazily(static_cast<uint64_t>(type_id) * 8 + 2, ptr,
+                                    extendee, metadata, ctx);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
-        type_id = 0;
+        state = State::kDone;
       } else {
-        int32 size = ReadSize(&ptr);
+        std::string tmp;
+        int32_t size = ReadSize(&ptr);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        ptr = ctx->ReadString(ptr, size, &payload);
+        ptr = ctx->ReadString(ptr, size, &tmp);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        payload_read = true;
+        if (state == State::kNoTag) {
+          payload = std::move(tmp);
+          state = State::kHasPayload;
+        }
       }
     } else {
       ptr = ReadTag(ptr - 1, &tag);
@@ -262,7 +271,7 @@
         ctx->SetLastTag(tag);
         return ptr;
       }
-      ptr = ParseField(tag, ptr, containing_type, metadata, ctx);
+      ptr = ParseField(tag, ptr, extendee, metadata, ctx);
       GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
     }
   }
diff -ur protobuf-3.17.3/src/google/protobuf/wire_format.cc protobuf-3.17.3-patched/src/google/protobuf/wire_format.cc
--- protobuf-3.17.3/src/google/protobuf/wire_format.cc	2021-06-08 07:11:10
+++ protobuf-3.17.3-patched/src/google/protobuf/wire_format.cc	2024-06-21 10:34:12
@@ -41,20 +41,21 @@
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/stubs/common.h>
 #include <google/protobuf/stubs/stringprintf.h>
-#include <google/protobuf/descriptor.pb.h>
-#include <google/protobuf/parse_context.h>
 #include <google/protobuf/io/coded_stream.h>
 #include <google/protobuf/io/zero_copy_stream.h>
 #include <google/protobuf/io/zero_copy_stream_impl.h>
 #include <google/protobuf/descriptor.h>
+#include <google/protobuf/descriptor.pb.h>
 #include <google/protobuf/dynamic_message.h>
 #include <google/protobuf/map_field.h>
 #include <google/protobuf/map_field_inl.h>
 #include <google/protobuf/message.h>
 #include <google/protobuf/message_lite.h>
+#include <google/protobuf/parse_context.h>
 #include <google/protobuf/unknown_field_set.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 const size_t kMapEntryTagByteSize = 2;
@@ -70,7 +71,7 @@
 // ===================================================================
 
 bool UnknownFieldSetFieldSkipper::SkipField(io::CodedInputStream* input,
-                                            uint32 tag) {
+                                            uint32_t tag) {
   return WireFormat::SkipField(input, tag, unknown_fields_);
 }
 
@@ -82,7 +83,7 @@
   unknown_fields_->AddVarint(field_number, value);
 }
 
-bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
+bool WireFormat::SkipField(io::CodedInputStream* input, uint32_t tag,
                            UnknownFieldSet* unknown_fields) {
   int number = WireFormatLite::GetTagFieldNumber(tag);
   // Field number 0 is illegal.
@@ -90,21 +91,21 @@
 
   switch (WireFormatLite::GetTagWireType(tag)) {
     case WireFormatLite::WIRETYPE_VARINT: {
-      uint64 value;
+      uint64_t value;
       if (!input->ReadVarint64(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddVarint(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddVarint(number, value);
       return true;
     }
     case WireFormatLite::WIRETYPE_FIXED64: {
-      uint64 value;
+      uint64_t value;
       if (!input->ReadLittleEndian64(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddFixed64(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddFixed64(number, value);
       return true;
     }
     case WireFormatLite::WIRETYPE_LENGTH_DELIMITED: {
-      uint32 length;
+      uint32_t length;
       if (!input->ReadVarint32(&length)) return false;
-      if (unknown_fields == NULL) {
+      if (unknown_fields == nullptr) {
         if (!input->Skip(length)) return false;
       } else {
         if (!input->ReadString(unknown_fields->AddLengthDelimited(number),
@@ -116,8 +117,8 @@
     }
     case WireFormatLite::WIRETYPE_START_GROUP: {
       if (!input->IncrementRecursionDepth()) return false;
-      if (!SkipMessage(input, (unknown_fields == NULL)
-                                  ? NULL
+      if (!SkipMessage(input, (unknown_fields == nullptr)
+                                  ? nullptr
                                   : unknown_fields->AddGroup(number))) {
         return false;
       }
@@ -134,9 +135,9 @@
       return false;
     }
     case WireFormatLite::WIRETYPE_FIXED32: {
-      uint32 value;
+      uint32_t value;
       if (!input->ReadLittleEndian32(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddFixed32(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddFixed32(number, value);
       return true;
     }
     default: {
@@ -148,7 +149,7 @@
 bool WireFormat::SkipMessage(io::CodedInputStream* input,
                              UnknownFieldSet* unknown_fields) {
   while (true) {
-    uint32 tag = input->ReadTag();
+    uint32_t tag = input->ReadTag();
     if (tag == 0) {
       // End of input.  This is a valid place to end, so return true.
       return true;
@@ -166,11 +167,11 @@
 }
 
 bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
-                                                uint32 field_number,
+                                                uint32_t field_number,
                                                 bool (*is_valid)(int),
                                                 UnknownFieldSet* unknown_fields,
                                                 RepeatedField<int>* values) {
-  uint32 length;
+  uint32_t length;
   if (!input->ReadVarint32(&length)) return false;
   io::CodedInputStream::Limit limit = input->PushLimit(length);
   while (input->BytesUntilLimit() > 0) {
@@ -179,7 +180,7 @@
             input, &value)) {
       return false;
     }
-    if (is_valid == NULL || is_valid(value)) {
+    if (is_valid == nullptr || is_valid(value)) {
       values->Add(value);
     } else {
       unknown_fields->AddVarint(field_number, value);
@@ -189,8 +190,8 @@
   return true;
 }
 
-uint8* WireFormat::InternalSerializeUnknownFieldsToArray(
-    const UnknownFieldSet& unknown_fields, uint8* target,
+uint8_t* WireFormat::InternalSerializeUnknownFieldsToArray(
+    const UnknownFieldSet& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   for (int i = 0; i < unknown_fields.field_count(); i++) {
     const UnknownField& field = unknown_fields.field(i);
@@ -227,8 +228,8 @@
   return target;
 }
 
-uint8* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(
-    const UnknownFieldSet& unknown_fields, uint8* target,
+uint8_t* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(
+    const UnknownFieldSet& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   for (int i = 0; i < unknown_fields.field_count(); i++) {
     const UnknownField& field = unknown_fields.field(i);
@@ -278,12 +279,12 @@
       case UnknownField::TYPE_FIXED32:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
             field.number(), WireFormatLite::WIRETYPE_FIXED32));
-        size += sizeof(int32);
+        size += sizeof(int32_t);
         break;
       case UnknownField::TYPE_FIXED64:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
             field.number(), WireFormatLite::WIRETYPE_FIXED64));
-        size += sizeof(int64);
+        size += sizeof(int64_t);
         break;
       case UnknownField::TYPE_LENGTH_DELIMITED:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
@@ -334,7 +335,7 @@
   const Reflection* message_reflection = message->GetReflection();
 
   while (true) {
-    uint32 tag = input->ReadTag();
+    uint32_t tag = input->ReadTag();
     if (tag == 0) {
       // End of input.  This is a valid place to end, so return true.
       return true;
@@ -346,15 +347,15 @@
       return true;
     }
 
-    const FieldDescriptor* field = NULL;
+    const FieldDescriptor* field = nullptr;
 
-    if (descriptor != NULL) {
+    if (descriptor != nullptr) {
       int field_number = WireFormatLite::GetTagFieldNumber(tag);
       field = descriptor->FindFieldByNumber(field_number);
 
       // If that failed, check if the field is an extension.
-      if (field == NULL && descriptor->IsExtensionNumber(field_number)) {
-        if (input->GetExtensionPool() == NULL) {
+      if (field == nullptr && descriptor->IsExtensionNumber(field_number)) {
+        if (input->GetExtensionPool() == nullptr) {
           field = message_reflection->FindKnownExtensionByNumber(field_number);
         } else {
           field = input->GetExtensionPool()->FindExtensionByNumber(
@@ -364,7 +365,7 @@
 
       // If that failed, but we're a MessageSet, and this is the tag for a
       // MessageSet item, then parse that.
-      if (field == NULL && descriptor->options().message_set_wire_format() &&
+      if (field == nullptr && descriptor->options().message_set_wire_format() &&
           tag == WireFormatLite::kMessageSetItemStartTag) {
         if (!ParseAndMergeMessageSetItem(input, message)) {
           return false;
@@ -380,20 +381,20 @@
 }
 
 bool WireFormat::SkipMessageSetField(io::CodedInputStream* input,
-                                     uint32 field_number,
+                                     uint32_t field_number,
                                      UnknownFieldSet* unknown_fields) {
-  uint32 length;
+  uint32_t length;
   if (!input->ReadVarint32(&length)) return false;
   return input->ReadString(unknown_fields->AddLengthDelimited(field_number),
                            length);
 }
 
-bool WireFormat::ParseAndMergeMessageSetField(uint32 field_number,
+bool WireFormat::ParseAndMergeMessageSetField(uint32_t field_number,
                                               const FieldDescriptor* field,
                                               Message* message,
                                               io::CodedInputStream* input) {
   const Reflection* message_reflection = message->GetReflection();
-  if (field == NULL) {
+  if (field == nullptr) {
     // We store unknown MessageSet extensions as groups.
     return SkipMessageSetField(
         input, field_number, message_reflection->MutableUnknownFields(message));
@@ -415,14 +416,14 @@
 }
 
 bool WireFormat::ParseAndMergeField(
-    uint32 tag,
-    const FieldDescriptor* field,  // May be NULL for unknown
+    uint32_t tag,
+    const FieldDescriptor* field,  // May be nullptr for unknown
     Message* message, io::CodedInputStream* input) {
   const Reflection* message_reflection = message->GetReflection();
 
   enum { UNKNOWN, NORMAL_FORMAT, PACKED_FORMAT } value_format;
 
-  if (field == NULL) {
+  if (field == nullptr) {
     value_format = UNKNOWN;
   } else if (WireFormatLite::GetTagWireType(tag) ==
              WireTypeForFieldType(field->type())) {
@@ -441,7 +442,7 @@
     return SkipField(input, tag,
                      message_reflection->MutableUnknownFields(message));
   } else if (value_format == PACKED_FORMAT) {
-    uint32 length;
+    uint32_t length;
     if (!input->ReadVarint32(&length)) return false;
     io::CodedInputStream::Limit limit = input->PushLimit(length);
 
@@ -459,17 +460,17 @@
     break;                                                                     \
   }
 
-      HANDLE_PACKED_TYPE(INT32, int32, Int32)
-      HANDLE_PACKED_TYPE(INT64, int64, Int64)
-      HANDLE_PACKED_TYPE(SINT32, int32, Int32)
-      HANDLE_PACKED_TYPE(SINT64, int64, Int64)
-      HANDLE_PACKED_TYPE(UINT32, uint32, UInt32)
-      HANDLE_PACKED_TYPE(UINT64, uint64, UInt64)
+      HANDLE_PACKED_TYPE(INT32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(INT64, int64_t, Int64)
+      HANDLE_PACKED_TYPE(SINT32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(SINT64, int64_t, Int64)
+      HANDLE_PACKED_TYPE(UINT32, uint32_t, UInt32)
+      HANDLE_PACKED_TYPE(UINT64, uint64_t, UInt64)
 
-      HANDLE_PACKED_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_PACKED_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_PACKED_TYPE(SFIXED32, int32, Int32)
-      HANDLE_PACKED_TYPE(SFIXED64, int64, Int64)
+      HANDLE_PACKED_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_PACKED_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_PACKED_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_PACKED_TYPE(FLOAT, float, Float)
       HANDLE_PACKED_TYPE(DOUBLE, double, Double)
@@ -489,12 +490,12 @@
           } else {
             const EnumValueDescriptor* enum_value =
                 field->enum_type()->FindValueByNumber(value);
-            if (enum_value != NULL) {
+            if (enum_value != nullptr) {
               message_reflection->AddEnum(message, field, enum_value);
             } else {
               // The enum value is not one of the known values.  Add it to the
               // UnknownFieldSet.
-              int64 sign_extended_value = static_cast<int64>(value);
+              int64_t sign_extended_value = static_cast<int64_t>(value);
               message_reflection->MutableUnknownFields(message)->AddVarint(
                   WireFormatLite::GetTagFieldNumber(tag), sign_extended_value);
             }
@@ -532,17 +533,17 @@
     break;                                                                    \
   }
 
-      HANDLE_TYPE(INT32, int32, Int32)
-      HANDLE_TYPE(INT64, int64, Int64)
-      HANDLE_TYPE(SINT32, int32, Int32)
-      HANDLE_TYPE(SINT64, int64, Int64)
-      HANDLE_TYPE(UINT32, uint32, UInt32)
-      HANDLE_TYPE(UINT64, uint64, UInt64)
+      HANDLE_TYPE(INT32, int32_t, Int32)
+      HANDLE_TYPE(INT64, int64_t, Int64)
+      HANDLE_TYPE(SINT32, int32_t, Int32)
+      HANDLE_TYPE(SINT64, int64_t, Int64)
+      HANDLE_TYPE(UINT32, uint32_t, UInt32)
+      HANDLE_TYPE(UINT64, uint64_t, UInt64)
 
-      HANDLE_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_TYPE(SFIXED32, int32, Int32)
-      HANDLE_TYPE(SFIXED64, int64, Int64)
+      HANDLE_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_TYPE(FLOAT, float, Float)
       HANDLE_TYPE(DOUBLE, double, Double)
@@ -641,8 +642,8 @@
       return ParseAndMergeMessageSetField(type_id, field, message, input);
     }
 
-    bool SkipField(uint32 tag, io::CodedInputStream* input) {
-      return WireFormat::SkipField(input, tag, NULL);
+    bool SkipField(uint32_t tag, io::CodedInputStream* input) {
+      return WireFormat::SkipField(input, tag, nullptr);
     }
 
     const Reflection* message_reflection;
@@ -657,19 +658,24 @@
   const char* _InternalParse(const char* ptr, internal::ParseContext* ctx) {
     // Parse a MessageSetItem
     auto metadata = reflection->MutableInternalMetadata(msg);
+    enum class State { kNoTag, kHasType, kHasPayload, kDone };
+    State state = State::kNoTag;
+
     std::string payload;
-    uint32 type_id = 0;
-    bool payload_read = false;
+    uint32_t type_id = 0;
     while (!ctx->Done(&ptr)) {
       // We use 64 bit tags in order to allow typeid's that span the whole
       // range of 32 bit numbers.
-      uint32 tag = static_cast<uint8>(*ptr++);
+      uint32_t tag = static_cast<uint8_t>(*ptr++);
       if (tag == WireFormatLite::kMessageSetTypeIdTag) {
-        uint64 tmp;
+        uint64_t tmp;
         ptr = ParseBigVarint(ptr, &tmp);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        type_id = tmp;
-        if (payload_read) {
+        if (state == State::kNoTag) {
+          type_id = tmp;
+          state = State::kHasType;
+        } else if (state == State::kHasPayload) {
+          type_id = tmp;
           const FieldDescriptor* field;
           if (ctx->data().pool == nullptr) {
             field = reflection->FindKnownExtensionByNumber(type_id);
@@ -696,17 +702,17 @@
             GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
                                            tmp_ctx.EndedAtLimit());
           }
-          type_id = 0;
+          state = State::kDone;
         }
         continue;
       } else if (tag == WireFormatLite::kMessageSetMessageTag) {
-        if (type_id == 0) {
-          int32 size = ReadSize(&ptr);
+        if (state == State::kNoTag) {
+          int32_t size = ReadSize(&ptr);
           GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
           ptr = ctx->ReadString(ptr, size, &payload);
           GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-          payload_read = true;
-        } else {
+          state = State::kHasPayload;
+        } else if (state == State::kHasType) {
           // We're now parsing the payload
           const FieldDescriptor* field = nullptr;
           if (descriptor->IsExtensionNumber(type_id)) {
@@ -718,9 +724,14 @@
             }
           }
           ptr = WireFormat::_InternalParseAndMergeField(
-              msg, ptr, ctx, static_cast<uint64>(type_id) * 8 + 2, reflection,
+              msg, ptr, ctx, static_cast<uint64_t>(type_id) * 8 + 2, reflection,
               field);
-          type_id = 0;
+          state = State::kDone;
+        } else {
+          int32_t size = ReadSize(&ptr);
+          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+          ptr = ctx->Skip(ptr, size);
+          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
         }
       } else {
         // An unknown field in MessageSetItem.
@@ -740,7 +751,7 @@
 
   const char* ParseMessageSet(const char* ptr, internal::ParseContext* ctx) {
     while (!ctx->Done(&ptr)) {
-      uint32 tag;
+      uint32_t tag;
       ptr = ReadTag(ptr, &tag);
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr)) return nullptr;
       if (tag == 0 || (tag & 7) == WireFormatLite::WIRETYPE_END_GROUP) {
@@ -786,7 +797,7 @@
     return message_set.ParseMessageSet(ptr, ctx);
   }
   while (!ctx->Done(&ptr)) {
-    uint32 tag;
+    uint32_t tag;
     ptr = ReadTag(ptr, &tag);
     if (PROTOBUF_PREDICT_FALSE(ptr == nullptr)) return nullptr;
     if (tag == 0 || (tag & 7) == WireFormatLite::WIRETYPE_END_GROUP) {
@@ -815,7 +826,7 @@
 }
 
 const char* WireFormat::_InternalParseAndMergeField(
-    Message* msg, const char* ptr, internal::ParseContext* ctx, uint64 tag,
+    Message* msg, const char* ptr, internal::ParseContext* ctx, uint64_t tag,
     const Reflection* reflection, const FieldDescriptor* field) {
   if (field == nullptr) {
     // unknown field set parser takes 64bit tags, because message set type ids
@@ -836,17 +847,17 @@
     return ptr;                                                             \
   }
 
-        HANDLE_PACKED_TYPE(INT32, int32, Int32)
-        HANDLE_PACKED_TYPE(INT64, int64, Int64)
-        HANDLE_PACKED_TYPE(SINT32, int32, SInt32)
-        HANDLE_PACKED_TYPE(SINT64, int64, SInt64)
-        HANDLE_PACKED_TYPE(UINT32, uint32, UInt32)
-        HANDLE_PACKED_TYPE(UINT64, uint64, UInt64)
+        HANDLE_PACKED_TYPE(INT32, int32_t, Int32)
+        HANDLE_PACKED_TYPE(INT64, int64_t, Int64)
+        HANDLE_PACKED_TYPE(SINT32, int32_t, SInt32)
+        HANDLE_PACKED_TYPE(SINT64, int64_t, SInt64)
+        HANDLE_PACKED_TYPE(UINT32, uint32_t, UInt32)
+        HANDLE_PACKED_TYPE(UINT64, uint64_t, UInt64)
 
-        HANDLE_PACKED_TYPE(FIXED32, uint32, Fixed32)
-        HANDLE_PACKED_TYPE(FIXED64, uint64, Fixed64)
-        HANDLE_PACKED_TYPE(SFIXED32, int32, SFixed32)
-        HANDLE_PACKED_TYPE(SFIXED64, int64, SFixed64)
+        HANDLE_PACKED_TYPE(FIXED32, uint32_t, Fixed32)
+        HANDLE_PACKED_TYPE(FIXED64, uint64_t, Fixed64)
+        HANDLE_PACKED_TYPE(SFIXED32, int32_t, SFixed32)
+        HANDLE_PACKED_TYPE(SFIXED64, int64_t, SFixed64)
 
         HANDLE_PACKED_TYPE(FLOAT, float, Float)
         HANDLE_PACKED_TYPE(DOUBLE, double, Double)
@@ -863,7 +874,7 @@
             ptr = internal::PackedEnumParser(rep_enum, ptr, ctx);
           } else {
             return ctx->ReadPackedVarint(
-                ptr, [rep_enum, field, reflection, msg](uint64 val) {
+                ptr, [rep_enum, field, reflection, msg](uint64_t val) {
                   if (field->enum_type()->FindValueByNumber(val) != nullptr) {
                     rep_enum->Add(val);
                   } else {
@@ -906,14 +917,14 @@
     return ptr;                                           \
   }
 
-    HANDLE_TYPE(BOOL, uint64, Bool)
-    HANDLE_TYPE(INT32, uint32, Int32)
-    HANDLE_TYPE(INT64, uint64, Int64)
-    HANDLE_TYPE(UINT32, uint32, UInt32)
-    HANDLE_TYPE(UINT64, uint64, UInt64)
+    HANDLE_TYPE(BOOL, uint64_t, Bool)
+    HANDLE_TYPE(INT32, uint32_t, Int32)
+    HANDLE_TYPE(INT64, uint64_t, Int64)
+    HANDLE_TYPE(UINT32, uint32_t, UInt32)
+    HANDLE_TYPE(UINT64, uint64_t, UInt64)
 
     case FieldDescriptor::TYPE_SINT32: {
-      int32 value = ReadVarintZigZag32(&ptr);
+      int32_t value = ReadVarintZigZag32(&ptr);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
         reflection->AddInt32(msg, field, value);
@@ -923,7 +934,7 @@
       return ptr;
     }
     case FieldDescriptor::TYPE_SINT64: {
-      int64 value = ReadVarintZigZag64(&ptr);
+      int64_t value = ReadVarintZigZag64(&ptr);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
         reflection->AddInt64(msg, field, value);
@@ -946,10 +957,10 @@
     return ptr;                                           \
   }
 
-      HANDLE_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_TYPE(SFIXED32, int32, Int32)
-      HANDLE_TYPE(SFIXED64, int64, Int64)
+      HANDLE_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_TYPE(FLOAT, float, Float)
       HANDLE_TYPE(DOUBLE, double, Double)
@@ -957,7 +968,7 @@
 #undef HANDLE_TYPE
 
     case FieldDescriptor::TYPE_ENUM: {
-      uint32 value;
+      uint32_t value;
       ptr = VarintParse(ptr, &value);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
@@ -992,9 +1003,9 @@
         }
       }
       if (field->is_repeated()) {
-        reflection->AddString(msg, field, value);
+        reflection->AddString(msg, field, std::move(value));
       } else {
-        reflection->SetString(msg, field, value);
+        reflection->SetString(msg, field, std::move(value));
       }
       return ptr;
     }
@@ -1030,8 +1041,8 @@
 
 // ===================================================================
 
-uint8* WireFormat::_InternalSerialize(const Message& message, uint8* target,
-                                      io::EpsCopyOutputStream* stream) {
+uint8_t* WireFormat::_InternalSerialize(const Message& message, uint8_t* target,
+                                        io::EpsCopyOutputStream* stream) {
   const Descriptor* descriptor = message.GetDescriptor();
   const Reflection* message_reflection = message.GetReflection();
 
@@ -1059,9 +1070,9 @@
   }
 }
 
-uint8* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
-                                      const MapKey& value, uint8* target,
-                                      io::EpsCopyOutputStream* stream) {
+uint8_t* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
+                                        const MapKey& value, uint8_t* target,
+                                        io::EpsCopyOutputStream* stream) {
   target = stream->EnsureSpace(target);
   switch (field->type()) {
     case FieldDescriptor::TYPE_DOUBLE:
@@ -1096,9 +1107,9 @@
   return target;
 }
 
-static uint8* SerializeMapValueRefWithCachedSizes(
-    const FieldDescriptor* field, const MapValueConstRef& value, uint8* target,
-    io::EpsCopyOutputStream* stream) {
+static uint8_t* SerializeMapValueRefWithCachedSizes(
+    const FieldDescriptor* field, const MapValueConstRef& value,
+    uint8_t* target, io::EpsCopyOutputStream* stream) {
   target = stream->EnsureSpace(target);
   switch (field->type()) {
 #define CASE_TYPE(FieldType, CamelFieldType, CamelCppType)   \
@@ -1125,10 +1136,11 @@
     case FieldDescriptor::TYPE_BYTES:
       target = stream->WriteString(2, value.GetStringValue(), target);
       break;
-    case FieldDescriptor::TYPE_MESSAGE:
-      target = WireFormatLite::InternalWriteMessage(2, value.GetMessageValue(),
+    case FieldDescriptor::TYPE_MESSAGE: {
+      auto& msg = value.GetMessageValue();
+      target = WireFormatLite::InternalWriteMessage(2, msg, msg.GetCachedSize(),
                                                     target, stream);
-      break;
+    } break;
     case FieldDescriptor::TYPE_GROUP:
       target = WireFormatLite::InternalWriteGroup(2, value.GetMessageValue(),
                                                   target, stream);
@@ -1180,11 +1192,11 @@
   };
 };
 
-static uint8* InternalSerializeMapEntry(const FieldDescriptor* field,
-                                        const MapKey& key,
-                                        const MapValueConstRef& value,
-                                        uint8* target,
-                                        io::EpsCopyOutputStream* stream) {
+static uint8_t* InternalSerializeMapEntry(const FieldDescriptor* field,
+                                          const MapKey& key,
+                                          const MapValueConstRef& value,
+                                          uint8_t* target,
+                                          io::EpsCopyOutputStream* stream) {
   const FieldDescriptor* key_field = field->message_type()->field(0);
   const FieldDescriptor* value_field = field->message_type()->field(1);
 
@@ -1201,9 +1213,10 @@
   return target;
 }
 
-uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
-                                          const Message& message, uint8* target,
-                                          io::EpsCopyOutputStream* stream) {
+uint8_t* WireFormat::InternalSerializeField(const FieldDescriptor* field,
+                                            const Message& message,
+                                            uint8_t* target,
+                                            io::EpsCopyOutputStream* stream) {
   const Reflection* message_reflection = message.GetReflection();
 
   if (field->is_extension() &&
@@ -1286,12 +1299,12 @@
     break;                                                                     \
   }
 
-      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)
-      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)
-      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)
-      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(INT32, int32_t, Int32, Int32)
+      HANDLE_PRIMITIVE_TYPE(INT64, int64_t, Int64, Int64)
+      HANDLE_PRIMITIVE_TYPE(SINT32, int32_t, SInt32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SINT64, int64_t, SInt64, Int64)
+      HANDLE_PRIMITIVE_TYPE(UINT32, uint32_t, UInt32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(UINT64, uint64_t, UInt64, UInt64)
       HANDLE_PRIMITIVE_TYPE(ENUM, int, Enum, Enum)
 
 #undef HANDLE_PRIMITIVE_TYPE
@@ -1303,10 +1316,10 @@
     break;                                                                     \
   }
 
-      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)
-      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)
+      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32_t, Fixed32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64_t, Fixed64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32_t, SFixed32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64_t, SFixed64, Int64)
 
       HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)
       HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)
@@ -1319,6 +1332,16 @@
     return target;
   }
 
+  auto get_message_from_field = [&message, &map_entries, message_reflection](
+                                    const FieldDescriptor* field, int j) {
+    if (!field->is_repeated()) {
+      return &message_reflection->GetMessage(message, field);
+    }
+    if (!map_entries.empty()) {
+      return map_entries[j];
+    }
+    return &message_reflection->GetRepeatedMessage(message, field, j);
+  };
   for (int j = 0; j < count; j++) {
     target = stream->EnsureSpace(target);
     switch (field->type()) {
@@ -1334,17 +1357,17 @@
     break;                                                                    \
   }
 
-      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)
-      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)
-      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)
-      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(INT32, int32_t, Int32, Int32)
+      HANDLE_PRIMITIVE_TYPE(INT64, int64_t, Int64, Int64)
+      HANDLE_PRIMITIVE_TYPE(SINT32, int32_t, SInt32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SINT64, int64_t, SInt64, Int64)
+      HANDLE_PRIMITIVE_TYPE(UINT32, uint32_t, UInt32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(UINT64, uint64_t, UInt64, UInt64)
 
-      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)
-      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)
+      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32_t, Fixed32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64_t, Fixed64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32_t, SFixed32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64_t, SFixed64, Int64)
 
       HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)
       HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)
@@ -1352,22 +1375,17 @@
       HANDLE_PRIMITIVE_TYPE(BOOL, bool, Bool, Bool)
 #undef HANDLE_PRIMITIVE_TYPE
 
-#define HANDLE_TYPE(TYPE, TYPE_METHOD, CPPTYPE_METHOD)                         \
-  case FieldDescriptor::TYPE_##TYPE:                                           \
-    target = WireFormatLite::InternalWrite##TYPE_METHOD(                       \
-        field->number(),                                                       \
-        field->is_repeated()                                                   \
-            ? (map_entries.empty()                                             \
-                   ? message_reflection->GetRepeated##CPPTYPE_METHOD(message,  \
-                                                                     field, j) \
-                   : *map_entries[j])                                          \
-            : message_reflection->Get##CPPTYPE_METHOD(message, field),         \
-        target, stream);                                                       \
-    break;
+      case FieldDescriptor::TYPE_GROUP: {
+        auto* msg = get_message_from_field(field, j);
+        target = WireFormatLite::InternalWriteGroup(field->number(), *msg,
+                                                    target, stream);
+      } break;
 
-      HANDLE_TYPE(GROUP, Group, Message)
-      HANDLE_TYPE(MESSAGE, Message, Message)
-#undef HANDLE_TYPE
+      case FieldDescriptor::TYPE_MESSAGE: {
+        auto* msg = get_message_from_field(field, j);
+        target = WireFormatLite::InternalWriteMessage(
+            field->number(), *msg, msg->GetCachedSize(), target, stream);
+      } break;
 
       case FieldDescriptor::TYPE_ENUM: {
         const EnumValueDescriptor* value =
@@ -1418,8 +1436,8 @@
   return target;
 }
 
-uint8* WireFormat::InternalSerializeMessageSetItem(
-    const FieldDescriptor* field, const Message& message, uint8* target,
+uint8_t* WireFormat::InternalSerializeMessageSetItem(
+    const FieldDescriptor* field, const Message& message, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   const Reflection* message_reflection = message.GetReflection();
 
@@ -1431,9 +1449,10 @@
   target = WireFormatLite::WriteUInt32ToArray(
       WireFormatLite::kMessageSetTypeIdNumber, field->number(), target);
   // Write message.
+  auto& msg = message_reflection->GetMessage(message, field);
   target = WireFormatLite::InternalWriteMessage(
-      WireFormatLite::kMessageSetMessageNumber,
-      message_reflection->GetMessage(message, field), target, stream);
+      WireFormatLite::kMessageSetMessageNumber, msg, msg.GetCachedSize(),
+      target, stream);
   // End group.
   target = stream->EnsureSpace(target);
   target = io::CodedOutputStream::WriteTagToArray(
diff -ur protobuf-3.17.3/src/google/protobuf/wire_format_lite.h protobuf-3.17.3-patched/src/google/protobuf/wire_format_lite.h
--- protobuf-3.17.3/src/google/protobuf/wire_format_lite.h	2021-06-08 07:11:10
+++ protobuf-3.17.3-patched/src/google/protobuf/wire_format_lite.h	2024-06-21 11:09:27
@@ -40,16 +40,17 @@
 #ifndef GOOGLE_PROTOBUF_WIRE_FORMAT_LITE_H__
 #define GOOGLE_PROTOBUF_WIRE_FORMAT_LITE_H__
 
+
 #include <string>
 
 #include <google/protobuf/stubs/common.h>
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/port.h>
+#include <google/protobuf/stubs/casts.h>
 #include <google/protobuf/arenastring.h>
 #include <google/protobuf/message_lite.h>
-#include <google/protobuf/port.h>
 #include <google/protobuf/repeated_field.h>
-#include <google/protobuf/stubs/casts.h>
 
 // Do UTF-8 validation on string type in Debug build only
 #ifndef NDEBUG
@@ -66,6 +67,8 @@
 // #pragma pop_macro("TYPE_BOOL")
 #undef TYPE_BOOL
 
+
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -157,16 +160,16 @@
   // Number of bits in a tag which identify the wire type.
   static constexpr int kTagTypeBits = 3;
   // Mask for those bits.
-  static constexpr uint32 kTagTypeMask = (1 << kTagTypeBits) - 1;
+  static constexpr uint32_t kTagTypeMask = (1 << kTagTypeBits) - 1;
 
   // Helper functions for encoding and decoding tags.  (Inlined below and in
   // _inl.h)
   //
   // This is different from MakeTag(field->number(), field->type()) in the
   // case of packed repeated fields.
-  constexpr static uint32 MakeTag(int field_number, WireType type);
-  static WireType GetTagWireType(uint32 tag);
-  static int GetTagFieldNumber(uint32 tag);
+  constexpr static uint32_t MakeTag(int field_number, WireType type);
+  static WireType GetTagWireType(uint32_t tag);
+  static int GetTagFieldNumber(uint32_t tag);
 
   // Compute the byte size of a tag.  For groups, this includes both the start
   // and end tags.
@@ -177,12 +180,12 @@
   // positioned immediately after the tag.  Skipped values are simply
   // discarded, not recorded anywhere.  See WireFormat::SkipField() for a
   // version that records to an UnknownFieldSet.
-  static bool SkipField(io::CodedInputStream* input, uint32 tag);
+  static bool SkipField(io::CodedInputStream* input, uint32_t tag);
 
   // Skips a field value with the given tag.  The input should start
   // positioned immediately after the tag. Skipped values are recorded to a
   // CodedOutputStream.
-  static bool SkipField(io::CodedInputStream* input, uint32 tag,
+  static bool SkipField(io::CodedInputStream* input, uint32_t tag,
                         io::CodedOutputStream* output);
 
   // Reads and ignores a message from the input.  Skipped values are simply
@@ -200,7 +203,7 @@
   // as a switch case or a template input.  WireFormatLite::MakeTag() is more
   // type-safe, though, so prefer it if possible.
 #define GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(FIELD_NUMBER, TYPE) \
-  static_cast<uint32>((static_cast<uint32>(FIELD_NUMBER) << 3) | (TYPE))
+  static_cast<uint32_t>((static_cast<uint32_t>(FIELD_NUMBER) << 3) | (TYPE))
 
   // These are the tags for the old MessageSet format, which was defined as:
   //   message MessageSet {
@@ -227,10 +230,10 @@
   // Helper functions for converting between floats/doubles and IEEE-754
   // uint32s/uint64s so that they can be written.  (Assumes your platform
   // uses IEEE-754 floats.)
-  static uint32 EncodeFloat(float value);
-  static float DecodeFloat(uint32 value);
-  static uint64 EncodeDouble(double value);
-  static double DecodeDouble(uint64 value);
+  static uint32_t EncodeFloat(float value);
+  static float DecodeFloat(uint32_t value);
+  static uint64_t EncodeDouble(double value);
+  static double DecodeDouble(uint64_t value);
 
   // Helper functions for mapping signed integers to unsigned integers in
   // such a way that numbers with small magnitudes will encode to smaller
@@ -238,10 +241,10 @@
   // number and varint-encode it, it will always take 10 bytes, defeating
   // the purpose of varint.  So, for the "sint32" and "sint64" field types,
   // we ZigZag-encode the values.
-  static uint32 ZigZagEncode32(int32 n);
-  static int32 ZigZagDecode32(uint32 n);
-  static uint64 ZigZagEncode64(int64 n);
-  static int64 ZigZagDecode64(uint64 n);
+  static uint32_t ZigZagEncode32(int32_t n);
+  static int32_t ZigZagDecode32(uint32_t n);
+  static uint64_t ZigZagEncode64(int64_t n);
+  static int64_t ZigZagDecode64(uint64_t n);
 
   // =================================================================
   // Methods for reading/writing individual field.
@@ -261,13 +264,13 @@
   // protocol compiler.
   template <typename CType, enum FieldType DeclaredType>
   PROTOBUF_NDEBUG_INLINE static bool ReadRepeatedPrimitive(
-      int tag_size, uint32 tag, io::CodedInputStream* input,
+      int tag_size, uint32_t tag, io::CodedInputStream* input,
       RepeatedField<CType>* value);
 
   // Identical to ReadRepeatedPrimitive, except will not inline the
   // implementation.
   template <typename CType, enum FieldType DeclaredType>
-  static bool ReadRepeatedPrimitiveNoInline(int tag_size, uint32 tag,
+  static bool ReadRepeatedPrimitiveNoInline(int tag_size, uint32_t tag,
                                             io::CodedInputStream* input,
                                             RepeatedField<CType>* value);
 
@@ -277,8 +280,8 @@
   // This is only implemented for the types with fixed wire size, e.g.
   // float, double, and the (s)fixed* types.
   template <typename CType, enum FieldType DeclaredType>
-  PROTOBUF_NDEBUG_INLINE static const uint8* ReadPrimitiveFromArray(
-      const uint8* buffer, CType* value);
+  PROTOBUF_NDEBUG_INLINE static const uint8_t* ReadPrimitiveFromArray(
+      const uint8_t* buffer, CType* value);
 
   // Reads a primitive packed field.
   //
@@ -293,14 +296,15 @@
   static bool ReadPackedPrimitiveNoInline(io::CodedInputStream* input,
                                           RepeatedField<CType>* value);
 
-  // Read a packed enum field. If the is_valid function is not NULL, values for
-  // which is_valid(value) returns false are silently dropped.
+  // Read a packed enum field. If the is_valid function is not nullptr, values
+  // for which is_valid(value) returns false are silently dropped.
   static bool ReadPackedEnumNoInline(io::CodedInputStream* input,
                                      bool (*is_valid)(int),
                                      RepeatedField<int>* values);
 
-  // Read a packed enum field. If the is_valid function is not NULL, values for
-  // which is_valid(value) returns false are appended to unknown_fields_stream.
+  // Read a packed enum field. If the is_valid function is not nullptr, values
+  // for which is_valid(value) returns false are appended to
+  // unknown_fields_stream.
   static bool ReadPackedEnumPreserveUnknowns(
       io::CodedInputStream* input, int field_number, bool (*is_valid)(int),
       io::CodedOutputStream* unknown_fields_stream, RepeatedField<int>* values);
@@ -350,25 +354,25 @@
 
   // Write fields, without tags.
   PROTOBUF_NDEBUG_INLINE static void WriteInt32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteInt64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteUInt32NoTag(
-      uint32 value, io::CodedOutputStream* output);
+      uint32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteUInt64NoTag(
-      uint64 value, io::CodedOutputStream* output);
+      uint64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSInt32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSInt64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFixed32NoTag(
-      uint32 value, io::CodedOutputStream* output);
+      uint32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFixed64NoTag(
-      uint64 value, io::CodedOutputStream* output);
+      uint64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSFixed32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSFixed64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFloatNoTag(
       float value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteDoubleNoTag(
@@ -383,37 +387,37 @@
                               io::CodedOutputStream* output);
   static void WriteDoubleArray(const double* a, int n,
                                io::CodedOutputStream* output);
-  static void WriteFixed32Array(const uint32* a, int n,
+  static void WriteFixed32Array(const uint32_t* a, int n,
                                 io::CodedOutputStream* output);
-  static void WriteFixed64Array(const uint64* a, int n,
+  static void WriteFixed64Array(const uint64_t* a, int n,
                                 io::CodedOutputStream* output);
-  static void WriteSFixed32Array(const int32* a, int n,
+  static void WriteSFixed32Array(const int32_t* a, int n,
                                  io::CodedOutputStream* output);
-  static void WriteSFixed64Array(const int64* a, int n,
+  static void WriteSFixed64Array(const int64_t* a, int n,
                                  io::CodedOutputStream* output);
   static void WriteBoolArray(const bool* a, int n,
                              io::CodedOutputStream* output);
 
   // Write fields, including tags.
-  static void WriteInt32(int field_number, int32 value,
+  static void WriteInt32(int field_number, int32_t value,
                          io::CodedOutputStream* output);
-  static void WriteInt64(int field_number, int64 value,
+  static void WriteInt64(int field_number, int64_t value,
                          io::CodedOutputStream* output);
-  static void WriteUInt32(int field_number, uint32 value,
+  static void WriteUInt32(int field_number, uint32_t value,
                           io::CodedOutputStream* output);
-  static void WriteUInt64(int field_number, uint64 value,
+  static void WriteUInt64(int field_number, uint64_t value,
                           io::CodedOutputStream* output);
-  static void WriteSInt32(int field_number, int32 value,
+  static void WriteSInt32(int field_number, int32_t value,
                           io::CodedOutputStream* output);
-  static void WriteSInt64(int field_number, int64 value,
+  static void WriteSInt64(int field_number, int64_t value,
                           io::CodedOutputStream* output);
-  static void WriteFixed32(int field_number, uint32 value,
+  static void WriteFixed32(int field_number, uint32_t value,
                            io::CodedOutputStream* output);
-  static void WriteFixed64(int field_number, uint64 value,
+  static void WriteFixed64(int field_number, uint64_t value,
                            io::CodedOutputStream* output);
-  static void WriteSFixed32(int field_number, int32 value,
+  static void WriteSFixed32(int field_number, int32_t value,
                             io::CodedOutputStream* output);
-  static void WriteSFixed64(int field_number, int64 value,
+  static void WriteSFixed64(int field_number, int64_t value,
                             io::CodedOutputStream* output);
   static void WriteFloat(int field_number, float value,
                          io::CodedOutputStream* output);
@@ -459,228 +463,235 @@
                                            io::CodedOutputStream* output);
 
   // Like above, but use only *ToArray methods of CodedOutputStream.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteTagToArray(int field_number,
-                                                       WireType type,
-                                                       uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteTagToArray(int field_number,
+                                                         WireType type,
+                                                         uint8_t* target);
 
   // Write fields, without tags.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32NoTagToArray(int32 value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64NoTagToArray(int64 value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32NoTagToArray(uint32 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64NoTagToArray(uint64 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32NoTagToArray(int32 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64NoTagToArray(int64 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32NoTagToArray(uint32 value,
-                                                                uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64NoTagToArray(uint64 value,
-                                                                uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32NoTagToArray(int32 value,
-                                                                 uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64NoTagToArray(int64 value,
-                                                                 uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatNoTagToArray(float value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleNoTagToArray(double value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolNoTagToArray(bool value,
-                                                             uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumNoTagToArray(int value,
-                                                             uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32NoTagToArray(
+      uint32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64NoTagToArray(
+      uint64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32NoTagToArray(
+      uint32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64NoTagToArray(
+      uint64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatNoTagToArray(
+      float value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleNoTagToArray(
+      double value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolNoTagToArray(bool value,
+                                                               uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumNoTagToArray(int value,
+                                                               uint8_t* target);
 
   // Write fields, without tags.  These require that value.size() > 0.
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WritePrimitiveNoTagToArray(
-      const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*),
-      uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WritePrimitiveNoTagToArray(
+      const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+      uint8_t* target);
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixedNoTagToArray(
-      const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*),
-      uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixedNoTagToArray(
+      const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+      uint8_t* target);
 
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32NoTagToArray(
-      const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64NoTagToArray(
-      const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32NoTagToArray(
-      const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64NoTagToArray(
-      const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatNoTagToArray(
-      const RepeatedField<float>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleNoTagToArray(
-      const RepeatedField<double>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolNoTagToArray(
-      const RepeatedField<bool>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumNoTagToArray(
-      const RepeatedField<int>& value, uint8* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32NoTagToArray(
+      const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64NoTagToArray(
+      const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32NoTagToArray(
+      const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64NoTagToArray(
+      const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatNoTagToArray(
+      const RepeatedField<float>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleNoTagToArray(
+      const RepeatedField<double>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolNoTagToArray(
+      const RepeatedField<bool>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumNoTagToArray(
+      const RepeatedField<int>& value, uint8_t* output);
 
   // Write fields, including tags.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32ToArray(int field_number,
-                                                         int32 value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64ToArray(int field_number,
-                                                         int64 value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32ToArray(int field_number,
-                                                          uint32 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64ToArray(int field_number,
-                                                          uint64 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32ToArray(int field_number,
-                                                          int32 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64ToArray(int field_number,
-                                                          int64 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32ToArray(int field_number,
-                                                           uint32 value,
-                                                           uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64ToArray(int field_number,
-                                                           uint64 value,
-                                                           uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32ToArray(int field_number,
-                                                            int32 value,
-                                                            uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64ToArray(int field_number,
-                                                            int64 value,
-                                                            uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatToArray(int field_number,
-                                                         float value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleToArray(int field_number,
-                                                          double value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolToArray(int field_number,
-                                                        bool value,
-                                                        uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumToArray(int field_number,
-                                                        int value,
-                                                        uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32ToArray(int field_number,
+                                                           int32_t value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64ToArray(int field_number,
+                                                           int64_t value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32ToArray(int field_number,
+                                                            uint32_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64ToArray(int field_number,
+                                                            uint64_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32ToArray(int field_number,
+                                                            int32_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64ToArray(int field_number,
+                                                            int64_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32ToArray(int field_number,
+                                                             uint32_t value,
+                                                             uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64ToArray(int field_number,
+                                                             uint64_t value,
+                                                             uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32ToArray(int field_number,
+                                                              int32_t value,
+                                                              uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64ToArray(int field_number,
+                                                              int64_t value,
+                                                              uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatToArray(int field_number,
+                                                           float value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleToArray(int field_number,
+                                                            double value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolToArray(int field_number,
+                                                          bool value,
+                                                          uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumToArray(int field_number,
+                                                          int value,
+                                                          uint8_t* target);
 
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WritePrimitiveToArray(
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WritePrimitiveToArray(
       int field_number, const RepeatedField<T>& value,
-      uint8* (*Writer)(int, T, uint8*), uint8* target);
+      uint8_t* (*Writer)(int, T, uint8_t*), uint8_t* target);
 
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32ToArray(
-      int field_number, const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64ToArray(
-      int field_number, const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32ToArray(
-      int field_number, const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64ToArray(
-      int field_number, const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatToArray(
-      int field_number, const RepeatedField<float>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleToArray(
-      int field_number, const RepeatedField<double>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolToArray(
-      int field_number, const RepeatedField<bool>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumToArray(
-      int field_number, const RepeatedField<int>& value, uint8* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32ToArray(
+      int field_number, const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64ToArray(
+      int field_number, const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32ToArray(
+      int field_number, const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64ToArray(
+      int field_number, const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatToArray(
+      int field_number, const RepeatedField<float>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleToArray(
+      int field_number, const RepeatedField<double>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolToArray(
+      int field_number, const RepeatedField<bool>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumToArray(
+      int field_number, const RepeatedField<int>& value, uint8_t* output);
 
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteStringToArray(
-      int field_number, const std::string& value, uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBytesToArray(
-      int field_number, const std::string& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteStringToArray(
+      int field_number, const std::string& value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBytesToArray(
+      int field_number, const std::string& value, uint8_t* target);
 
   // Whether to serialize deterministically (e.g., map keys are
   // sorted) is a property of a CodedOutputStream, and in the process
   // of serialization, the "ToArray" variants may be invoked.  But they don't
   // have a CodedOutputStream available, so they get an additional parameter
   // telling them whether to serialize deterministically.
-  template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteGroup(
-      int field_number, const MessageType& value, uint8* target,
-      io::EpsCopyOutputStream* stream);
-  template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteMessage(
-      int field_number, const MessageType& value, uint8* target,
-      io::EpsCopyOutputStream* stream);
+  static uint8_t* InternalWriteGroup(int field_number, const MessageLite& value,
+                                     uint8_t* target,
+                                     io::EpsCopyOutputStream* stream);
+  static uint8_t* InternalWriteMessage(int field_number,
+                                       const MessageLite& value,
+                                       int cached_size, uint8_t* target,
+                                       io::EpsCopyOutputStream* stream);
 
   // Like above, but de-virtualize the call to SerializeWithCachedSizes().  The
   // pointer must point at an instance of MessageType, *not* a subclass (or
   // the subclass must not override SerializeWithCachedSizes()).
   template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteGroupNoVirtualToArray(
-      int field_number, const MessageType& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* InternalWriteGroupNoVirtualToArray(
+      int field_number, const MessageType& value, uint8_t* target);
   template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteMessageNoVirtualToArray(
-      int field_number, const MessageType& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* InternalWriteMessageNoVirtualToArray(
+      int field_number, const MessageType& value, uint8_t* target);
 
   // For backward-compatibility, the last four methods also have versions
   // that are non-deterministic always.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteGroupToArray(
-      int field_number, const MessageLite& value, uint8* target) {
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteGroupToArray(
+      int field_number, const MessageLite& value, uint8_t* target) {
     io::EpsCopyOutputStream stream(
         target,
         value.GetCachedSize() +
             static_cast<int>(2 * io::CodedOutputStream::VarintSize32(
-                                     static_cast<uint32>(field_number) << 3)),
+                                     static_cast<uint32_t>(field_number) << 3)),
         io::CodedOutputStream::IsDefaultSerializationDeterministic());
     return InternalWriteGroup(field_number, value, target, &stream);
   }
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteMessageToArray(
-      int field_number, const MessageLite& value, uint8* target) {
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteMessageToArray(
+      int field_number, const MessageLite& value, uint8_t* target) {
     int size = value.GetCachedSize();
     io::EpsCopyOutputStream stream(
         target,
         size + static_cast<int>(io::CodedOutputStream::VarintSize32(
-                                    static_cast<uint32>(field_number) << 3) +
+                                    static_cast<uint32_t>(field_number) << 3) +
                                 io::CodedOutputStream::VarintSize32(size)),
         io::CodedOutputStream::IsDefaultSerializationDeterministic());
-    return InternalWriteMessage(field_number, value, target, &stream);
+    return InternalWriteMessage(field_number, value, value.GetCachedSize(),
+                                target, &stream);
   }
 
   // Compute the byte size of a field.  The XxSize() functions do NOT include
   // the tag, so you must also call TagSize().  (This is because, for repeated
   // fields, you should only call TagSize() once and multiply it by the element
   // count, but you may have to call XxSize() for each individual element.)
-  static inline size_t Int32Size(int32 value);
-  static inline size_t Int64Size(int64 value);
-  static inline size_t UInt32Size(uint32 value);
-  static inline size_t UInt64Size(uint64 value);
-  static inline size_t SInt32Size(int32 value);
-  static inline size_t SInt64Size(int64 value);
+  static inline size_t Int32Size(int32_t value);
+  static inline size_t Int64Size(int64_t value);
+  static inline size_t UInt32Size(uint32_t value);
+  static inline size_t UInt64Size(uint64_t value);
+  static inline size_t SInt32Size(int32_t value);
+  static inline size_t SInt64Size(int64_t value);
   static inline size_t EnumSize(int value);
+  static inline size_t Int32SizePlusOne(int32_t value);
+  static inline size_t Int64SizePlusOne(int64_t value);
+  static inline size_t UInt32SizePlusOne(uint32_t value);
+  static inline size_t UInt64SizePlusOne(uint64_t value);
+  static inline size_t SInt32SizePlusOne(int32_t value);
+  static inline size_t SInt64SizePlusOne(int64_t value);
+  static inline size_t EnumSizePlusOne(int value);
 
-  static size_t Int32Size(const RepeatedField<int32>& value);
-  static size_t Int64Size(const RepeatedField<int64>& value);
-  static size_t UInt32Size(const RepeatedField<uint32>& value);
-  static size_t UInt64Size(const RepeatedField<uint64>& value);
-  static size_t SInt32Size(const RepeatedField<int32>& value);
-  static size_t SInt64Size(const RepeatedField<int64>& value);
+  static size_t Int32Size(const RepeatedField<int32_t>& value);
+  static size_t Int64Size(const RepeatedField<int64_t>& value);
+  static size_t UInt32Size(const RepeatedField<uint32_t>& value);
+  static size_t UInt64Size(const RepeatedField<uint64_t>& value);
+  static size_t SInt32Size(const RepeatedField<int32_t>& value);
+  static size_t SInt64Size(const RepeatedField<int64_t>& value);
   static size_t EnumSize(const RepeatedField<int>& value);
 
   // These types always have the same size.
@@ -718,7 +729,7 @@
   // can be read using potentially faster paths.
   template <typename CType, enum FieldType DeclaredType>
   PROTOBUF_NDEBUG_INLINE static bool ReadRepeatedFixedSizePrimitive(
-      int tag_size, uint32 tag, io::CodedInputStream* input,
+      int tag_size, uint32_t tag, io::CodedInputStream* input,
       RepeatedField<CType>* value);
 
   // Like ReadRepeatedFixedSizePrimitive but for packed primitive fields.
@@ -744,7 +755,7 @@
   virtual ~FieldSkipper() {}
 
   // Skip a field whose tag has already been consumed.
-  virtual bool SkipField(io::CodedInputStream* input, uint32 tag);
+  virtual bool SkipField(io::CodedInputStream* input, uint32_t tag);
 
   // Skip an entire message or group, up to an end-group tag (which is consumed)
   // or end-of-stream.
@@ -765,7 +776,7 @@
   ~CodedOutputStreamFieldSkipper() override {}
 
   // implements FieldSkipper -----------------------------------------
-  bool SkipField(io::CodedInputStream* input, uint32 tag) override;
+  bool SkipField(io::CodedInputStream* input, uint32_t tag) override;
   bool SkipMessage(io::CodedInputStream* input) override;
   void SkipUnknownEnum(int field_number, int value) override;
 
@@ -780,23 +791,23 @@
   return kFieldTypeToCppTypeMap[type];
 }
 
-constexpr inline uint32 WireFormatLite::MakeTag(int field_number,
-                                                WireType type) {
+constexpr inline uint32_t WireFormatLite::MakeTag(int field_number,
+                                                  WireType type) {
   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);
 }
 
-inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32 tag) {
+inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32_t tag) {
   return static_cast<WireType>(tag & kTagTypeMask);
 }
 
-inline int WireFormatLite::GetTagFieldNumber(uint32 tag) {
+inline int WireFormatLite::GetTagFieldNumber(uint32_t tag) {
   return static_cast<int>(tag >> kTagTypeBits);
 }
 
 inline size_t WireFormatLite::TagSize(int field_number,
                                       WireFormatLite::FieldType type) {
   size_t result = io::CodedOutputStream::VarintSize32(
-      static_cast<uint32>(field_number << kTagTypeBits));
+      static_cast<uint32_t>(field_number << kTagTypeBits));
   if (type == TYPE_GROUP) {
     // Groups have both a start and an end tag.
     return result * 2;
@@ -805,19 +816,19 @@
   }
 }
 
-inline uint32 WireFormatLite::EncodeFloat(float value) {
-  return bit_cast<uint32>(value);
+inline uint32_t WireFormatLite::EncodeFloat(float value) {
+  return bit_cast<uint32_t>(value);
 }
 
-inline float WireFormatLite::DecodeFloat(uint32 value) {
+inline float WireFormatLite::DecodeFloat(uint32_t value) {
   return bit_cast<float>(value);
 }
 
-inline uint64 WireFormatLite::EncodeDouble(double value) {
-  return bit_cast<uint64>(value);
+inline uint64_t WireFormatLite::EncodeDouble(double value) {
+  return bit_cast<uint64_t>(value);
 }
 
-inline double WireFormatLite::DecodeDouble(uint64 value) {
+inline double WireFormatLite::DecodeDouble(uint64_t value) {
   return bit_cast<double>(value);
 }
 
@@ -832,7 +843,7 @@
 // in such a way that those with a small absolute value will have smaller
 // encoded values, making them appropriate for encoding using varint.
 //
-//       int32 ->     uint32
+//       int32_t ->     uint32_t
 // -------------------------
 //           0 ->          0
 //          -1 ->          1
@@ -845,26 +856,26 @@
 //        >> encode >>
 //        << decode <<
 
-inline uint32 WireFormatLite::ZigZagEncode32(int32 n) {
+inline uint32_t WireFormatLite::ZigZagEncode32(int32_t n) {
   // Note:  the right-shift must be arithmetic
   // Note:  left shift must be unsigned because of overflow
-  return (static_cast<uint32>(n) << 1) ^ static_cast<uint32>(n >> 31);
+  return (static_cast<uint32_t>(n) << 1) ^ static_cast<uint32_t>(n >> 31);
 }
 
-inline int32 WireFormatLite::ZigZagDecode32(uint32 n) {
+inline int32_t WireFormatLite::ZigZagDecode32(uint32_t n) {
   // Note:  Using unsigned types prevent undefined behavior
-  return static_cast<int32>((n >> 1) ^ (~(n & 1) + 1));
+  return static_cast<int32_t>((n >> 1) ^ (~(n & 1) + 1));
 }
 
-inline uint64 WireFormatLite::ZigZagEncode64(int64 n) {
+inline uint64_t WireFormatLite::ZigZagEncode64(int64_t n) {
   // Note:  the right-shift must be arithmetic
   // Note:  left shift must be unsigned because of overflow
-  return (static_cast<uint64>(n) << 1) ^ static_cast<uint64>(n >> 63);
+  return (static_cast<uint64_t>(n) << 1) ^ static_cast<uint64_t>(n >> 63);
 }
 
-inline int64 WireFormatLite::ZigZagDecode64(uint64 n) {
+inline int64_t WireFormatLite::ZigZagDecode64(uint64_t n) {
   // Note:  Using unsigned types prevent undefined behavior
-  return static_cast<int64>((n >> 1) ^ (~(n & 1) + 1));
+  return static_cast<int64_t>((n >> 1) ^ (~(n & 1) + 1));
 }
 
 // String is for UTF-8 text only, but, even so, ReadString() can simply
@@ -880,8 +891,8 @@
   return ReadBytes(input, p);
 }
 
-inline uint8* InternalSerializeUnknownMessageSetItemsToArray(
-    const std::string& unknown_fields, uint8* target,
+inline uint8_t* InternalSerializeUnknownMessageSetItemsToArray(
+    const std::string& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   return stream->WriteRaw(unknown_fields.data(),
                           static_cast<int>(unknown_fields.size()), target);
@@ -895,77 +906,83 @@
 // Implementation details of ReadPrimitive.
 
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_INT32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_INT32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_INT64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_INT64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint32, WireFormatLite::TYPE_UINT32>(
-    io::CodedInputStream* input, uint32* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint32_t, WireFormatLite::TYPE_UINT32>(
+    io::CodedInputStream* input, uint32_t* value) {
   return input->ReadVarint32(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint64, WireFormatLite::TYPE_UINT64>(
-    io::CodedInputStream* input, uint64* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint64_t, WireFormatLite::TYPE_UINT64>(
+    io::CodedInputStream* input, uint64_t* value) {
   return input->ReadVarint64(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_SINT32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_SINT32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
   *value = ZigZagDecode32(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_SINT64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_SINT64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
   *value = ZigZagDecode64(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint32, WireFormatLite::TYPE_FIXED32>(
-    io::CodedInputStream* input, uint32* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint32_t, WireFormatLite::TYPE_FIXED32>(
+    io::CodedInputStream* input, uint32_t* value) {
   return input->ReadLittleEndian32(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint64, WireFormatLite::TYPE_FIXED64>(
-    io::CodedInputStream* input, uint64* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint64_t, WireFormatLite::TYPE_FIXED64>(
+    io::CodedInputStream* input, uint64_t* value) {
   return input->ReadLittleEndian64(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_SFIXED32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool
+WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_SFIXED32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadLittleEndian32(&temp)) return false;
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_SFIXED64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool
+WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_SFIXED64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadLittleEndian64(&temp)) return false;
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return true;
 }
 template <>
 inline bool WireFormatLite::ReadPrimitive<float, WireFormatLite::TYPE_FLOAT>(
     io::CodedInputStream* input, float* value) {
-  uint32 temp;
+  uint32_t temp;
   if (!input->ReadLittleEndian32(&temp)) return false;
   *value = DecodeFloat(temp);
   return true;
@@ -973,7 +990,7 @@
 template <>
 inline bool WireFormatLite::ReadPrimitive<double, WireFormatLite::TYPE_DOUBLE>(
     io::CodedInputStream* input, double* value) {
-  uint64 temp;
+  uint64_t temp;
   if (!input->ReadLittleEndian64(&temp)) return false;
   *value = DecodeDouble(temp);
   return true;
@@ -981,7 +998,7 @@
 template <>
 inline bool WireFormatLite::ReadPrimitive<bool, WireFormatLite::TYPE_BOOL>(
     io::CodedInputStream* input, bool* value) {
-  uint64 temp;
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
   *value = temp != 0;
   return true;
@@ -989,56 +1006,56 @@
 template <>
 inline bool WireFormatLite::ReadPrimitive<int, WireFormatLite::TYPE_ENUM>(
     io::CodedInputStream* input, int* value) {
-  uint32 temp;
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
   *value = static_cast<int>(temp);
   return true;
 }
 
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<uint32, WireFormatLite::TYPE_FIXED32>(
-    const uint8* buffer, uint32* value) {
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<uint32_t, WireFormatLite::TYPE_FIXED32>(
+    const uint8_t* buffer, uint32_t* value) {
   return io::CodedInputStream::ReadLittleEndian32FromArray(buffer, value);
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<uint64, WireFormatLite::TYPE_FIXED64>(
-    const uint8* buffer, uint64* value) {
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<uint64_t, WireFormatLite::TYPE_FIXED64>(
+    const uint8_t* buffer, uint64_t* value) {
   return io::CodedInputStream::ReadLittleEndian64FromArray(buffer, value);
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<int32, WireFormatLite::TYPE_SFIXED32>(
-    const uint8* buffer, int32* value) {
-  uint32 temp;
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<int32_t, WireFormatLite::TYPE_SFIXED32>(
+    const uint8_t* buffer, int32_t* value) {
+  uint32_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian32FromArray(buffer, &temp);
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return buffer;
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<int64, WireFormatLite::TYPE_SFIXED64>(
-    const uint8* buffer, int64* value) {
-  uint64 temp;
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<int64_t, WireFormatLite::TYPE_SFIXED64>(
+    const uint8_t* buffer, int64_t* value) {
+  uint64_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian64FromArray(buffer, &temp);
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return buffer;
 }
 template <>
-inline const uint8*
+inline const uint8_t*
 WireFormatLite::ReadPrimitiveFromArray<float, WireFormatLite::TYPE_FLOAT>(
-    const uint8* buffer, float* value) {
-  uint32 temp;
+    const uint8_t* buffer, float* value) {
+  uint32_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian32FromArray(buffer, &temp);
   *value = DecodeFloat(temp);
   return buffer;
 }
 template <>
-inline const uint8*
+inline const uint8_t*
 WireFormatLite::ReadPrimitiveFromArray<double, WireFormatLite::TYPE_DOUBLE>(
-    const uint8* buffer, double* value) {
-  uint64 temp;
+    const uint8_t* buffer, double* value) {
+  uint64_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian64FromArray(buffer, &temp);
   *value = DecodeDouble(temp);
   return buffer;
@@ -1047,7 +1064,7 @@
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 inline bool WireFormatLite::ReadRepeatedPrimitive(
     int,  // tag_size, unused.
-    uint32 tag, io::CodedInputStream* input, RepeatedField<CType>* values) {
+    uint32_t tag, io::CodedInputStream* input, RepeatedField<CType>* values) {
   CType value;
   if (!ReadPrimitive<CType, DeclaredType>(input, &value)) return false;
   values->Add(value);
@@ -1062,7 +1079,7 @@
 
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
-    int tag_size, uint32 tag, io::CodedInputStream* input,
+    int tag_size, uint32_t tag, io::CodedInputStream* input,
     RepeatedField<CType>* values) {
   GOOGLE_DCHECK_EQ(UInt32Size(tag), static_cast<size_t>(tag_size));
   CType value;
@@ -1082,7 +1099,7 @@
   int size;
   input->GetDirectBufferPointerInline(&void_pointer, &size);
   if (size > 0) {
-    const uint8* buffer = reinterpret_cast<const uint8*>(void_pointer);
+    const uint8_t* buffer = reinterpret_cast<const uint8_t*>(void_pointer);
     // The number of bytes each type occupies on the wire.
     const int per_value_size = tag_size + static_cast<int>(sizeof(value));
 
@@ -1092,7 +1109,7 @@
     int num_read = 0;
     while (num_read < elements_available &&
            (buffer = io::CodedInputStream::ExpectTagFromArray(buffer, tag)) !=
-               NULL) {
+               nullptr) {
       buffer = ReadPrimitiveFromArray<CType, DeclaredType>(buffer, &value);
       values->AddAlreadyReserved(value);
       ++num_read;
@@ -1111,17 +1128,17 @@
   template <>                                                             \
   inline bool WireFormatLite::ReadRepeatedPrimitive<                      \
       CPPTYPE, WireFormatLite::DECLARED_TYPE>(                            \
-      int tag_size, uint32 tag, io::CodedInputStream* input,              \
+      int tag_size, uint32_t tag, io::CodedInputStream* input,            \
       RepeatedField<CPPTYPE>* values) {                                   \
     return ReadRepeatedFixedSizePrimitive<CPPTYPE,                        \
                                           WireFormatLite::DECLARED_TYPE>( \
         tag_size, tag, input, values);                                    \
   }
 
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint32, TYPE_FIXED32)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint64, TYPE_FIXED64)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(int32, TYPE_SFIXED32)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(int64, TYPE_SFIXED64)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint32_t, TYPE_FIXED32)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint64_t, TYPE_FIXED64)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(int32_t, TYPE_SFIXED32)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(int64_t, TYPE_SFIXED64)
 READ_REPEATED_FIXED_SIZE_PRIMITIVE(float, TYPE_FLOAT)
 READ_REPEATED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
@@ -1129,7 +1146,7 @@
 
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 bool WireFormatLite::ReadRepeatedPrimitiveNoInline(
-    int tag_size, uint32 tag, io::CodedInputStream* input,
+    int tag_size, uint32_t tag, io::CodedInputStream* input,
     RepeatedField<CType>* value) {
   return ReadRepeatedPrimitive<CType, DeclaredType>(tag_size, tag, input,
                                                     value);
@@ -1171,13 +1188,13 @@
   // -1               >= 0   Use fast path if length <= Limit.
   // >= 0             -1     Use slow path.
   // >= 0             >= 0   Use fast path if length <= min(both limits).
-  int64 bytes_limit = input->BytesUntilTotalBytesLimit();
+  int64_t bytes_limit = input->BytesUntilTotalBytesLimit();
   if (bytes_limit == -1) {
     bytes_limit = input->BytesUntilLimit();
   } else {
     // parentheses around (std::min) prevents macro expansion of min(...)
     bytes_limit =
-        (std::min)(bytes_limit, static_cast<int64>(input->BytesUntilLimit()));
+        (std::min)(bytes_limit, static_cast<int64_t>(input->BytesUntilLimit()));
   }
   if (bytes_limit >= new_bytes) {
     // Fast-path that pre-allocates *values to the final size.
@@ -1222,10 +1239,10 @@
         input, values);                                                        \
   }
 
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint32, TYPE_FIXED32)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint64, TYPE_FIXED64)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int32, TYPE_SFIXED32)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int64, TYPE_SFIXED64)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint32_t, TYPE_FIXED32)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint64_t, TYPE_FIXED64)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int32_t, TYPE_SFIXED32)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int64_t, TYPE_SFIXED64)
 READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(float, TYPE_FLOAT)
 READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
@@ -1271,45 +1288,45 @@
   output->WriteTag(MakeTag(field_number, type));
 }
 
-inline void WireFormatLite::WriteInt32NoTag(int32 value,
+inline void WireFormatLite::WriteInt32NoTag(int32_t value,
                                             io::CodedOutputStream* output) {
   output->WriteVarint32SignExtended(value);
 }
-inline void WireFormatLite::WriteInt64NoTag(int64 value,
+inline void WireFormatLite::WriteInt64NoTag(int64_t value,
                                             io::CodedOutputStream* output) {
-  output->WriteVarint64(static_cast<uint64>(value));
+  output->WriteVarint64(static_cast<uint64_t>(value));
 }
-inline void WireFormatLite::WriteUInt32NoTag(uint32 value,
+inline void WireFormatLite::WriteUInt32NoTag(uint32_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint32(value);
 }
-inline void WireFormatLite::WriteUInt64NoTag(uint64 value,
+inline void WireFormatLite::WriteUInt64NoTag(uint64_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint64(value);
 }
-inline void WireFormatLite::WriteSInt32NoTag(int32 value,
+inline void WireFormatLite::WriteSInt32NoTag(int32_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint32(ZigZagEncode32(value));
 }
-inline void WireFormatLite::WriteSInt64NoTag(int64 value,
+inline void WireFormatLite::WriteSInt64NoTag(int64_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint64(ZigZagEncode64(value));
 }
-inline void WireFormatLite::WriteFixed32NoTag(uint32 value,
+inline void WireFormatLite::WriteFixed32NoTag(uint32_t value,
                                               io::CodedOutputStream* output) {
   output->WriteLittleEndian32(value);
 }
-inline void WireFormatLite::WriteFixed64NoTag(uint64 value,
+inline void WireFormatLite::WriteFixed64NoTag(uint64_t value,
                                               io::CodedOutputStream* output) {
   output->WriteLittleEndian64(value);
 }
-inline void WireFormatLite::WriteSFixed32NoTag(int32 value,
+inline void WireFormatLite::WriteSFixed32NoTag(int32_t value,
                                                io::CodedOutputStream* output) {
-  output->WriteLittleEndian32(static_cast<uint32>(value));
+  output->WriteLittleEndian32(static_cast<uint32_t>(value));
 }
-inline void WireFormatLite::WriteSFixed64NoTag(int64 value,
+inline void WireFormatLite::WriteSFixed64NoTag(int64_t value,
                                                io::CodedOutputStream* output) {
-  output->WriteLittleEndian64(static_cast<uint64>(value));
+  output->WriteLittleEndian64(static_cast<uint64_t>(value));
 }
 inline void WireFormatLite::WriteFloatNoTag(float value,
                                             io::CodedOutputStream* output) {
@@ -1350,77 +1367,80 @@
 
 // ===================================================================
 
-inline uint8* WireFormatLite::WriteTagToArray(int field_number, WireType type,
-                                              uint8* target) {
+inline uint8_t* WireFormatLite::WriteTagToArray(int field_number, WireType type,
+                                                uint8_t* target) {
   return io::CodedOutputStream::WriteTagToArray(MakeTag(field_number, type),
                                                 target);
 }
 
-inline uint8* WireFormatLite::WriteInt32NoTagToArray(int32 value,
-                                                     uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(int32_t value,
+                                                       uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32SignExtendedToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteInt64NoTagToArray(int64 value,
-                                                     uint8* target) {
-  return io::CodedOutputStream::WriteVarint64ToArray(static_cast<uint64>(value),
-                                                     target);
+inline uint8_t* WireFormatLite::WriteInt64NoTagToArray(int64_t value,
+                                                       uint8_t* target) {
+  return io::CodedOutputStream::WriteVarint64ToArray(
+      static_cast<uint64_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteUInt32NoTagToArray(uint32 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32NoTagToArray(uint32_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt64NoTagToArray(uint64 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64NoTagToArray(uint64_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint64ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt32NoTagToArray(int32 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32NoTagToArray(int32_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(ZigZagEncode32(value),
                                                      target);
 }
-inline uint8* WireFormatLite::WriteSInt64NoTagToArray(int64 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64NoTagToArray(int64_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint64ToArray(ZigZagEncode64(value),
                                                      target);
 }
-inline uint8* WireFormatLite::WriteFixed32NoTagToArray(uint32 value,
-                                                       uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32NoTagToArray(uint32_t value,
+                                                         uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed64NoTagToArray(uint64 value,
-                                                       uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64NoTagToArray(uint64_t value,
+                                                         uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32NoTagToArray(int32 value,
-                                                        uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32NoTagToArray(int32_t value,
+                                                          uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(
-      static_cast<uint32>(value), target);
+      static_cast<uint32_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteSFixed64NoTagToArray(int64 value,
-                                                        uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64NoTagToArray(int64_t value,
+                                                          uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(
-      static_cast<uint64>(value), target);
+      static_cast<uint64_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteFloatNoTagToArray(float value,
-                                                     uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatNoTagToArray(float value,
+                                                       uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(EncodeFloat(value),
                                                            target);
 }
-inline uint8* WireFormatLite::WriteDoubleNoTagToArray(double value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleNoTagToArray(double value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(EncodeDouble(value),
                                                            target);
 }
-inline uint8* WireFormatLite::WriteBoolNoTagToArray(bool value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolNoTagToArray(bool value,
+                                                      uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(value ? 1 : 0, target);
 }
-inline uint8* WireFormatLite::WriteEnumNoTagToArray(int value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumNoTagToArray(int value,
+                                                      uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32SignExtendedToArray(value, target);
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WritePrimitiveNoTagToArray(
-    const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*), uint8* target) {
+inline uint8_t* WireFormatLite::WritePrimitiveNoTagToArray(
+    const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+    uint8_t* target) {
   const int n = value.size();
   GOOGLE_DCHECK_GT(n, 0);
 
@@ -1434,8 +1454,9 @@
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WriteFixedNoTagToArray(
-    const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*), uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixedNoTagToArray(
+    const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+    uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   (void)Writer;
 
@@ -1451,138 +1472,149 @@
 #endif
 }
 
-inline uint8* WireFormatLite::WriteInt32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteInt64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt32NoTagToArray(
-    const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32NoTagToArray(
+    const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteUInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt64NoTagToArray(
-    const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64NoTagToArray(
+    const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteUInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteSInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteSInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed32NoTagToArray(
-    const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32NoTagToArray(
+    const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFixed32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed64NoTagToArray(
-    const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64NoTagToArray(
+    const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFixed64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteSFixed32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSFixed64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteSFixed64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFloatNoTagToArray(
-    const RepeatedField<float>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatNoTagToArray(
+    const RepeatedField<float>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFloatNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteDoubleNoTagToArray(
-    const RepeatedField<double>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleNoTagToArray(
+    const RepeatedField<double>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteDoubleNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteBoolNoTagToArray(
-    const RepeatedField<bool>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolNoTagToArray(
+    const RepeatedField<bool>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteBoolNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteEnumNoTagToArray(
-    const RepeatedField<int>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumNoTagToArray(
+    const RepeatedField<int>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteEnumNoTagToArray, target);
 }
 
-inline uint8* WireFormatLite::WriteInt32ToArray(int field_number, int32 value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32ToArray(int field_number,
+                                                  int32_t value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteInt64ToArray(int field_number, int64 value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64ToArray(int field_number,
+                                                  int64_t value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt32ToArray(int field_number, uint32 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32ToArray(int field_number,
+                                                   uint32_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteUInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt64ToArray(int field_number, uint64 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64ToArray(int field_number,
+                                                   uint64_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteUInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt32ToArray(int field_number, int32 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32ToArray(int field_number,
+                                                   int32_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteSInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt64ToArray(int field_number, int64 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64ToArray(int field_number,
+                                                   int64_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteSInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed32ToArray(int field_number,
-                                                  uint32 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32ToArray(int field_number,
+                                                    uint32_t value,
+                                                    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteFixed32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed64ToArray(int field_number,
-                                                  uint64 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64ToArray(int field_number,
+                                                    uint64_t value,
+                                                    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteFixed64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32ToArray(int field_number,
-                                                   int32 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32ToArray(int field_number,
+                                                     int32_t value,
+                                                     uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteSFixed32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed64ToArray(int field_number,
-                                                   int64 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64ToArray(int field_number,
+                                                     int64_t value,
+                                                     uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteSFixed64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFloatToArray(int field_number, float value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatToArray(int field_number, float value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteFloatNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteDoubleToArray(int field_number, double value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleToArray(int field_number,
+                                                   double value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteDoubleNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteBoolToArray(int field_number, bool value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolToArray(int field_number, bool value,
+                                                 uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteBoolNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteEnumToArray(int field_number, int value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumToArray(int field_number, int value,
+                                                 uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteEnumNoTagToArray(value, target);
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WritePrimitiveToArray(
+inline uint8_t* WireFormatLite::WritePrimitiveToArray(
     int field_number, const RepeatedField<T>& value,
-    uint8* (*Writer)(int, T, uint8*), uint8* target) {
+    uint8_t* (*Writer)(int, T, uint8_t*), uint8_t* target) {
   const int n = value.size();
   if (n == 0) {
     return target;
@@ -1597,71 +1629,69 @@
   return target;
 }
 
-inline uint8* WireFormatLite::WriteInt32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteInt64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt32ToArray(
-    int field_number, const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32ToArray(
+    int field_number, const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteUInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt64ToArray(
-    int field_number, const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64ToArray(
+    int field_number, const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteUInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed32ToArray(
-    int field_number, const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32ToArray(
+    int field_number, const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFixed32ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteFixed64ToArray(
-    int field_number, const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64ToArray(
+    int field_number, const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFixed64ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteSFixed32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSFixed32ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteSFixed64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSFixed64ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteFloatToArray(
-    int field_number, const RepeatedField<float>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatToArray(
+    int field_number, const RepeatedField<float>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFloatToArray, target);
 }
-inline uint8* WireFormatLite::WriteDoubleToArray(
-    int field_number, const RepeatedField<double>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleToArray(
+    int field_number, const RepeatedField<double>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteDoubleToArray, target);
 }
-inline uint8* WireFormatLite::WriteBoolToArray(int field_number,
-                                               const RepeatedField<bool>& value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolToArray(
+    int field_number, const RepeatedField<bool>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteBoolToArray, target);
 }
-inline uint8* WireFormatLite::WriteEnumToArray(int field_number,
-                                               const RepeatedField<int>& value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumToArray(
+    int field_number, const RepeatedField<int>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteEnumToArray, target);
 }
-inline uint8* WireFormatLite::WriteStringToArray(int field_number,
-                                                 const std::string& value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteStringToArray(int field_number,
+                                                   const std::string& value,
+                                                   uint8_t* target) {
   // String is for UTF-8 text only
   // WARNING:  In wire_format.cc, both strings and bytes are handled by
   //   WriteString() to avoid code duplication.  If the implementations become
@@ -1669,51 +1699,32 @@
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteBytesToArray(int field_number,
-                                                const std::string& value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteBytesToArray(int field_number,
+                                                  const std::string& value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);
 }
 
 
-template <typename MessageType>
-inline uint8* WireFormatLite::InternalWriteGroup(
-    int field_number, const MessageType& value, uint8* target,
-    io::EpsCopyOutputStream* stream) {
-  target = WriteTagToArray(field_number, WIRETYPE_START_GROUP, target);
-  target = value._InternalSerialize(target, stream);
-  target = stream->EnsureSpace(target);
-  return WriteTagToArray(field_number, WIRETYPE_END_GROUP, target);
-}
-template <typename MessageType>
-inline uint8* WireFormatLite::InternalWriteMessage(
-    int field_number, const MessageType& value, uint8* target,
-    io::EpsCopyOutputStream* stream) {
-  target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
-  target = io::CodedOutputStream::WriteVarint32ToArrayOutOfLine(
-      static_cast<uint32>(value.GetCachedSize()), target);
-  return value._InternalSerialize(target, stream);
-}
-
 // See comment on ReadGroupNoVirtual to understand the need for this template
 // parameter name.
 template <typename MessageType_WorkAroundCppLookupDefect>
-inline uint8* WireFormatLite::InternalWriteGroupNoVirtualToArray(
+inline uint8_t* WireFormatLite::InternalWriteGroupNoVirtualToArray(
     int field_number, const MessageType_WorkAroundCppLookupDefect& value,
-    uint8* target) {
+    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_START_GROUP, target);
   target = value.MessageType_WorkAroundCppLookupDefect::
                SerializeWithCachedSizesToArray(target);
   return WriteTagToArray(field_number, WIRETYPE_END_GROUP, target);
 }
 template <typename MessageType_WorkAroundCppLookupDefect>
-inline uint8* WireFormatLite::InternalWriteMessageNoVirtualToArray(
+inline uint8_t* WireFormatLite::InternalWriteMessageNoVirtualToArray(
     int field_number, const MessageType_WorkAroundCppLookupDefect& value,
-    uint8* target) {
+    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   target = io::CodedOutputStream::WriteVarint32ToArray(
-      static_cast<uint32>(
+      static_cast<uint32_t>(
           value.MessageType_WorkAroundCppLookupDefect::GetCachedSize()),
       target);
   return value
@@ -1723,27 +1734,49 @@
 
 // ===================================================================
 
-inline size_t WireFormatLite::Int32Size(int32 value) {
+inline size_t WireFormatLite::Int32Size(int32_t value) {
   return io::CodedOutputStream::VarintSize32SignExtended(value);
 }
-inline size_t WireFormatLite::Int64Size(int64 value) {
-  return io::CodedOutputStream::VarintSize64(static_cast<uint64>(value));
+inline size_t WireFormatLite::Int64Size(int64_t value) {
+  return io::CodedOutputStream::VarintSize64(static_cast<uint64_t>(value));
 }
-inline size_t WireFormatLite::UInt32Size(uint32 value) {
+inline size_t WireFormatLite::UInt32Size(uint32_t value) {
   return io::CodedOutputStream::VarintSize32(value);
 }
-inline size_t WireFormatLite::UInt64Size(uint64 value) {
+inline size_t WireFormatLite::UInt64Size(uint64_t value) {
   return io::CodedOutputStream::VarintSize64(value);
 }
-inline size_t WireFormatLite::SInt32Size(int32 value) {
+inline size_t WireFormatLite::SInt32Size(int32_t value) {
   return io::CodedOutputStream::VarintSize32(ZigZagEncode32(value));
 }
-inline size_t WireFormatLite::SInt64Size(int64 value) {
+inline size_t WireFormatLite::SInt64Size(int64_t value) {
   return io::CodedOutputStream::VarintSize64(ZigZagEncode64(value));
 }
 inline size_t WireFormatLite::EnumSize(int value) {
   return io::CodedOutputStream::VarintSize32SignExtended(value);
 }
+inline size_t WireFormatLite::Int32SizePlusOne(int32_t value) {
+  return io::CodedOutputStream::VarintSize32SignExtendedPlusOne(value);
+}
+inline size_t WireFormatLite::Int64SizePlusOne(int64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(
+      static_cast<uint64_t>(value));
+}
+inline size_t WireFormatLite::UInt32SizePlusOne(uint32_t value) {
+  return io::CodedOutputStream::VarintSize32PlusOne(value);
+}
+inline size_t WireFormatLite::UInt64SizePlusOne(uint64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(value);
+}
+inline size_t WireFormatLite::SInt32SizePlusOne(int32_t value) {
+  return io::CodedOutputStream::VarintSize32PlusOne(ZigZagEncode32(value));
+}
+inline size_t WireFormatLite::SInt64SizePlusOne(int64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(ZigZagEncode64(value));
+}
+inline size_t WireFormatLite::EnumSizePlusOne(int value) {
+  return io::CodedOutputStream::VarintSize32SignExtendedPlusOne(value);
+}
 
 inline size_t WireFormatLite::StringSize(const std::string& value) {
   return LengthDelimitedSize(value.size());
@@ -1778,11 +1811,11 @@
 
 inline size_t WireFormatLite::LengthDelimitedSize(size_t length) {
   // The static_cast here prevents an error in certain compiler configurations
-  // but is not technically correct--if length is too large to fit in a uint32
+  // but is not technically correct--if length is too large to fit in a uint32_t
   // then it will be silently truncated. We will need to fix this if we ever
   // decide to start supporting serialized messages greater than 2 GiB in size.
   return length +
-         io::CodedOutputStream::VarintSize32(static_cast<uint32>(length));
+         io::CodedOutputStream::VarintSize32(static_cast<uint32_t>(length));
 }
 
 template <typename MS>
@@ -1791,55 +1824,64 @@
   //   required int32 type_id = 2;
   //   required data message = 3;
 
-  uint32 last_type_id = 0;
+  uint32_t last_type_id = 0;
 
   // If we see message data before the type_id, we'll append it to this so
   // we can parse it later.
   std::string message_data;
 
+  enum class State { kNoTag, kHasType, kHasPayload, kDone };
+  State state = State::kNoTag;
+
   while (true) {
-    const uint32 tag = input->ReadTagNoLastTag();
+    const uint32_t tag = input->ReadTagNoLastTag();
     if (tag == 0) return false;
 
     switch (tag) {
       case WireFormatLite::kMessageSetTypeIdTag: {
-        uint32 type_id;
+        uint32_t type_id;
         if (!input->ReadVarint32(&type_id)) return false;
-        last_type_id = type_id;
-
-        if (!message_data.empty()) {
+        if (state == State::kNoTag) {
+          last_type_id = type_id;
+          state = State::kHasType;
+        } else if (state == State::kHasPayload) {
           // We saw some message data before the type_id.  Have to parse it
           // now.
           io::CodedInputStream sub_input(
-              reinterpret_cast<const uint8*>(message_data.data()),
+              reinterpret_cast<const uint8_t*>(message_data.data()),
               static_cast<int>(message_data.size()));
           sub_input.SetRecursionLimit(input->RecursionBudget());
-          if (!ms.ParseField(last_type_id, &sub_input)) {
+          if (!ms.ParseField(type_id, &sub_input)) {
             return false;
           }
           message_data.clear();
+          state = State::kDone;
         }
 
         break;
       }
 
       case WireFormatLite::kMessageSetMessageTag: {
-        if (last_type_id == 0) {
+        if (state == State::kHasType) {
+          // Already saw type_id, so we can parse this directly.
+          if (!ms.ParseField(last_type_id, input)) {
+            return false;
+          }
+          state = State::kDone;
+        } else if (state == State::kNoTag) {
           // We haven't seen a type_id yet.  Append this data to message_data.
-          uint32 length;
+          uint32_t length;
           if (!input->ReadVarint32(&length)) return false;
-          if (static_cast<int32>(length) < 0) return false;
-          uint32 size = static_cast<uint32>(
+          if (static_cast<int32_t>(length) < 0) return false;
+          uint32_t size = static_cast<uint32_t>(
               length + io::CodedOutputStream::VarintSize32(length));
           message_data.resize(size);
-          auto ptr = reinterpret_cast<uint8*>(&message_data[0]);
+          auto ptr = reinterpret_cast<uint8_t*>(&message_data[0]);
           ptr = io::CodedOutputStream::WriteVarint32ToArray(length, ptr);
           if (!input->ReadRaw(ptr, length)) return false;
+          state = State::kHasPayload;
         } else {
-          // Already saw type_id, so we can parse this directly.
-          if (!ms.ParseField(last_type_id, input)) {
-            return false;
-          }
+          if (!ms.SkipField(tag, input)) return false;
         }
 
         break;
diff -ur protobuf-3.17.3/src/google/protobuf/wire_format_unittest.cc protobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.cc
--- protobuf-3.17.3/src/google/protobuf/wire_format_unittest.cc	2021-06-08 07:11:10
+++ protobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.cc	2024-06-21 11:12:17
@@ -34,1552 +34,32 @@
 
 #include <google/protobuf/wire_format.h>
 
-#include <google/protobuf/stubs/logging.h>
-#include <google/protobuf/stubs/common.h>
-#include <google/protobuf/test_util.h>
-#include <google/protobuf/test_util2.h>
 #include <google/protobuf/unittest.pb.h>
 #include <google/protobuf/unittest_mset.pb.h>
 #include <google/protobuf/unittest_mset_wire_format.pb.h>
 #include <google/protobuf/unittest_proto3_arena.pb.h>
-#include <google/protobuf/io/coded_stream.h>
-#include <google/protobuf/io/zero_copy_stream_impl.h>
-#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
-#include <google/protobuf/descriptor.h>
-#include <google/protobuf/wire_format_lite.h>
-#include <google/protobuf/testing/googletest.h>
-#include <google/protobuf/stubs/logging.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
-#include <google/protobuf/stubs/casts.h>
-#include <google/protobuf/stubs/strutil.h>
-#include <google/protobuf/stubs/stl_util.h>
 
+#define UNITTEST ::protobuf_unittest
+#define UNITTEST_IMPORT ::protobuf_unittest_import
+#define UNITTEST_PACKAGE_NAME "protobuf_unittest"
+#define PROTO2_WIREFORMAT_UNITTEST ::proto2_wireformat_unittest
+#define PROTO3_ARENA_UNITTEST ::proto3_arena_unittest
+
+// Must include after defining UNITTEST, etc.
 // clang-format off
-#include <google/protobuf/port_def.inc>
+#include <google/protobuf/test_util.inc>
+#include <google/protobuf/wire_format_unittest.inc>
 // clang-format on
 
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
 namespace google {
 namespace protobuf {
 namespace internal {
 namespace {
-
-TEST(WireFormatTest, EnumsInSync) {
-  // Verify that WireFormatLite::FieldType and WireFormatLite::CppType match
-  // FieldDescriptor::Type and FieldDescriptor::CppType.
-
-  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_TYPE),
-            implicit_cast<int>(WireFormatLite::MAX_FIELD_TYPE));
-  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_CPPTYPE),
-            implicit_cast<int>(WireFormatLite::MAX_CPPTYPE));
-
-  for (int i = 1; i <= WireFormatLite::MAX_FIELD_TYPE; i++) {
-    EXPECT_EQ(implicit_cast<int>(FieldDescriptor::TypeToCppType(
-                  static_cast<FieldDescriptor::Type>(i))),
-              implicit_cast<int>(WireFormatLite::FieldTypeToCppType(
-                  static_cast<WireFormatLite::FieldType>(i))));
-  }
-}
-
-TEST(WireFormatTest, MaxFieldNumber) {
-  // Make sure the max field number constant is accurate.
-  EXPECT_EQ((1 << (32 - WireFormatLite::kTagTypeBits)) - 1,
-            FieldDescriptor::kMaxNumber);
-}
-
-TEST(WireFormatTest, Parse) {
-  unittest::TestAllTypes source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetAllFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectAllFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParseExtensions) {
-  unittest::TestAllExtensions source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetAllExtensions(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectAllExtensionsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePacked) {
-  unittest::TestPackedTypes source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetPackedFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePackedFromUnpacked) {
-  // Serialize using the generated code.
-  unittest::TestUnpackedTypes source;
-  TestUtil::SetUnpackedFields(&source);
-  std::string data = source.SerializeAsString();
-
-  // Parse using WireFormat.
-  unittest::TestPackedTypes dest;
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParseUnpackedFromPacked) {
-  // Serialize using the generated code.
-  unittest::TestPackedTypes source;
-  TestUtil::SetPackedFields(&source);
-  std::string data = source.SerializeAsString();
-
-  // Parse using WireFormat.
-  unittest::TestUnpackedTypes dest;
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectUnpackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePackedExtensions) {
-  unittest::TestPackedExtensions source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetPackedExtensions(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedExtensionsSet(dest);
-}
-
-TEST(WireFormatTest, ParseOneof) {
-  unittest::TestOneof2 source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetOneof1(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectOneofSet1(dest);
-}
-
-TEST(WireFormatTest, OneofOnlySetLast) {
-  unittest::TestOneofBackwardsCompatible source;
-  unittest::TestOneof oneof_dest;
-  std::string data;
-
-  // Set two fields
-  source.set_foo_int(100);
-  source.set_foo_string("101");
-
-  // Serialize and parse to oneof message. Generated serializer may not order
-  // fields in tag order. Use WireFormat::SerializeWithCachedSizes instead as
-  // it sorts fields beforehand.
-  {
-    io::StringOutputStream raw_output(&data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(source, source.ByteSizeLong(),
-                                         &output);
-    ASSERT_FALSE(output.HadError());
-  }
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &oneof_dest);
-
-  // Only the last field is set.
-  EXPECT_FALSE(oneof_dest.has_foo_int());
-  EXPECT_TRUE(oneof_dest.has_foo_string());
-}
-
-TEST(WireFormatTest, ByteSize) {
-  unittest::TestAllTypes message;
-  TestUtil::SetAllFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizeExtensions) {
-  unittest::TestAllExtensions message;
-  TestUtil::SetAllExtensions(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizePacked) {
-  unittest::TestPackedTypes message;
-  TestUtil::SetPackedFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizePackedExtensions) {
-  unittest::TestPackedExtensions message;
-  TestUtil::SetPackedExtensions(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizeOneof) {
-  unittest::TestOneof2 message;
-  TestUtil::SetOneof1(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, Serialize) {
-  unittest::TestAllTypes message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllFields(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeExtensions) {
-  unittest::TestAllExtensions message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllExtensions(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeFieldsAndExtensions) {
-  unittest::TestFieldOrderings message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllFieldsAndExtensions(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeOneof) {
-  unittest::TestOneof2 message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetOneof1(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, ParseMultipleExtensionRanges) {
-  // Make sure we can parse a message that contains multiple extensions ranges.
-  unittest::TestFieldOrderings source;
-  std::string data;
-
-  TestUtil::SetAllFieldsAndExtensions(&source);
-  source.SerializeToString(&data);
-
-  {
-    unittest::TestFieldOrderings dest;
-    EXPECT_TRUE(dest.ParseFromString(data));
-    EXPECT_EQ(source.DebugString(), dest.DebugString());
-  }
-
-  // Also test using reflection-based parsing.
-  {
-    unittest::TestFieldOrderings dest;
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream coded_input(&raw_input);
-    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&coded_input, &dest));
-    EXPECT_EQ(source.DebugString(), dest.DebugString());
-  }
-}
-
-const int kUnknownTypeId = 1550055;
-
-TEST(WireFormatTest, SerializeMessageSet) {
-  // Set up a TestMessageSet with two known messages and an unknown one.
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension)
-      ->set_i(123);
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension2::message_set_extension)
-      ->set_str("foo");
-  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
-                                                           "bar");
-
-  std::string data;
-  ASSERT_TRUE(message_set.SerializeToString(&data));
-
-  // Parse back using RawMessageSet and check the contents.
-  unittest::RawMessageSet raw;
-  ASSERT_TRUE(raw.ParseFromString(data));
-
-  EXPECT_EQ(0, raw.unknown_fields().field_count());
-
-  ASSERT_EQ(3, raw.item_size());
-  EXPECT_EQ(
-      unittest::TestMessageSetExtension1::descriptor()->extension(0)->number(),
-      raw.item(0).type_id());
-  EXPECT_EQ(
-      unittest::TestMessageSetExtension2::descriptor()->extension(0)->number(),
-      raw.item(1).type_id());
-  EXPECT_EQ(kUnknownTypeId, raw.item(2).type_id());
-
-  unittest::TestMessageSetExtension1 message1;
-  EXPECT_TRUE(message1.ParseFromString(raw.item(0).message()));
-  EXPECT_EQ(123, message1.i());
-
-  unittest::TestMessageSetExtension2 message2;
-  EXPECT_TRUE(message2.ParseFromString(raw.item(1).message()));
-  EXPECT_EQ("foo", message2.str());
-
-  EXPECT_EQ("bar", raw.item(2).message());
-}
-
-TEST(WireFormatTest, SerializeMessageSetVariousWaysAreEqual) {
-  // Serialize a MessageSet to a stream and to a flat array using generated
-  // code, and also using WireFormat, and check that the results are equal.
-  // Set up a TestMessageSet with two known messages and an unknown one, as
-  // above.
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension)
-      ->set_i(123);
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension2::message_set_extension)
-      ->set_str("foo");
-  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
-                                                           "bar");
-
-  size_t size = message_set.ByteSizeLong();
-  EXPECT_EQ(size, message_set.GetCachedSize());
-  ASSERT_EQ(size, WireFormat::ByteSize(message_set));
-
-  std::string flat_data;
-  std::string stream_data;
-  std::string dynamic_data;
-  flat_data.resize(size);
-  stream_data.resize(size);
-
-  // Serialize to flat array
-  {
-    uint8* target = reinterpret_cast<uint8*>(::google::protobuf::string_as_array(&flat_data));
-    uint8* end = message_set.SerializeWithCachedSizesToArray(target);
-    EXPECT_EQ(size, end - target);
-  }
-
-  // Serialize to buffer
-  {
-    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&stream_data), size,
-                                       1);
-    io::CodedOutputStream output_stream(&array_stream);
-    message_set.SerializeWithCachedSizes(&output_stream);
-    ASSERT_FALSE(output_stream.HadError());
-  }
-
-  // Serialize to buffer with WireFormat.
-  {
-    io::StringOutputStream string_stream(&dynamic_data);
-    io::CodedOutputStream output_stream(&string_stream);
-    WireFormat::SerializeWithCachedSizes(message_set, size, &output_stream);
-    ASSERT_FALSE(output_stream.HadError());
-  }
-
-  EXPECT_TRUE(flat_data == stream_data);
-  EXPECT_TRUE(flat_data == dynamic_data);
-}
-
-TEST(WireFormatTest, ParseMessageSet) {
-  // Set up a RawMessageSet with two known messages and an unknown one.
-  unittest::RawMessageSet raw;
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(unittest::TestMessageSetExtension1::descriptor()
-                          ->extension(0)
-                          ->number());
-    unittest::TestMessageSetExtension1 message;
-    message.set_i(123);
-    message.SerializeToString(item->mutable_message());
-  }
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(unittest::TestMessageSetExtension2::descriptor()
-                          ->extension(0)
-                          ->number());
-    unittest::TestMessageSetExtension2 message;
-    message.set_str("foo");
-    message.SerializeToString(item->mutable_message());
-  }
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(kUnknownTypeId);
-    item->set_message("bar");
-  }
-
-  std::string data;
-  ASSERT_TRUE(raw.SerializeToString(&data));
-
-  // Parse as a TestMessageSet and check the contents.
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  ASSERT_TRUE(message_set.ParseFromString(data));
-
-  EXPECT_EQ(123,
-            message_set
-                .GetExtension(
-                    unittest::TestMessageSetExtension1::message_set_extension)
-                .i());
-  EXPECT_EQ("foo",
-            message_set
-                .GetExtension(
-                    unittest::TestMessageSetExtension2::message_set_extension)
-                .str());
-
-  ASSERT_EQ(1, message_set.unknown_fields().field_count());
-  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED,
-            message_set.unknown_fields().field(0).type());
-  EXPECT_EQ("bar", message_set.unknown_fields().field(0).length_delimited());
-
-  // Also parse using WireFormat.
-  proto2_wireformat_unittest::TestMessageSet dynamic_message_set;
-  io::CodedInputStream input(reinterpret_cast<const uint8*>(data.data()),
-                             data.size());
-  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &dynamic_message_set));
-  EXPECT_EQ(message_set.DebugString(), dynamic_message_set.DebugString());
-}
-
-TEST(WireFormatTest, ParseMessageSetWithReverseTagOrder) {
-  std::string data;
-  {
-    unittest::TestMessageSetExtension1 message;
-    message.set_i(123);
-    // Build a MessageSet manually with its message content put before its
-    // type_id.
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    coded_output.WriteTag(WireFormatLite::kMessageSetItemStartTag);
-    // Write the message content first.
-    WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
-                             WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                             &coded_output);
-    coded_output.WriteVarint32(message.ByteSizeLong());
-    message.SerializeWithCachedSizes(&coded_output);
-    // Write the type id.
-    uint32 type_id = message.GetDescriptor()->extension(0)->number();
-    WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber,
-                                type_id, &coded_output);
-    coded_output.WriteTag(WireFormatLite::kMessageSetItemEndTag);
-  }
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    ASSERT_TRUE(message_set.ParseFromString(data));
-
-    EXPECT_EQ(123,
-              message_set
-                  .GetExtension(
-                      unittest::TestMessageSetExtension1::message_set_extension)
-                  .i());
-  }
-  {
-    // Test parse the message via Reflection.
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    io::CodedInputStream input(reinterpret_cast<const uint8*>(data.data()),
-                               data.size());
-    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&input, &message_set));
-    EXPECT_TRUE(input.ConsumedEntireMessage());
-
-    EXPECT_EQ(123,
-              message_set
-                  .GetExtension(
-                      unittest::TestMessageSetExtension1::message_set_extension)
-                  .i());
-  }
-}
-
-void SerializeReverseOrder(
-    const proto2_wireformat_unittest::TestMessageSet& mset,
-    io::CodedOutputStream* coded_output);
-
-void SerializeReverseOrder(const unittest::TestMessageSetExtension1& message,
-                           io::CodedOutputStream* coded_output) {
-  WireFormatLite::WriteTag(15,  // i
-                           WireFormatLite::WIRETYPE_VARINT, coded_output);
-  coded_output->WriteVarint64(message.i());
-  WireFormatLite::WriteTag(16,  // recursive
-                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                           coded_output);
-  coded_output->WriteVarint32(message.recursive().GetCachedSize());
-  SerializeReverseOrder(message.recursive(), coded_output);
-}
-
-void SerializeReverseOrder(
-    const proto2_wireformat_unittest::TestMessageSet& mset,
-    io::CodedOutputStream* coded_output) {
-  if (!mset.HasExtension(
-          unittest::TestMessageSetExtension1::message_set_extension))
-    return;
-  coded_output->WriteTag(WireFormatLite::kMessageSetItemStartTag);
-  // Write the message content first.
-  WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
-                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                           coded_output);
-  auto& message = mset.GetExtension(
-      unittest::TestMessageSetExtension1::message_set_extension);
-  coded_output->WriteVarint32(message.GetCachedSize());
-  SerializeReverseOrder(message, coded_output);
-  // Write the type id.
-  uint32 type_id = message.GetDescriptor()->extension(0)->number();
-  WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber, type_id,
-                              coded_output);
-  coded_output->WriteTag(WireFormatLite::kMessageSetItemEndTag);
-}
-
-TEST(WireFormatTest, ParseMessageSetWithDeepRecReverseOrder) {
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < 200; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    message_set.ByteSizeLong();
-    // Serialize with reverse payload tag order
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    SerializeReverseOrder(message_set, &coded_output);
-  }
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseFailMalformedMessageSet) {
-  constexpr int kDepth = 5;
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < kDepth; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    auto m = mset->MutableExtension(
-        unittest::TestMessageSetExtension1::message_set_extension);
-    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
-    m->set_i(-1);
-
-    EXPECT_TRUE(message_set.SerializeToString(&data));
-    // Make the proto mal-formed.
-    data[data.size() - 2 - kDepth] = 0xFF;
-  }
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseFailMalformedMessageSetReverseOrder) {
-  constexpr int kDepth = 5;
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < kDepth; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    auto m = mset->MutableExtension(
-        unittest::TestMessageSetExtension1::message_set_extension);
-    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
-    m->set_i(-1);
-    // SerializeReverseOrder() assumes "recursive" is always present.
-    m->mutable_recursive();
-
-    message_set.ByteSizeLong();
-
-    // Serialize with reverse payload tag order
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    SerializeReverseOrder(message_set, &coded_output);
-  }
-
-  // Make varint for -1 malformed.
-  data[data.size() - 5 * (kDepth + 1) - 4] = 0xFF;
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseBrokenMessageSet) {
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  std::string input("goodbye");  // Invalid wire format data.
-  EXPECT_FALSE(message_set.ParseFromString(input));
-}
-
-TEST(WireFormatTest, RecursionLimit) {
-  unittest::TestRecursiveMessage message;
-  message.mutable_a()->mutable_a()->mutable_a()->mutable_a()->set_i(1);
-  std::string data;
-  message.SerializeToString(&data);
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(4);
-    unittest::TestRecursiveMessage message2;
-    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
-  }
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(3);
-    unittest::TestRecursiveMessage message2;
-    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
-  }
-}
-
-TEST(WireFormatTest, UnknownFieldRecursionLimit) {
-  unittest::TestEmptyMessage message;
-  message.mutable_unknown_fields()
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddVarint(1234, 123);
-  std::string data;
-  message.SerializeToString(&data);
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(4);
-    unittest::TestEmptyMessage message2;
-    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
-  }
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(3);
-    unittest::TestEmptyMessage message2;
-    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
-  }
-}
-
-TEST(WireFormatTest, ZigZag) {
-// avoid line-wrapping
-#define LL(x) static_cast<int64_t>(ULL(x))
-#define ULL(x) uint64_t{x##u}
-#define ZigZagEncode32(x) WireFormatLite::ZigZagEncode32(x)
-#define ZigZagDecode32(x) WireFormatLite::ZigZagDecode32(x)
-#define ZigZagEncode64(x) WireFormatLite::ZigZagEncode64(x)
-#define ZigZagDecode64(x) WireFormatLite::ZigZagDecode64(x)
-
-  EXPECT_EQ(0u, ZigZagEncode32(0));
-  EXPECT_EQ(1u, ZigZagEncode32(-1));
-  EXPECT_EQ(2u, ZigZagEncode32(1));
-  EXPECT_EQ(3u, ZigZagEncode32(-2));
-  EXPECT_EQ(0x7FFFFFFEu, ZigZagEncode32(0x3FFFFFFF));
-  EXPECT_EQ(0x7FFFFFFFu, ZigZagEncode32(0xC0000000));
-  EXPECT_EQ(0xFFFFFFFEu, ZigZagEncode32(0x7FFFFFFF));
-  EXPECT_EQ(0xFFFFFFFFu, ZigZagEncode32(0x80000000));
-
-  EXPECT_EQ(0, ZigZagDecode32(0u));
-  EXPECT_EQ(-1, ZigZagDecode32(1u));
-  EXPECT_EQ(1, ZigZagDecode32(2u));
-  EXPECT_EQ(-2, ZigZagDecode32(3u));
-  EXPECT_EQ(0x3FFFFFFF, ZigZagDecode32(0x7FFFFFFEu));
-  EXPECT_EQ(0xC0000000, ZigZagDecode32(0x7FFFFFFFu));
-  EXPECT_EQ(0x7FFFFFFF, ZigZagDecode32(0xFFFFFFFEu));
-  EXPECT_EQ(0x80000000, ZigZagDecode32(0xFFFFFFFFu));
-
-  EXPECT_EQ(0u, ZigZagEncode64(0));
-  EXPECT_EQ(1u, ZigZagEncode64(-1));
-  EXPECT_EQ(2u, ZigZagEncode64(1));
-  EXPECT_EQ(3u, ZigZagEncode64(-2));
-  EXPECT_EQ(ULL(0x000000007FFFFFFE), ZigZagEncode64(LL(0x000000003FFFFFFF)));
-  EXPECT_EQ(ULL(0x000000007FFFFFFF), ZigZagEncode64(LL(0xFFFFFFFFC0000000)));
-  EXPECT_EQ(ULL(0x00000000FFFFFFFE), ZigZagEncode64(LL(0x000000007FFFFFFF)));
-  EXPECT_EQ(ULL(0x00000000FFFFFFFF), ZigZagEncode64(LL(0xFFFFFFFF80000000)));
-  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFE), ZigZagEncode64(LL(0x7FFFFFFFFFFFFFFF)));
-  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFF), ZigZagEncode64(LL(0x8000000000000000)));
-
-  EXPECT_EQ(0, ZigZagDecode64(0u));
-  EXPECT_EQ(-1, ZigZagDecode64(1u));
-  EXPECT_EQ(1, ZigZagDecode64(2u));
-  EXPECT_EQ(-2, ZigZagDecode64(3u));
-  EXPECT_EQ(LL(0x000000003FFFFFFF), ZigZagDecode64(ULL(0x000000007FFFFFFE)));
-  EXPECT_EQ(LL(0xFFFFFFFFC0000000), ZigZagDecode64(ULL(0x000000007FFFFFFF)));
-  EXPECT_EQ(LL(0x000000007FFFFFFF), ZigZagDecode64(ULL(0x00000000FFFFFFFE)));
-  EXPECT_EQ(LL(0xFFFFFFFF80000000), ZigZagDecode64(ULL(0x00000000FFFFFFFF)));
-  EXPECT_EQ(LL(0x7FFFFFFFFFFFFFFF), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFE)));
-  EXPECT_EQ(LL(0x8000000000000000), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFF)));
-
-  // Some easier-to-verify round-trip tests.  The inputs (other than 0, 1, -1)
-  // were chosen semi-randomly via keyboard bashing.
-  EXPECT_EQ(0, ZigZagDecode32(ZigZagEncode32(0)));
-  EXPECT_EQ(1, ZigZagDecode32(ZigZagEncode32(1)));
-  EXPECT_EQ(-1, ZigZagDecode32(ZigZagEncode32(-1)));
-  EXPECT_EQ(14927, ZigZagDecode32(ZigZagEncode32(14927)));
-  EXPECT_EQ(-3612, ZigZagDecode32(ZigZagEncode32(-3612)));
-
-  EXPECT_EQ(0, ZigZagDecode64(ZigZagEncode64(0)));
-  EXPECT_EQ(1, ZigZagDecode64(ZigZagEncode64(1)));
-  EXPECT_EQ(-1, ZigZagDecode64(ZigZagEncode64(-1)));
-  EXPECT_EQ(14927, ZigZagDecode64(ZigZagEncode64(14927)));
-  EXPECT_EQ(-3612, ZigZagDecode64(ZigZagEncode64(-3612)));
-
-  EXPECT_EQ(LL(856912304801416),
-            ZigZagDecode64(ZigZagEncode64(LL(856912304801416))));
-  EXPECT_EQ(LL(-75123905439571256),
-            ZigZagDecode64(ZigZagEncode64(LL(-75123905439571256))));
-}
-
-TEST(WireFormatTest, RepeatedScalarsDifferentTagSizes) {
-  // At one point checks would trigger when parsing repeated fixed scalar
-  // fields.
-  protobuf_unittest::TestRepeatedScalarDifferentTagSizes msg1, msg2;
-  for (int i = 0; i < 100; ++i) {
-    msg1.add_repeated_fixed32(i);
-    msg1.add_repeated_int32(i);
-    msg1.add_repeated_fixed64(i);
-    msg1.add_repeated_int64(i);
-    msg1.add_repeated_float(i);
-    msg1.add_repeated_uint64(i);
-  }
-
-  // Make sure that we have a variety of tag sizes.
-  const Descriptor* desc = msg1.GetDescriptor();
-  const FieldDescriptor* field;
-  field = desc->FindFieldByName("repeated_fixed32");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_int32");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_fixed64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_int64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_float");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_uint64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
-
-  EXPECT_TRUE(msg2.ParseFromString(msg1.SerializeAsString()));
-  EXPECT_EQ(msg1.DebugString(), msg2.DebugString());
-}
-
-TEST(WireFormatTest, CompatibleTypes) {
-  const int64 data = 0x100000000LL;
-  unittest::Int64Message msg1;
-  msg1.set_data(data);
-  std::string serialized;
-  msg1.SerializeToString(&serialized);
-
-  // Test int64 is compatible with bool
-  unittest::BoolMessage msg2;
-  ASSERT_TRUE(msg2.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<bool>(data), msg2.data());
-
-  // Test int64 is compatible with uint64
-  unittest::Uint64Message msg3;
-  ASSERT_TRUE(msg3.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<uint64>(data), msg3.data());
-
-  // Test int64 is compatible with int32
-  unittest::Int32Message msg4;
-  ASSERT_TRUE(msg4.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<int32>(data), msg4.data());
-
-  // Test int64 is compatible with uint32
-  unittest::Uint32Message msg5;
-  ASSERT_TRUE(msg5.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<uint32>(data), msg5.data());
-}
-
-class Proto3PrimitiveRepeatedWireFormatTest : public ::testing::Test {
- protected:
-  Proto3PrimitiveRepeatedWireFormatTest()
-      : packedTestAllTypes_(
-            "\xFA\x01\x01\x01"
-            "\x82\x02\x01\x01"
-            "\x8A\x02\x01\x01"
-            "\x92\x02\x01\x01"
-            "\x9A\x02\x01\x02"
-            "\xA2\x02\x01\x02"
-            "\xAA\x02\x04\x01\x00\x00\x00"
-            "\xB2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xBA\x02\x04\x01\x00\x00\x00"
-            "\xC2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xCA\x02\x04\x00\x00\x80\x3f"
-            "\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\xDA\x02\x01\x01"
-            "\x9A\x03\x01\x01",
-            86),
-        packedTestUnpackedTypes_(
-            "\x0A\x01\x01"
-            "\x12\x01\x01"
-            "\x1A\x01\x01"
-            "\x22\x01\x01"
-            "\x2A\x01\x02"
-            "\x32\x01\x02"
-            "\x3A\x04\x01\x00\x00\x00"
-            "\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x4A\x04\x01\x00\x00\x00"
-            "\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x5A\x04\x00\x00\x80\x3f"
-            "\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\x6A\x01\x01"
-            "\x72\x01\x01",
-            72),
-        unpackedTestAllTypes_(
-            "\xF8\x01\x01"
-            "\x80\x02\x01"
-            "\x88\x02\x01"
-            "\x90\x02\x01"
-            "\x98\x02\x02"
-            "\xA0\x02\x02"
-            "\xAD\x02\x01\x00\x00\x00"
-            "\xB1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xBD\x02\x01\x00\x00\x00"
-            "\xC1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xCD\x02\x00\x00\x80\x3f"
-            "\xD1\x02\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\xD8\x02\x01"
-            "\x98\x03\x01",
-            72),
-        unpackedTestUnpackedTypes_(
-            "\x08\x01"
-            "\x10\x01"
-            "\x18\x01"
-            "\x20\x01"
-            "\x28\x02"
-            "\x30\x02"
-            "\x3D\x01\x00\x00\x00"
-            "\x41\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x4D\x01\x00\x00\x00"
-            "\x51\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x5D\x00\x00\x80\x3f"
-            "\x61\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\x68\x01"
-            "\x70\x01",
-            58) {}
-  template <class Proto>
-  void SetProto3PrimitiveRepeatedFields(Proto* message) {
-    message->add_repeated_int32(1);
-    message->add_repeated_int64(1);
-    message->add_repeated_uint32(1);
-    message->add_repeated_uint64(1);
-    message->add_repeated_sint32(1);
-    message->add_repeated_sint64(1);
-    message->add_repeated_fixed32(1);
-    message->add_repeated_fixed64(1);
-    message->add_repeated_sfixed32(1);
-    message->add_repeated_sfixed64(1);
-    message->add_repeated_float(1.0);
-    message->add_repeated_double(1.0);
-    message->add_repeated_bool(true);
-    message->add_repeated_nested_enum(proto3_arena_unittest::TestAllTypes::FOO);
-  }
-
-  template <class Proto>
-  void ExpectProto3PrimitiveRepeatedFieldsSet(const Proto& message) {
-    EXPECT_EQ(1, message.repeated_int32(0));
-    EXPECT_EQ(1, message.repeated_int64(0));
-    EXPECT_EQ(1, message.repeated_uint32(0));
-    EXPECT_EQ(1, message.repeated_uint64(0));
-    EXPECT_EQ(1, message.repeated_sint32(0));
-    EXPECT_EQ(1, message.repeated_sint64(0));
-    EXPECT_EQ(1, message.repeated_fixed32(0));
-    EXPECT_EQ(1, message.repeated_fixed64(0));
-    EXPECT_EQ(1, message.repeated_sfixed32(0));
-    EXPECT_EQ(1, message.repeated_sfixed64(0));
-    EXPECT_EQ(1.0, message.repeated_float(0));
-    EXPECT_EQ(1.0, message.repeated_double(0));
-    EXPECT_EQ(true, message.repeated_bool(0));
-    EXPECT_EQ(proto3_arena_unittest::TestAllTypes::FOO,
-              message.repeated_nested_enum(0));
-  }
-
-  template <class Proto>
-  void TestSerialization(Proto* message, const std::string& expected) {
-    SetProto3PrimitiveRepeatedFields(message);
-
-    size_t size = message->ByteSizeLong();
-
-    // Serialize using the generated code.
-    std::string generated_data;
-    {
-      io::StringOutputStream raw_output(&generated_data);
-      io::CodedOutputStream output(&raw_output);
-      message->SerializeWithCachedSizes(&output);
-      ASSERT_FALSE(output.HadError());
-    }
-    EXPECT_TRUE(TestUtil::EqualsToSerialized(*message, generated_data));
-
-    // Serialize using the dynamic code.
-    std::string dynamic_data;
-    {
-      io::StringOutputStream raw_output(&dynamic_data);
-      io::CodedOutputStream output(&raw_output);
-      WireFormat::SerializeWithCachedSizes(*message, size, &output);
-      ASSERT_FALSE(output.HadError());
-    }
-    EXPECT_TRUE(expected == dynamic_data);
-  }
-
-  template <class Proto>
-  void TestParsing(Proto* message, const std::string& compatible_data) {
-    message->Clear();
-    message->ParseFromString(compatible_data);
-    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
-
-    message->Clear();
-    io::CodedInputStream input(
-        reinterpret_cast<const uint8*>(compatible_data.data()),
-        compatible_data.size());
-    WireFormat::ParseAndMergePartial(&input, message);
-    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
-  }
-
-  const std::string packedTestAllTypes_;
-  const std::string packedTestUnpackedTypes_;
-  const std::string unpackedTestAllTypes_;
-  const std::string unpackedTestUnpackedTypes_;
-};
-
-TEST_F(Proto3PrimitiveRepeatedWireFormatTest, Proto3PrimitiveRepeated) {
-  proto3_arena_unittest::TestAllTypes packed_message;
-  proto3_arena_unittest::TestUnpackedTypes unpacked_message;
-  TestSerialization(&packed_message, packedTestAllTypes_);
-  TestParsing(&packed_message, packedTestAllTypes_);
-  TestParsing(&packed_message, unpackedTestAllTypes_);
-  TestSerialization(&unpacked_message, unpackedTestUnpackedTypes_);
-  TestParsing(&unpacked_message, packedTestUnpackedTypes_);
-  TestParsing(&unpacked_message, unpackedTestUnpackedTypes_);
-}
-
-class WireFormatInvalidInputTest : public testing::Test {
- protected:
-  // Make a serialized TestAllTypes in which the field optional_nested_message
-  // contains exactly the given bytes, which may be invalid.
-  std::string MakeInvalidEmbeddedMessage(const char* bytes, int size) {
-    const FieldDescriptor* field =
-        unittest::TestAllTypes::descriptor()->FindFieldByName(
-            "optional_nested_message");
-    GOOGLE_CHECK(field != NULL);
-
-    std::string result;
-
-    {
-      io::StringOutputStream raw_output(&result);
-      io::CodedOutputStream output(&raw_output);
-
-      WireFormatLite::WriteBytes(field->number(), std::string(bytes, size),
-                                 &output);
-    }
-
-    return result;
-  }
-
-  // Make a serialized TestAllTypes in which the field optionalgroup
-  // contains exactly the given bytes -- which may be invalid -- and
-  // possibly no end tag.
-  std::string MakeInvalidGroup(const char* bytes, int size,
-                               bool include_end_tag) {
-    const FieldDescriptor* field =
-        unittest::TestAllTypes::descriptor()->FindFieldByName("optionalgroup");
-    GOOGLE_CHECK(field != NULL);
-
-    std::string result;
-
-    {
-      io::StringOutputStream raw_output(&result);
-      io::CodedOutputStream output(&raw_output);
-
-      output.WriteVarint32(WireFormat::MakeTag(field));
-      output.WriteString(std::string(bytes, size));
-      if (include_end_tag) {
-        output.WriteVarint32(WireFormatLite::MakeTag(
-            field->number(), WireFormatLite::WIRETYPE_END_GROUP));
-      }
-    }
-
-    return result;
-  }
-};
-
-TEST_F(WireFormatInvalidInputTest, InvalidSubMessage) {
-  unittest::TestAllTypes message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidEmbeddedMessage("", 0)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\0", 1)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\200", 1)));
-
-  // The byte is an endgroup tag, but we aren't parsing a group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\014", 1)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\017", 1)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidMessageWithExtraZero) {
-  std::string data;
-  {
-    // Serialize a valid proto
-    unittest::TestAllTypes message;
-    message.set_optional_int32(1);
-    message.SerializeToString(&data);
-    data.push_back(0);  // Append invalid zero tag
-  }
-
-  // Control case.
-  {
-    io::ArrayInputStream ais(data.data(), data.size());
-    io::CodedInputStream is(&ais);
-    unittest::TestAllTypes message;
-    // It should fail but currently passes.
-    EXPECT_TRUE(message.MergePartialFromCodedStream(&is));
-    // Parsing from the string should fail.
-    EXPECT_FALSE(message.ParseFromString(data));
-  }
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidGroup) {
-  unittest::TestAllTypes message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
-
-  // Missing end tag.  Groups cannot end at EOF.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
-
-  // The byte is an endgroup tag, but not the right one for this group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidUnknownGroup) {
-  // Use TestEmptyMessage so that the group made by MakeInvalidGroup will not
-  // be a known tag number.
-  unittest::TestEmptyMessage message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
-
-  // Missing end tag.  Groups cannot end at EOF.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
-
-  // The byte is an endgroup tag, but not the right one for this group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidStringInUnknownGroup) {
-  // Test a bug fix:  SkipMessage should fail if the message contains a
-  // string whose length would extend beyond the message end.
-
-  unittest::TestAllTypes message;
-  message.set_optional_string("foo foo foo foo");
-  std::string data;
-  message.SerializeToString(&data);
-
-  // Chop some bytes off the end.
-  data.resize(data.size() - 4);
-
-  // Try to skip it.  Note that the bug was only present when parsing to an
-  // UnknownFieldSet.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream coded_input(&raw_input);
-  UnknownFieldSet unknown_fields;
-  EXPECT_FALSE(WireFormat::SkipMessage(&coded_input, &unknown_fields));
-}
-
-// Test differences between string and bytes.
-// Value of a string type must be valid UTF-8 string.  When UTF-8
-// validation is enabled (GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED):
-// WriteInvalidUTF8String:  see error message.
-// ReadInvalidUTF8String:  see error message.
-// WriteValidUTF8String: fine.
-// ReadValidUTF8String:  fine.
-// WriteAnyBytes: fine.
-// ReadAnyBytes: fine.
-const char* kInvalidUTF8String = "Invalid UTF-8: \xA0\xB0\xC0\xD0";
-// This used to be "Valid UTF-8: \x01\x02\u8C37\u6B4C", but MSVC seems to
-// interpret \u differently from GCC.
-const char* kValidUTF8String = "Valid UTF-8: \x01\x02\350\260\267\346\255\214";
-
-template <typename T>
-bool WriteMessage(const char* value, T* message, std::string* wire_buffer) {
-  message->set_data(value);
-  wire_buffer->clear();
-  message->AppendToString(wire_buffer);
-  return (wire_buffer->size() > 0);
-}
-
-template <typename T>
-bool ReadMessage(const std::string& wire_buffer, T* message) {
-  return message->ParseFromArray(wire_buffer.data(), wire_buffer.size());
-}
-
-class Utf8ValidationTest : public ::testing::Test {
- protected:
-  Utf8ValidationTest() {}
-  virtual ~Utf8ValidationTest() {}
-  virtual void SetUp() {
-  }
-
-};
-
-TEST_F(Utf8ValidationTest, WriteInvalidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field 'protobuf_unittest.OneString.data' "
-                       "contains invalid UTF-8 data when "
-                       "serializing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-}
-
-
-TEST_F(Utf8ValidationTest, ReadInvalidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field 'protobuf_unittest.OneString.data' "
-                       "contains invalid UTF-8 data when "
-                       "parsing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-}
-
-
-TEST_F(Utf8ValidationTest, WriteValidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kValidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-}
-
-TEST_F(Utf8ValidationTest, ReadValidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  WriteMessage(kValidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-  EXPECT_EQ(input.data(), output.data());
-}
-
-// Bytes: anything can pass as bytes, use invalid UTF-8 string to test
-TEST_F(Utf8ValidationTest, WriteArbitraryBytes) {
-  std::string wire_buffer;
-  protobuf_unittest::OneBytes input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-}
-
-TEST_F(Utf8ValidationTest, ReadArbitraryBytes) {
-  std::string wire_buffer;
-  protobuf_unittest::OneBytes input;
-  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneBytes output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-  EXPECT_EQ(input.data(), output.data());
-}
-
-TEST_F(Utf8ValidationTest, ParseRepeatedString) {
-  protobuf_unittest::MoreBytes input;
-  input.add_data(kValidUTF8String);
-  input.add_data(kInvalidUTF8String);
-  input.add_data(kInvalidUTF8String);
-  std::string wire_buffer = input.SerializeAsString();
-
-  protobuf_unittest::MoreString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(2, errors.size());
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  EXPECT_EQ(wire_buffer, output.SerializeAsString());
-}
-
-// Test the old VerifyUTF8String() function, which may still be called by old
-// generated code.
-TEST_F(Utf8ValidationTest, OldVerifyUTF8String) {
-  std::string data(kInvalidUTF8String);
-
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WireFormat::VerifyUTF8String(data.data(), data.size(),
-                                 WireFormat::SERIALIZE);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field contains invalid UTF-8 data when "
-                       "serializing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-#else
-  ASSERT_EQ(0, errors.size());
-#endif
-}
-
-
-TEST(RepeatedVarint, Int32) {
-  RepeatedField<int32> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar Int32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::Int32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::Int32Size(v));
-}
-
-TEST(RepeatedVarint, Int64) {
-  RepeatedField<int64> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar Int64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::Int64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::Int64Size(v));
-}
-
-TEST(RepeatedVarint, SInt32) {
-  RepeatedField<int32> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar SInt32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::SInt32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::SInt32Size(v));
-}
-
-TEST(RepeatedVarint, SInt64) {
-  RepeatedField<int64> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar SInt64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::SInt64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::SInt64Size(v));
-}
-
-TEST(RepeatedVarint, UInt32) {
-  RepeatedField<uint32> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar UInt32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::UInt32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::UInt32Size(v));
-}
-
-TEST(RepeatedVarint, UInt64) {
-  RepeatedField<uint64> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar UInt64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::UInt64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::UInt64Size(v));
-}
-
-TEST(RepeatedVarint, Enum) {
-  RepeatedField<int> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar EnumSize.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::EnumSize(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::EnumSize(v));
-}
 
 
 }  // namespace
Only in protobuf-3.17.3-patched/src/google/protobuf: wire_format_unittest.inc
