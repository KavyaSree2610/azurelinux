diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/extension_set_inl.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/extension_set_inl.h
index 074784b..f88e170 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/extension_set_inl.h
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/extension_set_inl.h
@@ -31,9 +31,9 @@
 #ifndef GOOGLE_PROTOBUF_EXTENSION_SET_INL_H__
 #define GOOGLE_PROTOBUF_EXTENSION_SET_INL_H__
 
-#include <google/protobuf/parse_context.h>
 #include <google/protobuf/extension_set.h>
 #include <google/protobuf/metadata_lite.h>
+#include <google/protobuf/parse_context.h>
 
 namespace google {
 namespace protobuf {
@@ -83,7 +83,7 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
     switch (extension.type) {
 #define HANDLE_VARINT_TYPE(UPPERCASE, CPP_CAMELCASE)                        \
   case WireFormatLite::TYPE_##UPPERCASE: {                                  \
-    uint64 value;                                                           \
+    uint64_t value;                                                         \
     ptr = VarintParse(ptr, &value);                                         \
     GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
     if (extension.is_repeated) {                                            \
@@ -103,7 +103,7 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
 #undef HANDLE_VARINT_TYPE
 #define HANDLE_SVARINT_TYPE(UPPERCASE, CPP_CAMELCASE, SIZE)                 \
   case WireFormatLite::TYPE_##UPPERCASE: {                                  \
-    uint64 val;                                                             \
+    uint64_t val;                                                             \
     ptr = VarintParse(ptr, &val);                                           \
     GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
     auto value = WireFormatLite::ZigZagDecode##SIZE(val);                   \
@@ -132,16 +132,16 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
     }                                                                       \
   } break
 
-      HANDLE_FIXED_TYPE(FIXED32, UInt32, uint32);
-      HANDLE_FIXED_TYPE(FIXED64, UInt64, uint64);
-      HANDLE_FIXED_TYPE(SFIXED32, Int32, int32);
-      HANDLE_FIXED_TYPE(SFIXED64, Int64, int64);
+      HANDLE_FIXED_TYPE(FIXED32, UInt32, uint32_t);
+      HANDLE_FIXED_TYPE(FIXED64, UInt64, uint64_t);
+      HANDLE_FIXED_TYPE(SFIXED32, Int32, int32_t);
+      HANDLE_FIXED_TYPE(SFIXED64, Int64, int64_t);
       HANDLE_FIXED_TYPE(FLOAT, Float, float);
       HANDLE_FIXED_TYPE(DOUBLE, Double, double);
 #undef HANDLE_FIXED_TYPE
 
       case WireFormatLite::TYPE_ENUM: {
-        uint64 val;
+        uint64_t val;
         ptr = VarintParse(ptr, &val);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
         int value = val;
@@ -181,7 +181,7 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
                 : MutableMessage(number, WireFormatLite::TYPE_GROUP,
                                  *extension.message_info.prototype,
                                  extension.descriptor);
-        uint32 tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
+        uint32_t tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
         return ctx->ParseGroup(value, ptr, tag);
       }
 
@@ -203,22 +203,27 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
 
 template <typename Msg, typename T>
 const char* ExtensionSet::ParseMessageSetItemTmpl(
-    const char* ptr, const Msg* containing_type,
-    internal::InternalMetadata* metadata, internal::ParseContext* ctx) {
+    const char* ptr, const Msg* extendee, internal::InternalMetadata* metadata,
+    internal::ParseContext* ctx) {
   std::string payload;
-  uint32 type_id = 0;
-  bool payload_read = false;
+  uint32_t type_id;
+  enum class State { kNoTag, kHasType, kHasPayload, kDone };
+  State state = State::kNoTag;
+
   while (!ctx->Done(&ptr)) {
-    uint32 tag = static_cast<uint8>(*ptr++);
+    uint32_t tag = static_cast<uint8_t>(*ptr++);
     if (tag == WireFormatLite::kMessageSetTypeIdTag) {
-      uint64 tmp;
+      uint64_t tmp;
       ptr = ParseBigVarint(ptr, &tmp);
       GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-      type_id = tmp;
-      if (payload_read) {
+      if (state == State::kNoTag) {
+        type_id = tmp;
+        state = State::kHasType;
+      } else if (state == State::kHasPayload) {
+        type_id = tmp;
         ExtensionInfo extension;
         bool was_packed_on_wire;
-        if (!FindExtension(2, type_id, containing_type, ctx, &extension,
+        if (!FindExtension(2, type_id, extendee, ctx, &extension,
                            &was_packed_on_wire)) {
           WriteLengthDelimited(type_id, payload,
                                metadata->mutable_unknown_fields<T>());
@@ -241,20 +246,24 @@ const char* ExtensionSet::ParseMessageSetItemTmpl(
           GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
                                          tmp_ctx.EndedAtLimit());
         }
-        type_id = 0;
+        state = State::kDone;
       }
     } else if (tag == WireFormatLite::kMessageSetMessageTag) {
-      if (type_id != 0) {
-        ptr = ParseFieldMaybeLazily(static_cast<uint64>(type_id) * 8 + 2, ptr,
-                                    containing_type, metadata, ctx);
+      if (state == State::kHasType) {
+        ptr = ParseFieldMaybeLazily(static_cast<uint64_t>(type_id) * 8 + 2, ptr,
+                                    extendee, metadata, ctx);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
-        type_id = 0;
+        state = State::kDone;
       } else {
-        int32 size = ReadSize(&ptr);
+        std::string tmp;
+        int32_t size = ReadSize(&ptr);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        ptr = ctx->ReadString(ptr, size, &payload);
+        ptr = ctx->ReadString(ptr, size, &tmp);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        payload_read = true;
+        if (state == State::kNoTag) {
+          payload = std::move(tmp);
+          state = State::kHasPayload;
+        }
       }
     } else {
       ptr = ReadTag(ptr - 1, &tag);
@@ -262,7 +271,7 @@ const char* ExtensionSet::ParseMessageSetItemTmpl(
         ctx->SetLastTag(tag);
         return ptr;
       }
-      ptr = ParseField(tag, ptr, containing_type, metadata, ctx);
+      ptr = ParseField(tag, ptr, extendee, metadata, ctx);
       GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
     }
   }
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.cc
index a318da4..0546393 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.cc
@@ -54,6 +54,7 @@
 #include <google/protobuf/stubs/stl_util.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -151,7 +152,7 @@ CodedInputStream::IncrementRecursionDepthAndPushLimit(int byte_limit) {
 }
 
 CodedInputStream::Limit CodedInputStream::ReadLengthAndPushLimit() {
-  uint32 length;
+  uint32_t length;
   return PushLimit(ReadVarint32(&length) ? length : 0);
 }
 
@@ -243,7 +244,7 @@ bool CodedInputStream::ReadRaw(void* buffer, int size) {
   while ((current_buffer_size = BufferSize()) < size) {
     // Reading past end of buffer.  Copy what we have, then refresh.
     memcpy(buffer, buffer_, current_buffer_size);
-    buffer = reinterpret_cast<uint8*>(buffer) + current_buffer_size;
+    buffer = reinterpret_cast<uint8_t*>(buffer) + current_buffer_size;
     size -= current_buffer_size;
     Advance(current_buffer_size);
     if (!Refresh()) return false;
@@ -308,11 +309,11 @@ bool CodedInputStream::ReadStringFallback(std::string* buffer, int size) {
 }
 
 
-bool CodedInputStream::ReadLittleEndian32Fallback(uint32* value) {
-  uint8 bytes[sizeof(*value)];
+bool CodedInputStream::ReadLittleEndian32Fallback(uint32_t* value) {
+  uint8_t bytes[sizeof(*value)];
 
-  const uint8* ptr;
-  if (BufferSize() >= static_cast<int64>(sizeof(*value))) {
+  const uint8_t* ptr;
+  if (BufferSize() >= static_cast<int64_t>(sizeof(*value))) {
     // Fast path:  Enough bytes in the buffer to read directly.
     ptr = buffer_;
     Advance(sizeof(*value));
@@ -325,11 +326,11 @@ bool CodedInputStream::ReadLittleEndian32Fallback(uint32* value) {
   return true;
 }
 
-bool CodedInputStream::ReadLittleEndian64Fallback(uint64* value) {
-  uint8 bytes[sizeof(*value)];
+bool CodedInputStream::ReadLittleEndian64Fallback(uint64_t* value) {
+  uint8_t bytes[sizeof(*value)];
 
-  const uint8* ptr;
-  if (BufferSize() >= static_cast<int64>(sizeof(*value))) {
+  const uint8_t* ptr;
+  if (BufferSize() >= static_cast<int64_t>(sizeof(*value))) {
     // Fast path:  Enough bytes in the buffer to read directly.
     ptr = buffer_;
     Advance(sizeof(*value));
@@ -348,11 +349,11 @@ namespace {
 // compile time, compiler can generate optimal code. For example, instead of
 // subtracting 0x80 at each iteration, it subtracts properly shifted mask once.
 template <size_t N>
-const uint8* DecodeVarint64KnownSize(const uint8* buffer, uint64* value) {
+const uint8_t* DecodeVarint64KnownSize(const uint8_t* buffer, uint64_t* value) {
   GOOGLE_DCHECK_GT(N, 0);
-  uint64 result = static_cast<uint64>(buffer[N - 1]) << (7 * (N - 1));
+  uint64_t result = static_cast<uint64_t>(buffer[N - 1]) << (7 * (N - 1));
   for (size_t i = 0, offset = 0; i < N - 1; i++, offset += 7) {
-    result += static_cast<uint64>(buffer[i] - 0x80) << offset;
+    result += static_cast<uint64_t>(buffer[i] - 0x80) << offset;
   }
   *value = result;
   return buffer + N;
@@ -363,18 +364,18 @@ const uint8* DecodeVarint64KnownSize(const uint8* buffer, uint64* value) {
 // part is buffer + (number of bytes read).  This function is always inlined,
 // so returning a pair is costless.
 PROTOBUF_ALWAYS_INLINE
-::std::pair<bool, const uint8*> ReadVarint32FromArray(uint32 first_byte,
-                                                      const uint8* buffer,
-                                                      uint32* value);
-inline ::std::pair<bool, const uint8*> ReadVarint32FromArray(
-    uint32 first_byte, const uint8* buffer, uint32* value) {
+::std::pair<bool, const uint8_t*> ReadVarint32FromArray(uint32_t first_byte,
+                                                      const uint8_t* buffer,
+                                                      uint32_t* value);
+inline ::std::pair<bool, const uint8_t*> ReadVarint32FromArray(
+    uint32_t first_byte, const uint8_t* buffer, uint32_t* value) {
   // Fast path:  We have enough bytes left in the buffer to guarantee that
   // this read won't cross the end, so we can skip the checks.
   GOOGLE_DCHECK_EQ(*buffer, first_byte);
   GOOGLE_DCHECK_EQ(first_byte & 0x80, 0x80) << first_byte;
-  const uint8* ptr = buffer;
-  uint32 b;
-  uint32 result = first_byte - 0x80;
+  const uint8_t* ptr = buffer;
+  uint32_t b;
+  uint32_t result = first_byte - 0x80;
   ++ptr;  // We just processed the first byte.  Move on to the second.
   b = *(ptr++);
   result += b << 7;
@@ -409,14 +410,14 @@ done:
   return std::make_pair(true, ptr);
 }
 
-PROTOBUF_ALWAYS_INLINE::std::pair<bool, const uint8*> ReadVarint64FromArray(
-    const uint8* buffer, uint64* value);
-inline ::std::pair<bool, const uint8*> ReadVarint64FromArray(
-    const uint8* buffer, uint64* value) {
+PROTOBUF_ALWAYS_INLINE::std::pair<bool, const uint8_t*> ReadVarint64FromArray(
+    const uint8_t* buffer, uint64_t* value);
+inline ::std::pair<bool, const uint8_t*> ReadVarint64FromArray(
+    const uint8_t* buffer, uint64_t* value) {
   // Assumes varint64 is at least 2 bytes.
   GOOGLE_DCHECK_GE(buffer[0], 128);
 
-  const uint8* next;
+  const uint8_t* next;
   if (buffer[1] < 128) {
     next = DecodeVarint64KnownSize<2>(buffer, value);
   } else if (buffer[2] < 128) {
@@ -446,23 +447,23 @@ inline ::std::pair<bool, const uint8*> ReadVarint64FromArray(
 
 }  // namespace
 
-bool CodedInputStream::ReadVarint32Slow(uint32* value) {
+bool CodedInputStream::ReadVarint32Slow(uint32_t* value) {
   // Directly invoke ReadVarint64Fallback, since we already tried to optimize
   // for one-byte varints.
-  std::pair<uint64, bool> p = ReadVarint64Fallback();
-  *value = static_cast<uint32>(p.first);
+  std::pair<uint64_t, bool> p = ReadVarint64Fallback();
+  *value = static_cast<uint32_t>(p.first);
   return p.second;
 }
 
-int64 CodedInputStream::ReadVarint32Fallback(uint32 first_byte_or_zero) {
+int64_t CodedInputStream::ReadVarint32Fallback(uint32_t first_byte_or_zero) {
   if (BufferSize() >= kMaxVarintBytes ||
       // Optimization:  We're also safe if the buffer is non-empty and it ends
       // with a byte that would terminate a varint.
       (buffer_end_ > buffer_ && !(buffer_end_[-1] & 0x80))) {
     GOOGLE_DCHECK_NE(first_byte_or_zero, 0)
         << "Caller should provide us with *buffer_ when buffer is non-empty";
-    uint32 temp;
-    ::std::pair<bool, const uint8*> p =
+    uint32_t temp;
+    ::std::pair<bool, const uint8_t*> p =
         ReadVarint32FromArray(first_byte_or_zero, buffer_, &temp);
     if (!p.first) return -1;
     buffer_ = p.second;
@@ -471,16 +472,16 @@ int64 CodedInputStream::ReadVarint32Fallback(uint32 first_byte_or_zero) {
     // Really slow case: we will incur the cost of an extra function call here,
     // but moving this out of line reduces the size of this function, which
     // improves the common case. In micro benchmarks, this is worth about 10-15%
-    uint32 temp;
-    return ReadVarint32Slow(&temp) ? static_cast<int64>(temp) : -1;
+    uint32_t temp;
+    return ReadVarint32Slow(&temp) ? static_cast<int64_t>(temp) : -1;
   }
 }
 
 int CodedInputStream::ReadVarintSizeAsIntSlow() {
   // Directly invoke ReadVarint64Fallback, since we already tried to optimize
   // for one-byte varints.
-  std::pair<uint64, bool> p = ReadVarint64Fallback();
-  if (!p.second || p.first > static_cast<uint64>(INT_MAX)) return -1;
+  std::pair<uint64_t, bool> p = ReadVarint64Fallback();
+  if (!p.second || p.first > static_cast<uint64_t>(INT_MAX)) return -1;
   return p.first;
 }
 
@@ -489,9 +490,9 @@ int CodedInputStream::ReadVarintSizeAsIntFallback() {
       // Optimization:  We're also safe if the buffer is non-empty and it ends
       // with a byte that would terminate a varint.
       (buffer_end_ > buffer_ && !(buffer_end_[-1] & 0x80))) {
-    uint64 temp;
-    ::std::pair<bool, const uint8*> p = ReadVarint64FromArray(buffer_, &temp);
-    if (!p.first || temp > static_cast<uint64>(INT_MAX)) return -1;
+    uint64_t temp;
+    ::std::pair<bool, const uint8_t*> p = ReadVarint64FromArray(buffer_, &temp);
+    if (!p.first || temp > static_cast<uint64_t>(INT_MAX)) return -1;
     buffer_ = p.second;
     return temp;
   } else {
@@ -502,7 +503,7 @@ int CodedInputStream::ReadVarintSizeAsIntFallback() {
   }
 }
 
-uint32 CodedInputStream::ReadTagSlow() {
+uint32_t CodedInputStream::ReadTagSlow() {
   if (buffer_ == buffer_end_) {
     // Call refresh.
     if (!Refresh()) {
@@ -523,12 +524,12 @@ uint32 CodedInputStream::ReadTagSlow() {
 
   // For the slow path, just do a 64-bit read. Try to optimize for one-byte tags
   // again, since we have now refreshed the buffer.
-  uint64 result = 0;
+  uint64_t result = 0;
   if (!ReadVarint64(&result)) return 0;
-  return static_cast<uint32>(result);
+  return static_cast<uint32_t>(result);
 }
 
-uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {
+uint32_t CodedInputStream::ReadTagFallback(uint32_t first_byte_or_zero) {
   const int buf_size = BufferSize();
   if (buf_size >= kMaxVarintBytes ||
       // Optimization:  We're also safe if the buffer is non-empty and it ends
@@ -539,8 +540,8 @@ uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {
       ++buffer_;
       return 0;
     }
-    uint32 tag;
-    ::std::pair<bool, const uint8*> p =
+    uint32_t tag;
+    ::std::pair<bool, const uint8_t*> p =
         ReadVarint32FromArray(first_byte_or_zero, buffer_, &tag);
     if (!p.first) {
       return 0;
@@ -565,13 +566,13 @@ uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {
   }
 }
 
-bool CodedInputStream::ReadVarint64Slow(uint64* value) {
+bool CodedInputStream::ReadVarint64Slow(uint64_t* value) {
   // Slow path:  This read might cross the end of the buffer, so we
   // need to check and refresh the buffer if and when it does.
 
-  uint64 result = 0;
+  uint64_t result = 0;
   int count = 0;
-  uint32 b;
+  uint32_t b;
 
   do {
     if (count == kMaxVarintBytes) {
@@ -585,7 +586,7 @@ bool CodedInputStream::ReadVarint64Slow(uint64* value) {
       }
     }
     b = *buffer_;
-    result |= static_cast<uint64>(b & 0x7F) << (7 * count);
+    result |= static_cast<uint64_t>(b & 0x7F) << (7 * count);
     Advance(1);
     ++count;
   } while (b & 0x80);
@@ -594,20 +595,20 @@ bool CodedInputStream::ReadVarint64Slow(uint64* value) {
   return true;
 }
 
-std::pair<uint64, bool> CodedInputStream::ReadVarint64Fallback() {
+std::pair<uint64_t, bool> CodedInputStream::ReadVarint64Fallback() {
   if (BufferSize() >= kMaxVarintBytes ||
       // Optimization:  We're also safe if the buffer is non-empty and it ends
       // with a byte that would terminate a varint.
       (buffer_end_ > buffer_ && !(buffer_end_[-1] & 0x80))) {
-    uint64 temp;
-    ::std::pair<bool, const uint8*> p = ReadVarint64FromArray(buffer_, &temp);
+    uint64_t temp;
+    ::std::pair<bool, const uint8_t*> p = ReadVarint64FromArray(buffer_, &temp);
     if (!p.first) {
       return std::make_pair(0, false);
     }
     buffer_ = p.second;
     return std::make_pair(temp, true);
   } else {
-    uint64 temp;
+    uint64_t temp;
     bool success = ReadVarint64Slow(&temp);
     return std::make_pair(temp, success);
   }
@@ -633,7 +634,7 @@ bool CodedInputStream::Refresh() {
   const void* void_buffer;
   int buffer_size;
   if (NextNonEmpty(input_, &void_buffer, &buffer_size)) {
-    buffer_ = reinterpret_cast<const uint8*>(void_buffer);
+    buffer_ = reinterpret_cast<const uint8_t*>(void_buffer);
     buffer_end_ = buffer_ + buffer_size;
     GOOGLE_CHECK_GE(buffer_size, 0);
 
@@ -670,7 +671,7 @@ void EpsCopyOutputStream::EnableAliasing(bool enabled) {
   aliasing_enabled_ = enabled && stream_->AllowsAliasing();
 }
 
-int64 EpsCopyOutputStream::ByteCount(uint8* ptr) const {
+int64_t EpsCopyOutputStream::ByteCount(uint8_t* ptr) const {
   // Calculate the current offset relative to the end of the stream buffer.
   int delta = (end_ - ptr) + (buffer_end_ ? 0 : kSlopBytes);
   return stream_->ByteCount() - delta;
@@ -679,7 +680,7 @@ int64 EpsCopyOutputStream::ByteCount(uint8* ptr) const {
 // Flushes what's written out to the underlying ZeroCopyOutputStream buffers.
 // Returns the size remaining in the buffer and sets buffer_end_ to the start
 // of the remaining buffer, ie. [buffer_end_, buffer_end_ + return value)
-int EpsCopyOutputStream::Flush(uint8* ptr) {
+int EpsCopyOutputStream::Flush(uint8_t* ptr) {
   while (buffer_end_ && ptr > end_) {
     int overrun = ptr - end_;
     GOOGLE_DCHECK(!had_error_);
@@ -701,24 +702,24 @@ int EpsCopyOutputStream::Flush(uint8* ptr) {
   return s;
 }
 
-uint8* EpsCopyOutputStream::Trim(uint8* ptr) {
+uint8_t* EpsCopyOutputStream::Trim(uint8_t* ptr) {
   if (had_error_) return ptr;
   int s = Flush(ptr);
-  if (s) stream_->BackUp(s);
+  stream_->BackUp(s);
   // Reset to initial state (expecting new buffer)
   buffer_end_ = end_ = buffer_;
   return buffer_;
 }
 
 
-uint8* EpsCopyOutputStream::FlushAndResetBuffer(uint8* ptr) {
+uint8_t* EpsCopyOutputStream::FlushAndResetBuffer(uint8_t* ptr) {
   if (had_error_) return buffer_;
   int s = Flush(ptr);
   if (had_error_) return buffer_;
   return SetInitialBuffer(buffer_end_, s);
 }
 
-bool EpsCopyOutputStream::Skip(int count, uint8** pp) {
+bool EpsCopyOutputStream::Skip(int count, uint8_t** pp) {
   if (count < 0) return false;
   if (had_error_) {
     *pp = buffer_;
@@ -737,12 +738,12 @@ bool EpsCopyOutputStream::Skip(int count, uint8** pp) {
       return false;
     }
   }
-  *pp = SetInitialBuffer(static_cast<uint8*>(data) + count, size - count);
+  *pp = SetInitialBuffer(static_cast<uint8_t*>(data) + count, size - count);
   return true;
 }
 
 bool EpsCopyOutputStream::GetDirectBufferPointer(void** data, int* size,
-                                                 uint8** pp) {
+                                                 uint8_t** pp) {
   if (had_error_) {
     *pp = buffer_;
     return false;
@@ -763,8 +764,8 @@ bool EpsCopyOutputStream::GetDirectBufferPointer(void** data, int* size,
   return true;
 }
 
-uint8* EpsCopyOutputStream::GetDirectBufferForNBytesAndAdvance(int size,
-                                                               uint8** pp) {
+uint8_t* EpsCopyOutputStream::GetDirectBufferForNBytesAndAdvance(int size,
+                                                               uint8_t** pp) {
   if (had_error_) {
     *pp = buffer_;
     return nullptr;
@@ -784,13 +785,13 @@ uint8* EpsCopyOutputStream::GetDirectBufferForNBytesAndAdvance(int size,
   }
 }
 
-uint8* EpsCopyOutputStream::Next() {
+uint8_t* EpsCopyOutputStream::Next() {
   GOOGLE_DCHECK(!had_error_);  // NOLINT
   if (PROTOBUF_PREDICT_FALSE(stream_ == nullptr)) return Error();
   if (buffer_end_) {
     // We're in the patch buffer and need to fill up the previous buffer.
     std::memcpy(buffer_end_, buffer_, end_ - buffer_);
-    uint8* ptr;
+    uint8_t* ptr;
     int size;
     do {
       void* data;
@@ -799,7 +800,7 @@ uint8* EpsCopyOutputStream::Next() {
         // able to write.
         return Error();
       }
-      ptr = static_cast<uint8*>(data);
+      ptr = static_cast<uint8_t*>(data);
     } while (size == 0);
     if (PROTOBUF_PREDICT_TRUE(size > kSlopBytes)) {
       std::memcpy(ptr, end_, kSlopBytes);
@@ -822,7 +823,7 @@ uint8* EpsCopyOutputStream::Next() {
   }
 }
 
-uint8* EpsCopyOutputStream::EnsureSpaceFallback(uint8* ptr) {
+uint8_t* EpsCopyOutputStream::EnsureSpaceFallback(uint8_t* ptr) {
   do {
     if (PROTOBUF_PREDICT_FALSE(had_error_)) return buffer_;
     int overrun = ptr - end_;
@@ -834,13 +835,13 @@ uint8* EpsCopyOutputStream::EnsureSpaceFallback(uint8* ptr) {
   return ptr;
 }
 
-uint8* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,
-                                             uint8* ptr) {
+uint8_t* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,
+                                             uint8_t* ptr) {
   int s = GetSize(ptr);
   while (s < size) {
     std::memcpy(ptr, data, s);
     size -= s;
-    data = static_cast<const uint8*>(data) + s;
+    data = static_cast<const uint8_t*>(data) + s;
     ptr = EnsureSpaceFallback(ptr + s);
     s = GetSize(ptr);
   }
@@ -848,8 +849,8 @@ uint8* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,
   return ptr + size;
 }
 
-uint8* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,
-                                            uint8* ptr) {
+uint8_t* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,
+                                            uint8_t* ptr) {
   if (size < GetSize(ptr)
   ) {
     return WriteRaw(data, size, ptr);
@@ -861,13 +862,13 @@ uint8* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,
 }
 
 #ifndef PROTOBUF_LITTLE_ENDIAN
-uint8* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
-                                                   uint8* ptr) {
-  auto p = static_cast<const uint8*>(data);
+uint8_t* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
+                                                   uint8_t* ptr) {
+  auto p = static_cast<const uint8_t*>(data);
   auto end = p + size;
   while (end - p >= kSlopBytes) {
     ptr = EnsureSpace(ptr);
-    uint32 buffer[4];
+    uint32_t buffer[4];
     static_assert(sizeof(buffer) == kSlopBytes, "Buffer must be kSlopBytes");
     std::memcpy(buffer, p, kSlopBytes);
     p += kSlopBytes;
@@ -876,7 +877,7 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
   }
   while (p < end) {
     ptr = EnsureSpace(ptr);
-    uint32 buffer;
+    uint32_t buffer;
     std::memcpy(&buffer, p, 4);
     p += 4;
     ptr = CodedOutputStream::WriteLittleEndian32ToArray(buffer, ptr);
@@ -884,13 +885,13 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian32(const void* data, int size,
   return ptr;
 }
 
-uint8* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
-                                                   uint8* ptr) {
-  auto p = static_cast<const uint8*>(data);
+uint8_t* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
+                                                   uint8_t* ptr) {
+  auto p = static_cast<const uint8_t*>(data);
   auto end = p + size;
   while (end - p >= kSlopBytes) {
     ptr = EnsureSpace(ptr);
-    uint64 buffer[2];
+    uint64_t buffer[2];
     static_assert(sizeof(buffer) == kSlopBytes, "Buffer must be kSlopBytes");
     std::memcpy(buffer, p, kSlopBytes);
     p += kSlopBytes;
@@ -899,7 +900,7 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
   }
   while (p < end) {
     ptr = EnsureSpace(ptr);
-    uint64 buffer;
+    uint64_t buffer;
     std::memcpy(&buffer, p, 8);
     p += 8;
     ptr = CodedOutputStream::WriteLittleEndian64ToArray(buffer, ptr);
@@ -909,19 +910,19 @@ uint8* EpsCopyOutputStream::WriteRawLittleEndian64(const void* data, int size,
 #endif
 
 
-uint8* EpsCopyOutputStream::WriteStringMaybeAliasedOutline(uint32 num,
+uint8_t* EpsCopyOutputStream::WriteStringMaybeAliasedOutline(uint32_t num,
                                                            const std::string& s,
-                                                           uint8* ptr) {
+                                                           uint8_t* ptr) {
   ptr = EnsureSpace(ptr);
-  uint32 size = s.size();
+  uint32_t size = s.size();
   ptr = WriteLengthDelim(num, size, ptr);
   return WriteRawMaybeAliased(s.data(), size, ptr);
 }
 
-uint8* EpsCopyOutputStream::WriteStringOutline(uint32 num, const std::string& s,
-                                               uint8* ptr) {
+uint8_t* EpsCopyOutputStream::WriteStringOutline(uint32_t num, const std::string& s,
+                                               uint8_t* ptr) {
   ptr = EnsureSpace(ptr);
-  uint32 size = s.size();
+  uint32_t size = s.size();
   ptr = WriteLengthDelim(num, size, ptr);
   return WriteRaw(s.data(), size, ptr);
 }
@@ -944,28 +945,28 @@ CodedOutputStream::CodedOutputStream(ZeroCopyOutputStream* stream,
 CodedOutputStream::~CodedOutputStream() { Trim(); }
 
 
-uint8* CodedOutputStream::WriteStringWithSizeToArray(const std::string& str,
-                                                     uint8* target) {
-  GOOGLE_DCHECK_LE(str.size(), kuint32max);
+uint8_t* CodedOutputStream::WriteStringWithSizeToArray(const std::string& str,
+                                                     uint8_t* target) {
+  GOOGLE_DCHECK_LE(str.size(), std::numeric_limits<uint32_t>::max());
   target = WriteVarint32ToArray(str.size(), target);
   return WriteStringToArray(str, target);
 }
 
-uint8* CodedOutputStream::WriteVarint32ToArrayOutOfLineHelper(uint32 value,
-                                                              uint8* target) {
+uint8_t* CodedOutputStream::WriteVarint32ToArrayOutOfLineHelper(uint32_t value,
+                                                              uint8_t* target) {
   GOOGLE_DCHECK_GE(value, 0x80);
-  target[0] |= static_cast<uint8>(0x80);
+  target[0] |= static_cast<uint8_t>(0x80);
   value >>= 7;
-  target[1] = static_cast<uint8>(value);
+  target[1] = static_cast<uint8_t>(value);
   if (value < 0x80) {
     return target + 2;
   }
   target += 2;
   do {
     // Turn on continuation bit in the byte we just wrote.
-    target[-1] |= static_cast<uint8>(0x80);
+    target[-1] |= static_cast<uint8_t>(0x80);
     value >>= 7;
-    *target = static_cast<uint8>(value);
+    *target = static_cast<uint8_t>(value);
     ++target;
   } while (value >= 0x80);
   return target;
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.h
index 1cf0068..079fd64 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/io/coded_stream.h
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/io/coded_stream.h
@@ -75,7 +75,7 @@
 //     return;
 //   }
 //
-//   uint32 size;
+//   uint32_t size;
 //   coded_input->ReadVarint32(&size);
 //
 //   char* text = new char[size + 1];
@@ -116,6 +116,7 @@
 #include <climits>
 #include <cstddef>
 #include <cstring>
+#include <limits>
 #include <string>
 #include <type_traits>
 #include <utility>
@@ -135,6 +136,10 @@
 #include <machine/endian.h>  // __BYTE_ORDER
 #elif defined(__FreeBSD__)
 #include <sys/endian.h>  // __BYTE_ORDER
+#elif (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))
+#include <sys/isa_defs.h>  // __BYTE_ORDER
+#elif defined(_AIX) || defined(__TOS_AIX__)
+#include <sys/machine.h>  // BYTE_ORDER
 #else
 #if !defined(__QNX__)
 #include <endian.h>  // __BYTE_ORDER
@@ -153,6 +158,7 @@
 #include <google/protobuf/stubs/port.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -194,7 +200,7 @@ class PROTOBUF_EXPORT CodedInputStream {
   // Create a CodedInputStream that reads from the given flat array.  This is
   // faster than using an ArrayInputStream.  PushLimit(size) is implied by
   // this constructor.
-  explicit CodedInputStream(const uint8* buffer, int size);
+  explicit CodedInputStream(const uint8_t* buffer, int size);
 
   // Destroy the CodedInputStream and position the underlying
   // ZeroCopyInputStream at the first unread byte.  If an error occurred while
@@ -233,25 +239,25 @@ class PROTOBUF_EXPORT CodedInputStream {
 
 
   // Read a 32-bit little-endian integer.
-  bool ReadLittleEndian32(uint32* value);
+  bool ReadLittleEndian32(uint32_t* value);
   // Read a 64-bit little-endian integer.
-  bool ReadLittleEndian64(uint64* value);
+  bool ReadLittleEndian64(uint64_t* value);
 
   // These methods read from an externally provided buffer. The caller is
   // responsible for ensuring that the buffer has sufficient space.
   // Read a 32-bit little-endian integer.
-  static const uint8* ReadLittleEndian32FromArray(const uint8* buffer,
-                                                  uint32* value);
+  static const uint8_t* ReadLittleEndian32FromArray(const uint8_t* buffer,
+                                                    uint32_t* value);
   // Read a 64-bit little-endian integer.
-  static const uint8* ReadLittleEndian64FromArray(const uint8* buffer,
-                                                  uint64* value);
+  static const uint8_t* ReadLittleEndian64FromArray(const uint8_t* buffer,
+                                                    uint64_t* value);
 
   // Read an unsigned integer with Varint encoding, truncating to 32 bits.
   // Reading a 32-bit value is equivalent to reading a 64-bit one and casting
-  // it to uint32, but may be more efficient.
-  bool ReadVarint32(uint32* value);
+  // it to uint32_t, but may be more efficient.
+  bool ReadVarint32(uint32_t* value);
   // Read an unsigned integer with Varint encoding.
-  bool ReadVarint64(uint64* value);
+  bool ReadVarint64(uint64_t* value);
 
   // Reads a varint off the wire into an "int". This should be used for reading
   // sizes off the wire (sizes of strings, submessages, bytes fields, etc).
@@ -272,11 +278,11 @@ class PROTOBUF_EXPORT CodedInputStream {
   // Always inline because this is only called in one place per parse loop
   // but it is called for every iteration of said loop, so it should be fast.
   // GCC doesn't want to inline this by default.
-  PROTOBUF_ALWAYS_INLINE uint32 ReadTag() {
+  PROTOBUF_ALWAYS_INLINE uint32_t ReadTag() {
     return last_tag_ = ReadTagNoLastTag();
   }
 
-  PROTOBUF_ALWAYS_INLINE uint32 ReadTagNoLastTag();
+  PROTOBUF_ALWAYS_INLINE uint32_t ReadTagNoLastTag();
 
   // This usually a faster alternative to ReadTag() when cutoff is a manifest
   // constant.  It does particularly well for cutoff >= 127.  The first part
@@ -287,14 +293,14 @@ class PROTOBUF_EXPORT CodedInputStream {
   // because that can arise in several ways, and for best performance we want
   // to avoid an extra "is tag == 0?" check here.)
   PROTOBUF_ALWAYS_INLINE
-  std::pair<uint32, bool> ReadTagWithCutoff(uint32 cutoff) {
-    std::pair<uint32, bool> result = ReadTagWithCutoffNoLastTag(cutoff);
+  std::pair<uint32_t, bool> ReadTagWithCutoff(uint32_t cutoff) {
+    std::pair<uint32_t, bool> result = ReadTagWithCutoffNoLastTag(cutoff);
     last_tag_ = result.first;
     return result;
   }
 
   PROTOBUF_ALWAYS_INLINE
-  std::pair<uint32, bool> ReadTagWithCutoffNoLastTag(uint32 cutoff);
+  std::pair<uint32_t, bool> ReadTagWithCutoffNoLastTag(uint32_t cutoff);
 
   // Usually returns true if calling ReadVarint32() now would produce the given
   // value.  Will always return false if ReadVarint32() would not return the
@@ -303,7 +309,7 @@ class PROTOBUF_EXPORT CodedInputStream {
   // parameter.
   // Always inline because this collapses to a small number of instructions
   // when given a constant parameter, but GCC doesn't want to inline by default.
-  PROTOBUF_ALWAYS_INLINE bool ExpectTag(uint32 expected);
+  PROTOBUF_ALWAYS_INLINE bool ExpectTag(uint32_t expected);
 
   // Like above, except this reads from the specified buffer. The caller is
   // responsible for ensuring that the buffer is large enough to read a varint
@@ -313,7 +319,8 @@ class PROTOBUF_EXPORT CodedInputStream {
   // Returns a pointer beyond the expected tag if it was found, or NULL if it
   // was not.
   PROTOBUF_ALWAYS_INLINE
-  static const uint8* ExpectTagFromArray(const uint8* buffer, uint32 expected);
+  static const uint8_t* ExpectTagFromArray(const uint8_t* buffer,
+                                           uint32_t expected);
 
   // Usually returns true if no more bytes can be read.  Always returns false
   // if more bytes can be read.  If ExpectAtEnd() returns true, a subsequent
@@ -332,8 +339,8 @@ class PROTOBUF_EXPORT CodedInputStream {
   // of the enclosing message.  The enclosing message would like to check that
   // tag to make sure it had the right number, so it calls LastTagWas() on
   // return from the embedded parser to check.
-  bool LastTagWas(uint32 expected);
-  void SetLastTag(uint32 tag) { last_tag_ = tag; }
+  bool LastTagWas(uint32_t expected);
+  void SetLastTag(uint32_t tag) { last_tag_ = tag; }
 
   // When parsing message (but NOT a group), this method must be called
   // immediately after MergeFromCodedStream() returns (if it returns true)
@@ -399,13 +406,6 @@ class PROTOBUF_EXPORT CodedInputStream {
   // This is unrelated to PushLimit()/PopLimit().
   void SetTotalBytesLimit(int total_bytes_limit);
 
-  PROTOBUF_DEPRECATED_MSG(
-      "Please use the single parameter version of SetTotalBytesLimit(). The "
-      "second parameter is ignored.")
-  void SetTotalBytesLimit(int total_bytes_limit, int) {
-    SetTotalBytesLimit(total_bytes_limit);
-  }
-
   // The Total Bytes Limit minus the Current Position, or -1 if the total bytes
   // limit is INT_MAX.
   int BytesUntilTotalBytesLimit() const;
@@ -543,8 +543,8 @@ class PROTOBUF_EXPORT CodedInputStream {
  private:
   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CodedInputStream);
 
-  const uint8* buffer_;
-  const uint8* buffer_end_;  // pointer to the end of the buffer.
+  const uint8_t* buffer_;
+  const uint8_t* buffer_end_;  // pointer to the end of the buffer.
   ZeroCopyInputStream* input_;
   int total_bytes_read_;  // total bytes read from input_, including
                           // the current buffer
@@ -554,7 +554,7 @@ class PROTOBUF_EXPORT CodedInputStream {
   int overflow_bytes_;
 
   // LastTagWas() stuff.
-  uint32 last_tag_;  // result of last ReadTag() or ReadTagWithCutoff().
+  uint32_t last_tag_;  // result of last ReadTag() or ReadTagWithCutoff().
 
   // This is set true by ReadTag{Fallback/Slow}() if it is called when exactly
   // at EOF, or by ExpectAtEnd() when it returns true.  This happens when we
@@ -622,22 +622,22 @@ class PROTOBUF_EXPORT CodedInputStream {
   // message crosses multiple buffers.  Note: ReadVarint32Fallback() and
   // ReadVarint64Fallback() are called frequently and generally not inlined, so
   // they have been optimized to avoid "out" parameters.  The former returns -1
-  // if it fails and the uint32 it read otherwise.  The latter has a bool
+  // if it fails and the uint32_t it read otherwise.  The latter has a bool
   // indicating success or failure as part of its return type.
-  int64 ReadVarint32Fallback(uint32 first_byte_or_zero);
+  int64_t ReadVarint32Fallback(uint32_t first_byte_or_zero);
   int ReadVarintSizeAsIntFallback();
-  std::pair<uint64, bool> ReadVarint64Fallback();
-  bool ReadVarint32Slow(uint32* value);
-  bool ReadVarint64Slow(uint64* value);
+  std::pair<uint64_t, bool> ReadVarint64Fallback();
+  bool ReadVarint32Slow(uint32_t* value);
+  bool ReadVarint64Slow(uint64_t* value);
   int ReadVarintSizeAsIntSlow();
-  bool ReadLittleEndian32Fallback(uint32* value);
-  bool ReadLittleEndian64Fallback(uint64* value);
+  bool ReadLittleEndian32Fallback(uint32_t* value);
+  bool ReadLittleEndian64Fallback(uint64_t* value);
 
   // Fallback/slow methods for reading tags. These do not update last_tag_,
   // but will set legitimate_message_end_ if we are at the end of the input
   // stream.
-  uint32 ReadTagFallback(uint32 first_byte_or_zero);
-  uint32 ReadTagSlow();
+  uint32_t ReadTagFallback(uint32_t first_byte_or_zero);
+  uint32_t ReadTagSlow();
   bool ReadStringFallback(std::string* buffer, int size);
 
   // Return the size of the buffer.
@@ -663,7 +663,7 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
 
   // Initialize from a stream.
   EpsCopyOutputStream(ZeroCopyOutputStream* stream, bool deterministic,
-                      uint8** pp)
+                      uint8_t** pp)
       : end_(buffer_),
         stream_(stream),
         is_serialization_deterministic_(deterministic) {
@@ -674,33 +674,33 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
   // pointed to the end of the array. When using this the total size is already
   // known, so no need to maintain the slop region.
   EpsCopyOutputStream(void* data, int size, bool deterministic)
-      : end_(static_cast<uint8*>(data) + size),
+      : end_(static_cast<uint8_t*>(data) + size),
         buffer_end_(nullptr),
         stream_(nullptr),
         is_serialization_deterministic_(deterministic) {}
 
   // Initialize from stream but with the first buffer already given (eager).
   EpsCopyOutputStream(void* data, int size, ZeroCopyOutputStream* stream,
-                      bool deterministic, uint8** pp)
+                      bool deterministic, uint8_t** pp)
       : stream_(stream), is_serialization_deterministic_(deterministic) {
     *pp = SetInitialBuffer(data, size);
   }
 
   // Flush everything that's written into the underlying ZeroCopyOutputStream
   // and trims the underlying stream to the location of ptr.
-  uint8* Trim(uint8* ptr);
+  uint8_t* Trim(uint8_t* ptr);
 
   // After this it's guaranteed you can safely write kSlopBytes to ptr. This
   // will never fail! The underlying stream can produce an error. Use HadError
   // to check for errors.
-  PROTOBUF_MUST_USE_RESULT uint8* EnsureSpace(uint8* ptr) {
+  PROTOBUF_MUST_USE_RESULT uint8_t* EnsureSpace(uint8_t* ptr) {
     if (PROTOBUF_PREDICT_FALSE(ptr >= end_)) {
       return EnsureSpaceFallback(ptr);
     }
     return ptr;
   }
 
-  uint8* WriteRaw(const void* data, int size, uint8* ptr) {
+  uint8_t* WriteRaw(const void* data, int size, uint8_t* ptr) {
     if (PROTOBUF_PREDICT_FALSE(end_ - ptr < size)) {
       return WriteRawFallback(data, size, ptr);
     }
@@ -711,7 +711,7 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
   // aliasing the buffer (ie. not copying the data). The caller is responsible
   // to make sure the buffer is alive for the duration of the
   // ZeroCopyOutputStream.
-  uint8* WriteRawMaybeAliased(const void* data, int size, uint8* ptr) {
+  uint8_t* WriteRawMaybeAliased(const void* data, int size, uint8_t* ptr) {
     if (aliasing_enabled_) {
       return WriteAliasedRaw(data, size, ptr);
     } else {
@@ -720,78 +720,80 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
   }
 
 
-  uint8* WriteStringMaybeAliased(uint32 num, const std::string& s, uint8* ptr) {
+  uint8_t* WriteStringMaybeAliased(uint32_t num, const std::string& s,
+                                   uint8_t* ptr) {
     std::ptrdiff_t size = s.size();
     if (PROTOBUF_PREDICT_FALSE(
             size >= 128 || end_ - ptr + 16 - TagSize(num << 3) - 1 < size)) {
       return WriteStringMaybeAliasedOutline(num, s, ptr);
     }
     ptr = UnsafeVarint((num << 3) | 2, ptr);
-    *ptr++ = static_cast<uint8>(size);
+    *ptr++ = static_cast<uint8_t>(size);
     std::memcpy(ptr, s.data(), size);
     return ptr + size;
   }
-  uint8* WriteBytesMaybeAliased(uint32 num, const std::string& s, uint8* ptr) {
+  uint8_t* WriteBytesMaybeAliased(uint32_t num, const std::string& s,
+                                  uint8_t* ptr) {
     return WriteStringMaybeAliased(num, s, ptr);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteString(uint32 num, const T& s,
-                                            uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteString(uint32_t num, const T& s,
+                                              uint8_t* ptr) {
     std::ptrdiff_t size = s.size();
     if (PROTOBUF_PREDICT_FALSE(
             size >= 128 || end_ - ptr + 16 - TagSize(num << 3) - 1 < size)) {
       return WriteStringOutline(num, s, ptr);
     }
     ptr = UnsafeVarint((num << 3) | 2, ptr);
-    *ptr++ = static_cast<uint8>(size);
+    *ptr++ = static_cast<uint8_t>(size);
     std::memcpy(ptr, s.data(), size);
     return ptr + size;
   }
   template <typename T>
-  uint8* WriteBytes(uint32 num, const T& s, uint8* ptr) {
+  uint8_t* WriteBytes(uint32_t num, const T& s, uint8_t* ptr) {
     return WriteString(num, s, ptr);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteInt32Packed(int num, const T& r, int size,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteInt32Packed(int num, const T& r,
+                                                   int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteUInt32Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteUInt32Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode32);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteSInt32Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteSInt32Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, ZigZagEncode32);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteInt64Packed(int num, const T& r, int size,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteInt64Packed(int num, const T& r,
+                                                   int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteUInt64Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteUInt64Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteSInt64Packed(int num, const T& r, int size,
-                                                  uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteSInt64Packed(int num, const T& r,
+                                                    int size, uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, ZigZagEncode64);
   }
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteEnumPacked(int num, const T& r, int size,
-                                                uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteEnumPacked(int num, const T& r, int size,
+                                                  uint8_t* ptr) {
     return WriteVarintPacked(num, r, size, ptr, Encode64);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteFixedPacked(int num, const T& r,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteFixedPacked(int num, const T& r,
+                                                   uint8_t* ptr) {
     ptr = EnsureSpace(ptr);
     constexpr auto element_size = sizeof(typename T::value_type);
     auto size = r.size() * element_size;
@@ -827,34 +829,35 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
 
   // The number of bytes written to the stream at position ptr, relative to the
   // stream's overall position.
-  int64 ByteCount(uint8* ptr) const;
+  int64_t ByteCount(uint8_t* ptr) const;
 
 
  private:
-  uint8* end_;
-  uint8* buffer_end_ = buffer_;
-  uint8 buffer_[2 * kSlopBytes];
+  uint8_t* end_;
+  uint8_t* buffer_end_ = buffer_;
+  uint8_t buffer_[2 * kSlopBytes];
   ZeroCopyOutputStream* stream_;
   bool had_error_ = false;
   bool aliasing_enabled_ = false;  // See EnableAliasing().
   bool is_serialization_deterministic_;
+  bool skip_check_consistency = false;
 
-  uint8* EnsureSpaceFallback(uint8* ptr);
-  inline uint8* Next();
-  int Flush(uint8* ptr);
-  std::ptrdiff_t GetSize(uint8* ptr) const {
+  uint8_t* EnsureSpaceFallback(uint8_t* ptr);
+  inline uint8_t* Next();
+  int Flush(uint8_t* ptr);
+  std::ptrdiff_t GetSize(uint8_t* ptr) const {
     GOOGLE_DCHECK(ptr <= end_ + kSlopBytes);  // NOLINT
     return end_ + kSlopBytes - ptr;
   }
 
-  uint8* Error() {
+  uint8_t* Error() {
     had_error_ = true;
     // We use the patch buffer to always guarantee space to write to.
     end_ = buffer_ + kSlopBytes;
     return buffer_;
   }
 
-  static constexpr int TagSize(uint32 tag) {
+  static constexpr int TagSize(uint32_t tag) {
     return (tag < (1 << 7))    ? 1
            : (tag < (1 << 14)) ? 2
            : (tag < (1 << 21)) ? 3
@@ -862,28 +865,30 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
                                : 5;
   }
 
-  PROTOBUF_ALWAYS_INLINE uint8* WriteTag(uint32 num, uint32 wt, uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteTag(uint32_t num, uint32_t wt,
+                                           uint8_t* ptr) {
     GOOGLE_DCHECK(ptr < end_);  // NOLINT
     return UnsafeVarint((num << 3) | wt, ptr);
   }
 
-  PROTOBUF_ALWAYS_INLINE uint8* WriteLengthDelim(int num, uint32 size,
-                                                 uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteLengthDelim(int num, uint32_t size,
+                                                   uint8_t* ptr) {
     ptr = WriteTag(num, 2, ptr);
     return UnsafeWriteSize(size, ptr);
   }
 
-  uint8* WriteRawFallback(const void* data, int size, uint8* ptr);
+  uint8_t* WriteRawFallback(const void* data, int size, uint8_t* ptr);
 
-  uint8* WriteAliasedRaw(const void* data, int size, uint8* ptr);
+  uint8_t* WriteAliasedRaw(const void* data, int size, uint8_t* ptr);
 
-  uint8* WriteStringMaybeAliasedOutline(uint32 num, const std::string& s,
-                                        uint8* ptr);
-  uint8* WriteStringOutline(uint32 num, const std::string& s, uint8* ptr);
+  uint8_t* WriteStringMaybeAliasedOutline(uint32_t num, const std::string& s,
+                                          uint8_t* ptr);
+  uint8_t* WriteStringOutline(uint32_t num, const std::string& s, uint8_t* ptr);
 
   template <typename T, typename E>
-  PROTOBUF_ALWAYS_INLINE uint8* WriteVarintPacked(int num, const T& r, int size,
-                                                  uint8* ptr, const E& encode) {
+  PROTOBUF_ALWAYS_INLINE uint8_t* WriteVarintPacked(int num, const T& r,
+                                                    int size, uint8_t* ptr,
+                                                    const E& encode) {
     ptr = EnsureSpace(ptr);
     ptr = WriteLengthDelim(num, size, ptr);
     auto it = r.data();
@@ -895,65 +900,65 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
     return ptr;
   }
 
-  static uint32 Encode32(uint32 v) { return v; }
-  static uint64 Encode64(uint64 v) { return v; }
-  static uint32 ZigZagEncode32(int32 v) {
-    return (static_cast<uint32>(v) << 1) ^ static_cast<uint32>(v >> 31);
+  static uint32_t Encode32(uint32_t v) { return v; }
+  static uint64_t Encode64(uint64_t v) { return v; }
+  static uint32_t ZigZagEncode32(int32_t v) {
+    return (static_cast<uint32_t>(v) << 1) ^ static_cast<uint32_t>(v >> 31);
   }
-  static uint64 ZigZagEncode64(int64 v) {
-    return (static_cast<uint64>(v) << 1) ^ static_cast<uint64>(v >> 63);
+  static uint64_t ZigZagEncode64(int64_t v) {
+    return (static_cast<uint64_t>(v) << 1) ^ static_cast<uint64_t>(v >> 63);
   }
 
   template <typename T>
-  PROTOBUF_ALWAYS_INLINE static uint8* UnsafeVarint(T value, uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE static uint8_t* UnsafeVarint(T value, uint8_t* ptr) {
     static_assert(std::is_unsigned<T>::value,
                   "Varint serialization must be unsigned");
-    ptr[0] = static_cast<uint8>(value);
+    ptr[0] = static_cast<uint8_t>(value);
     if (value < 0x80) {
       return ptr + 1;
     }
     // Turn on continuation bit in the byte we just wrote.
-    ptr[0] |= static_cast<uint8>(0x80);
+    ptr[0] |= static_cast<uint8_t>(0x80);
     value >>= 7;
-    ptr[1] = static_cast<uint8>(value);
+    ptr[1] = static_cast<uint8_t>(value);
     if (value < 0x80) {
       return ptr + 2;
     }
     ptr += 2;
     do {
       // Turn on continuation bit in the byte we just wrote.
-      ptr[-1] |= static_cast<uint8>(0x80);
+      ptr[-1] |= static_cast<uint8_t>(0x80);
       value >>= 7;
-      *ptr = static_cast<uint8>(value);
+      *ptr = static_cast<uint8_t>(value);
       ++ptr;
     } while (value >= 0x80);
     return ptr;
   }
 
-  PROTOBUF_ALWAYS_INLINE static uint8* UnsafeWriteSize(uint32 value,
-                                                       uint8* ptr) {
+  PROTOBUF_ALWAYS_INLINE static uint8_t* UnsafeWriteSize(uint32_t value,
+                                                         uint8_t* ptr) {
     while (PROTOBUF_PREDICT_FALSE(value >= 0x80)) {
-      *ptr = static_cast<uint8>(value | 0x80);
+      *ptr = static_cast<uint8_t>(value | 0x80);
       value >>= 7;
       ++ptr;
     }
-    *ptr++ = static_cast<uint8>(value);
+    *ptr++ = static_cast<uint8_t>(value);
     return ptr;
   }
 
   template <int S>
-  uint8* WriteRawLittleEndian(const void* data, int size, uint8* ptr);
+  uint8_t* WriteRawLittleEndian(const void* data, int size, uint8_t* ptr);
 #ifndef PROTOBUF_LITTLE_ENDIAN
-  uint8* WriteRawLittleEndian32(const void* data, int size, uint8* ptr);
-  uint8* WriteRawLittleEndian64(const void* data, int size, uint8* ptr);
+  uint8_t* WriteRawLittleEndian32(const void* data, int size, uint8_t* ptr);
+  uint8_t* WriteRawLittleEndian64(const void* data, int size, uint8_t* ptr);
 #endif
 
   // These methods are for CodedOutputStream. Ideally they should be private
   // but to match current behavior of CodedOutputStream as close as possible
   // we allow it some functionality.
  public:
-  uint8* SetInitialBuffer(void* data, int size) {
-    auto ptr = static_cast<uint8*>(data);
+  uint8_t* SetInitialBuffer(void* data, int size) {
+    auto ptr = static_cast<uint8_t*>(data);
     if (size > kSlopBytes) {
       end_ = ptr + size - kSlopBytes;
       buffer_end_ = nullptr;
@@ -968,28 +973,28 @@ class PROTOBUF_EXPORT EpsCopyOutputStream {
  private:
   // Needed by CodedOutputStream HadError. HadError needs to flush the patch
   // buffers to ensure there is no error as of yet.
-  uint8* FlushAndResetBuffer(uint8*);
+  uint8_t* FlushAndResetBuffer(uint8_t*);
 
   // The following functions mimic the old CodedOutputStream behavior as close
   // as possible. They flush the current state to the stream, behave as
   // the old CodedOutputStream and then return to normal operation.
-  bool Skip(int count, uint8** pp);
-  bool GetDirectBufferPointer(void** data, int* size, uint8** pp);
-  uint8* GetDirectBufferForNBytesAndAdvance(int size, uint8** pp);
+  bool Skip(int count, uint8_t** pp);
+  bool GetDirectBufferPointer(void** data, int* size, uint8_t** pp);
+  uint8_t* GetDirectBufferForNBytesAndAdvance(int size, uint8_t** pp);
 
   friend class CodedOutputStream;
 };
 
 template <>
-inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<1>(const void* data,
-                                                           int size,
-                                                           uint8* ptr) {
+inline uint8_t* EpsCopyOutputStream::WriteRawLittleEndian<1>(const void* data,
+                                                             int size,
+                                                             uint8_t* ptr) {
   return WriteRaw(data, size, ptr);
 }
 template <>
-inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<4>(const void* data,
-                                                           int size,
-                                                           uint8* ptr) {
+inline uint8_t* EpsCopyOutputStream::WriteRawLittleEndian<4>(const void* data,
+                                                             int size,
+                                                             uint8_t* ptr) {
 #ifdef PROTOBUF_LITTLE_ENDIAN
   return WriteRaw(data, size, ptr);
 #else
@@ -997,9 +1002,9 @@ inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<4>(const void* data,
 #endif
 }
 template <>
-inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<8>(const void* data,
-                                                           int size,
-                                                           uint8* ptr) {
+inline uint8_t* EpsCopyOutputStream::WriteRawLittleEndian<8>(const void* data,
+                                                             int size,
+                                                             uint8_t* ptr) {
 #ifdef PROTOBUF_LITTLE_ENDIAN
   return WriteRaw(data, size, ptr);
 #else
@@ -1035,7 +1040,7 @@ inline uint8* EpsCopyOutputStream::WriteRawLittleEndian<8>(const void* data,
 //                    CodedOutputStream::VarintSize32(strlen(text)) +
 //                    strlen(text);
 //
-//   uint8* buffer =
+//   uint8_t* buffer =
 //       coded_output->GetDirectBufferForNBytesAndAdvance(coded_size);
 //   if (buffer != nullptr) {
 //     // The output stream has enough space in the buffer: write directly to
@@ -1107,7 +1112,7 @@ class PROTOBUF_EXPORT CodedOutputStream {
   // there are not enough bytes available, returns NULL.  The return pointer is
   // invalidated as soon as any other non-const method of CodedOutputStream
   // is called.
-  inline uint8* GetDirectBufferForNBytesAndAdvance(int size) {
+  inline uint8_t* GetDirectBufferForNBytesAndAdvance(int size) {
     return impl_.GetDirectBufferForNBytesAndAdvance(size, &cur_);
   }
 
@@ -1123,72 +1128,80 @@ class PROTOBUF_EXPORT CodedOutputStream {
   // copy loops. Since this gets called by every field with string or bytes
   // type, inlining may lead to a significant amount of code bloat, with only a
   // minor performance gain.
-  static uint8* WriteRawToArray(const void* buffer, int size, uint8* target);
+  static uint8_t* WriteRawToArray(const void* buffer, int size,
+                                  uint8_t* target);
 
   // Equivalent to WriteRaw(str.data(), str.size()).
   void WriteString(const std::string& str);
   // Like WriteString()  but writing directly to the target array.
-  static uint8* WriteStringToArray(const std::string& str, uint8* target);
+  static uint8_t* WriteStringToArray(const std::string& str, uint8_t* target);
   // Write the varint-encoded size of str followed by str.
-  static uint8* WriteStringWithSizeToArray(const std::string& str,
-                                           uint8* target);
+  static uint8_t* WriteStringWithSizeToArray(const std::string& str,
+                                             uint8_t* target);
 
 
   // Write a 32-bit little-endian integer.
-  void WriteLittleEndian32(uint32 value) {
+  void WriteLittleEndian32(uint32_t value) {
     cur_ = impl_.EnsureSpace(cur_);
     SetCur(WriteLittleEndian32ToArray(value, Cur()));
   }
   // Like WriteLittleEndian32()  but writing directly to the target array.
-  static uint8* WriteLittleEndian32ToArray(uint32 value, uint8* target);
+  static uint8_t* WriteLittleEndian32ToArray(uint32_t value, uint8_t* target);
   // Write a 64-bit little-endian integer.
-  void WriteLittleEndian64(uint64 value) {
+  void WriteLittleEndian64(uint64_t value) {
     cur_ = impl_.EnsureSpace(cur_);
     SetCur(WriteLittleEndian64ToArray(value, Cur()));
   }
   // Like WriteLittleEndian64()  but writing directly to the target array.
-  static uint8* WriteLittleEndian64ToArray(uint64 value, uint8* target);
+  static uint8_t* WriteLittleEndian64ToArray(uint64_t value, uint8_t* target);
 
   // Write an unsigned integer with Varint encoding.  Writing a 32-bit value
-  // is equivalent to casting it to uint64 and writing it as a 64-bit value,
+  // is equivalent to casting it to uint64_t and writing it as a 64-bit value,
   // but may be more efficient.
-  void WriteVarint32(uint32 value);
+  void WriteVarint32(uint32_t value);
   // Like WriteVarint32()  but writing directly to the target array.
-  static uint8* WriteVarint32ToArray(uint32 value, uint8* target);
-  // Like WriteVarint32()  but writing directly to the target array, and with the
-  // less common-case paths being out of line rather than inlined.
-  static uint8* WriteVarint32ToArrayOutOfLine(uint32 value, uint8* target);
+  static uint8_t* WriteVarint32ToArray(uint32_t value, uint8_t* target);
+  // Like WriteVarint32()  but writing directly to the target array, and with
+  // the less common-case paths being out of line rather than inlined.
+  static uint8_t* WriteVarint32ToArrayOutOfLine(uint32_t value,
+                                                uint8_t* target);
   // Write an unsigned integer with Varint encoding.
-  void WriteVarint64(uint64 value);
+  void WriteVarint64(uint64_t value);
   // Like WriteVarint64()  but writing directly to the target array.
-  static uint8* WriteVarint64ToArray(uint64 value, uint8* target);
+  static uint8_t* WriteVarint64ToArray(uint64_t value, uint8_t* target);
 
   // Equivalent to WriteVarint32() except when the value is negative,
   // in which case it must be sign-extended to a full 10 bytes.
-  void WriteVarint32SignExtended(int32 value);
+  void WriteVarint32SignExtended(int32_t value);
   // Like WriteVarint32SignExtended()  but writing directly to the target array.
-  static uint8* WriteVarint32SignExtendedToArray(int32 value, uint8* target);
+  static uint8_t* WriteVarint32SignExtendedToArray(int32_t value,
+                                                   uint8_t* target);
 
   // This is identical to WriteVarint32(), but optimized for writing tags.
   // In particular, if the input is a compile-time constant, this method
   // compiles down to a couple instructions.
   // Always inline because otherwise the aforementioned optimization can't work,
   // but GCC by default doesn't want to inline this.
-  void WriteTag(uint32 value);
+  void WriteTag(uint32_t value);
   // Like WriteTag()  but writing directly to the target array.
   PROTOBUF_ALWAYS_INLINE
-  static uint8* WriteTagToArray(uint32 value, uint8* target);
+  static uint8_t* WriteTagToArray(uint32_t value, uint8_t* target);
 
   // Returns the number of bytes needed to encode the given value as a varint.
-  static size_t VarintSize32(uint32 value);
+  static size_t VarintSize32(uint32_t value);
   // Returns the number of bytes needed to encode the given value as a varint.
-  static size_t VarintSize64(uint64 value);
+  static size_t VarintSize64(uint64_t value);
 
   // If negative, 10 bytes.  Otherwise, same as VarintSize32().
-  static size_t VarintSize32SignExtended(int32 value);
+  static size_t VarintSize32SignExtended(int32_t value);
+
+  // Same as above, plus one.  The additional one comes at no compute cost.
+  static size_t VarintSize32PlusOne(uint32_t value);
+  static size_t VarintSize64PlusOne(uint64_t value);
+  static size_t VarintSize32SignExtendedPlusOne(int32_t value);
 
   // Compile-time equivalent of VarintSize32().
-  template <uint32 Value>
+  template <uint32_t Value>
   struct StaticVarintSize32 {
     static const size_t value = (Value < (1 << 7))    ? 1
                                 : (Value < (1 << 14)) ? 2
@@ -1213,7 +1226,7 @@ class PROTOBUF_EXPORT CodedOutputStream {
   // remains live until all of the data has been consumed from the stream.
   void EnableAliasing(bool enabled) { impl_.EnableAliasing(enabled); }
 
-  // Indicate to the serializer whether the user wants derministic
+  // Indicate to the serializer whether the user wants deterministic
   // serialization. The default when this is not called comes from the global
   // default, controlled by SetDefaultSerializationDeterministic.
   //
@@ -1251,14 +1264,17 @@ class PROTOBUF_EXPORT CodedOutputStream {
   template <typename Func>
   void Serialize(const Func& func);
 
-  uint8* Cur() const { return cur_; }
-  void SetCur(uint8* ptr) { cur_ = ptr; }
+  uint8_t* Cur() const { return cur_; }
+  void SetCur(uint8_t* ptr) { cur_ = ptr; }
   EpsCopyOutputStream* EpsCopy() { return &impl_; }
 
  private:
+  template <class Stream>
+  void InitEagerly(Stream* stream);
+
   EpsCopyOutputStream impl_;
-  uint8* cur_;
-  int64 start_count_;
+  uint8_t* cur_;
+  int64_t start_count_;
   static std::atomic<bool> default_serialization_deterministic_;
 
   // See above.  Other projects may use "friend" to allow them to call this.
@@ -1273,7 +1289,8 @@ class PROTOBUF_EXPORT CodedOutputStream {
     default_serialization_deterministic_.store(true, std::memory_order_relaxed);
   }
   // REQUIRES: value >= 0x80, and that (value & 7f) has been written to *target.
-  static uint8* WriteVarint32ToArrayOutOfLineHelper(uint32 value, uint8* target);
+  static uint8_t* WriteVarint32ToArrayOutOfLineHelper(uint32_t value,
+                                                      uint8_t* target);
   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CodedOutputStream);
 };
 
@@ -1281,8 +1298,8 @@ class PROTOBUF_EXPORT CodedOutputStream {
 // The vast majority of varints are only one byte.  These inline
 // methods optimize for that case.
 
-inline bool CodedInputStream::ReadVarint32(uint32* value) {
-  uint32 v = 0;
+inline bool CodedInputStream::ReadVarint32(uint32_t* value) {
+  uint32_t v = 0;
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_)) {
     v = *buffer_;
     if (v < 0x80) {
@@ -1291,18 +1308,18 @@ inline bool CodedInputStream::ReadVarint32(uint32* value) {
       return true;
     }
   }
-  int64 result = ReadVarint32Fallback(v);
-  *value = static_cast<uint32>(result);
+  int64_t result = ReadVarint32Fallback(v);
+  *value = static_cast<uint32_t>(result);
   return result >= 0;
 }
 
-inline bool CodedInputStream::ReadVarint64(uint64* value) {
+inline bool CodedInputStream::ReadVarint64(uint64_t* value) {
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_) && *buffer_ < 0x80) {
     *value = *buffer_;
     Advance(1);
     return true;
   }
-  std::pair<uint64, bool> p = ReadVarint64Fallback();
+  std::pair<uint64_t, bool> p = ReadVarint64Fallback();
   *value = p.first;
   return p.second;
 }
@@ -1321,40 +1338,40 @@ inline bool CodedInputStream::ReadVarintSizeAsInt(int* value) {
 }
 
 // static
-inline const uint8* CodedInputStream::ReadLittleEndian32FromArray(
-    const uint8* buffer, uint32* value) {
+inline const uint8_t* CodedInputStream::ReadLittleEndian32FromArray(
+    const uint8_t* buffer, uint32_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(value, buffer, sizeof(*value));
   return buffer + sizeof(*value);
 #else
-  *value = (static_cast<uint32>(buffer[0])) |
-           (static_cast<uint32>(buffer[1]) << 8) |
-           (static_cast<uint32>(buffer[2]) << 16) |
-           (static_cast<uint32>(buffer[3]) << 24);
+  *value = (static_cast<uint32_t>(buffer[0])) |
+           (static_cast<uint32_t>(buffer[1]) << 8) |
+           (static_cast<uint32_t>(buffer[2]) << 16) |
+           (static_cast<uint32_t>(buffer[3]) << 24);
   return buffer + sizeof(*value);
 #endif
 }
 // static
-inline const uint8* CodedInputStream::ReadLittleEndian64FromArray(
-    const uint8* buffer, uint64* value) {
+inline const uint8_t* CodedInputStream::ReadLittleEndian64FromArray(
+    const uint8_t* buffer, uint64_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(value, buffer, sizeof(*value));
   return buffer + sizeof(*value);
 #else
-  uint32 part0 = (static_cast<uint32>(buffer[0])) |
-                 (static_cast<uint32>(buffer[1]) << 8) |
-                 (static_cast<uint32>(buffer[2]) << 16) |
-                 (static_cast<uint32>(buffer[3]) << 24);
-  uint32 part1 = (static_cast<uint32>(buffer[4])) |
-                 (static_cast<uint32>(buffer[5]) << 8) |
-                 (static_cast<uint32>(buffer[6]) << 16) |
-                 (static_cast<uint32>(buffer[7]) << 24);
-  *value = static_cast<uint64>(part0) | (static_cast<uint64>(part1) << 32);
+  uint32_t part0 = (static_cast<uint32_t>(buffer[0])) |
+                   (static_cast<uint32_t>(buffer[1]) << 8) |
+                   (static_cast<uint32_t>(buffer[2]) << 16) |
+                   (static_cast<uint32_t>(buffer[3]) << 24);
+  uint32_t part1 = (static_cast<uint32_t>(buffer[4])) |
+                   (static_cast<uint32_t>(buffer[5]) << 8) |
+                   (static_cast<uint32_t>(buffer[6]) << 16) |
+                   (static_cast<uint32_t>(buffer[7]) << 24);
+  *value = static_cast<uint64_t>(part0) | (static_cast<uint64_t>(part1) << 32);
   return buffer + sizeof(*value);
 #endif
 }
 
-inline bool CodedInputStream::ReadLittleEndian32(uint32* value) {
+inline bool CodedInputStream::ReadLittleEndian32(uint32_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   if (PROTOBUF_PREDICT_TRUE(BufferSize() >= static_cast<int>(sizeof(*value)))) {
     buffer_ = ReadLittleEndian32FromArray(buffer_, value);
@@ -1367,7 +1384,7 @@ inline bool CodedInputStream::ReadLittleEndian32(uint32* value) {
 #endif
 }
 
-inline bool CodedInputStream::ReadLittleEndian64(uint64* value) {
+inline bool CodedInputStream::ReadLittleEndian64(uint64_t* value) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   if (PROTOBUF_PREDICT_TRUE(BufferSize() >= static_cast<int>(sizeof(*value)))) {
     buffer_ = ReadLittleEndian64FromArray(buffer_, value);
@@ -1380,8 +1397,8 @@ inline bool CodedInputStream::ReadLittleEndian64(uint64* value) {
 #endif
 }
 
-inline uint32 CodedInputStream::ReadTagNoLastTag() {
-  uint32 v = 0;
+inline uint32_t CodedInputStream::ReadTagNoLastTag() {
+  uint32_t v = 0;
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_)) {
     v = *buffer_;
     if (v < 0x80) {
@@ -1393,20 +1410,20 @@ inline uint32 CodedInputStream::ReadTagNoLastTag() {
   return v;
 }
 
-inline std::pair<uint32, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
-    uint32 cutoff) {
+inline std::pair<uint32_t, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
+    uint32_t cutoff) {
   // In performance-sensitive code we can expect cutoff to be a compile-time
   // constant, and things like "cutoff >= kMax1ByteVarint" to be evaluated at
   // compile time.
-  uint32 first_byte_or_zero = 0;
+  uint32_t first_byte_or_zero = 0;
   if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_)) {
     // Hot case: buffer_ non_empty, buffer_[0] in [1, 128).
     // TODO(gpike): Is it worth rearranging this? E.g., if the number of fields
     // is large enough then is it better to check for the two-byte case first?
     first_byte_or_zero = buffer_[0];
-    if (static_cast<int8>(buffer_[0]) > 0) {
-      const uint32 kMax1ByteVarint = 0x7f;
-      uint32 tag = buffer_[0];
+    if (static_cast<int8_t>(buffer_[0]) > 0) {
+      const uint32_t kMax1ByteVarint = 0x7f;
+      uint32_t tag = buffer_[0];
       Advance(1);
       return std::make_pair(tag, cutoff >= kMax1ByteVarint || tag <= cutoff);
     }
@@ -1415,8 +1432,8 @@ inline std::pair<uint32, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
     // first byte and the second byte.
     if (cutoff >= 0x80 && PROTOBUF_PREDICT_TRUE(buffer_ + 1 < buffer_end_) &&
         PROTOBUF_PREDICT_TRUE((buffer_[0] & ~buffer_[1]) >= 0x80)) {
-      const uint32 kMax2ByteVarint = (0x7f << 7) + 0x7f;
-      uint32 tag = (1u << 7) * buffer_[1] + (buffer_[0] - 0x80);
+      const uint32_t kMax2ByteVarint = (0x7f << 7) + 0x7f;
+      uint32_t tag = (1u << 7) * buffer_[1] + (buffer_[0] - 0x80);
       Advance(2);
       // It might make sense to test for tag == 0 now, but it is so rare that
       // that we don't bother.  A varint-encoded 0 should be one byte unless
@@ -1429,11 +1446,11 @@ inline std::pair<uint32, bool> CodedInputStream::ReadTagWithCutoffNoLastTag(
     }
   }
   // Slow path
-  const uint32 tag = ReadTagFallback(first_byte_or_zero);
-  return std::make_pair(tag, static_cast<uint32>(tag - 1) < cutoff);
+  const uint32_t tag = ReadTagFallback(first_byte_or_zero);
+  return std::make_pair(tag, static_cast<uint32_t>(tag - 1) < cutoff);
 }
 
-inline bool CodedInputStream::LastTagWas(uint32 expected) {
+inline bool CodedInputStream::LastTagWas(uint32_t expected) {
   return last_tag_ == expected;
 }
 
@@ -1441,7 +1458,7 @@ inline bool CodedInputStream::ConsumedEntireMessage() {
   return legitimate_message_end_;
 }
 
-inline bool CodedInputStream::ExpectTag(uint32 expected) {
+inline bool CodedInputStream::ExpectTag(uint32_t expected) {
   if (expected < (1 << 7)) {
     if (PROTOBUF_PREDICT_TRUE(buffer_ < buffer_end_) &&
         buffer_[0] == expected) {
@@ -1452,8 +1469,8 @@ inline bool CodedInputStream::ExpectTag(uint32 expected) {
     }
   } else if (expected < (1 << 14)) {
     if (PROTOBUF_PREDICT_TRUE(BufferSize() >= 2) &&
-        buffer_[0] == static_cast<uint8>(expected | 0x80) &&
-        buffer_[1] == static_cast<uint8>(expected >> 7)) {
+        buffer_[0] == static_cast<uint8_t>(expected | 0x80) &&
+        buffer_[1] == static_cast<uint8_t>(expected >> 7)) {
       Advance(2);
       return true;
     } else {
@@ -1465,15 +1482,15 @@ inline bool CodedInputStream::ExpectTag(uint32 expected) {
   }
 }
 
-inline const uint8* CodedInputStream::ExpectTagFromArray(const uint8* buffer,
-                                                         uint32 expected) {
+inline const uint8_t* CodedInputStream::ExpectTagFromArray(
+    const uint8_t* buffer, uint32_t expected) {
   if (expected < (1 << 7)) {
     if (buffer[0] == expected) {
       return buffer + 1;
     }
   } else if (expected < (1 << 14)) {
-    if (buffer[0] == static_cast<uint8>(expected | 0x80) &&
-        buffer[1] == static_cast<uint8>(expected >> 7)) {
+    if (buffer[0] == static_cast<uint8_t>(expected | 0x80) &&
+        buffer[1] == static_cast<uint8_t>(expected >> 7)) {
       return buffer + 2;
     }
   }
@@ -1552,7 +1569,7 @@ inline CodedInputStream::CodedInputStream(ZeroCopyInputStream* input)
       last_tag_(0),
       legitimate_message_end_(false),
       aliasing_enabled_(false),
-      current_limit_(kint32max),
+      current_limit_(std::numeric_limits<int32_t>::max()),
       buffer_size_after_limit_(0),
       total_bytes_limit_(kDefaultTotalBytesLimit),
       recursion_budget_(default_recursion_limit_),
@@ -1563,7 +1580,7 @@ inline CodedInputStream::CodedInputStream(ZeroCopyInputStream* input)
   Refresh();
 }
 
-inline CodedInputStream::CodedInputStream(const uint8* buffer, int size)
+inline CodedInputStream::CodedInputStream(const uint8_t* buffer, int size)
     : buffer_(buffer),
       buffer_end_(buffer + size),
       input_(nullptr),
@@ -1599,14 +1616,14 @@ inline bool CodedInputStream::Skip(int count) {
   return SkipFallback(count, original_buffer_size);
 }
 
-inline uint8* CodedOutputStream::WriteVarint32ToArray(uint32 value,
-                                                      uint8* target) {
+inline uint8* CodedOutputStream::WriteVarint32ToArray(uint32_t value,
+                                                      uint8_t* target) {
   return EpsCopyOutputStream::UnsafeVarint(value, target);
 }
 
-inline uint8* CodedOutputStream::WriteVarint32ToArrayOutOfLine(uint32 value,
-                                                               uint8* target) {
-  target[0] = static_cast<uint8>(value);
+inline uint8_t* CodedOutputStream::WriteVarint32ToArrayOutOfLine(
+    uint32_t value, uint8_t* target) {
+  target[0] = static_cast<uint8_t>(value);
   if (value < 0x80) {
     return target + 1;
   } else {
@@ -1614,95 +1631,111 @@ inline uint8* CodedOutputStream::WriteVarint32ToArrayOutOfLine(uint32 value,
   }
 }
 
-inline uint8* CodedOutputStream::WriteVarint64ToArray(uint64 value,
-                                                      uint8* target) {
+inline uint8_t* CodedOutputStream::WriteVarint64ToArray(uint64_t value,
+                                                        uint8_t* target) {
   return EpsCopyOutputStream::UnsafeVarint(value, target);
 }
 
-inline void CodedOutputStream::WriteVarint32SignExtended(int32 value) {
-  WriteVarint64(static_cast<uint64>(value));
+inline void CodedOutputStream::WriteVarint32SignExtended(int32_t value) {
+  WriteVarint64(static_cast<uint64_t>(value));
 }
 
-inline uint8* CodedOutputStream::WriteVarint32SignExtendedToArray(
-    int32 value, uint8* target) {
-  return WriteVarint64ToArray(static_cast<uint64>(value), target);
+inline uint8_t* CodedOutputStream::WriteVarint32SignExtendedToArray(
+    int32_t value, uint8_t* target) {
+  return WriteVarint64ToArray(static_cast<uint64_t>(value), target);
 }
 
-inline uint8* CodedOutputStream::WriteLittleEndian32ToArray(uint32 value,
-                                                            uint8* target) {
+inline uint8_t* CodedOutputStream::WriteLittleEndian32ToArray(uint32_t value,
+                                                              uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(target, &value, sizeof(value));
 #else
-  target[0] = static_cast<uint8>(value);
-  target[1] = static_cast<uint8>(value >> 8);
-  target[2] = static_cast<uint8>(value >> 16);
-  target[3] = static_cast<uint8>(value >> 24);
+  target[0] = static_cast<uint8_t>(value);
+  target[1] = static_cast<uint8_t>(value >> 8);
+  target[2] = static_cast<uint8_t>(value >> 16);
+  target[3] = static_cast<uint8_t>(value >> 24);
 #endif
   return target + sizeof(value);
 }
 
-inline uint8* CodedOutputStream::WriteLittleEndian64ToArray(uint64 value,
-                                                            uint8* target) {
+inline uint8_t* CodedOutputStream::WriteLittleEndian64ToArray(uint64_t value,
+                                                              uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   memcpy(target, &value, sizeof(value));
 #else
-  uint32 part0 = static_cast<uint32>(value);
-  uint32 part1 = static_cast<uint32>(value >> 32);
-
-  target[0] = static_cast<uint8>(part0);
-  target[1] = static_cast<uint8>(part0 >> 8);
-  target[2] = static_cast<uint8>(part0 >> 16);
-  target[3] = static_cast<uint8>(part0 >> 24);
-  target[4] = static_cast<uint8>(part1);
-  target[5] = static_cast<uint8>(part1 >> 8);
-  target[6] = static_cast<uint8>(part1 >> 16);
-  target[7] = static_cast<uint8>(part1 >> 24);
+  uint32_t part0 = static_cast<uint32_t>(value);
+  uint32_t part1 = static_cast<uint32_t>(value >> 32);
+
+  target[0] = static_cast<uint8_t>(part0);
+  target[1] = static_cast<uint8_t>(part0 >> 8);
+  target[2] = static_cast<uint8_t>(part0 >> 16);
+  target[3] = static_cast<uint8_t>(part0 >> 24);
+  target[4] = static_cast<uint8_t>(part1);
+  target[5] = static_cast<uint8_t>(part1 >> 8);
+  target[6] = static_cast<uint8_t>(part1 >> 16);
+  target[7] = static_cast<uint8_t>(part1 >> 24);
 #endif
   return target + sizeof(value);
 }
 
-inline void CodedOutputStream::WriteVarint32(uint32 value) {
+inline void CodedOutputStream::WriteVarint32(uint32_t value) {
   cur_ = impl_.EnsureSpace(cur_);
   SetCur(WriteVarint32ToArray(value, Cur()));
 }
 
-inline void CodedOutputStream::WriteVarint64(uint64 value) {
+inline void CodedOutputStream::WriteVarint64(uint64_t value) {
   cur_ = impl_.EnsureSpace(cur_);
   SetCur(WriteVarint64ToArray(value, Cur()));
 }
 
-inline void CodedOutputStream::WriteTag(uint32 value) { WriteVarint32(value); }
+inline void CodedOutputStream::WriteTag(uint32_t value) {
+  WriteVarint32(value);
+}
 
-inline uint8* CodedOutputStream::WriteTagToArray(uint32 value, uint8* target) {
+inline uint8_t* CodedOutputStream::WriteTagToArray(uint32_t value,
+                                                   uint8_t* target) {
   return WriteVarint32ToArray(value, target);
 }
 
-inline size_t CodedOutputStream::VarintSize32(uint32 value) {
+inline size_t CodedOutputStream::VarintSize32(uint32_t value) {
   // This computes value == 0 ? 1 : floor(log2(value)) / 7 + 1
   // Use an explicit multiplication to implement the divide of
   // a number in the 1..31 range.
   // Explicit OR 0x1 to avoid calling Bits::Log2FloorNonZero(0), which is
   // undefined.
-  uint32 log2value = Bits::Log2FloorNonZero(value | 0x1);
+  uint32_t log2value = Bits::Log2FloorNonZero(value | 0x1);
   return static_cast<size_t>((log2value * 9 + 73) / 64);
 }
 
-inline size_t CodedOutputStream::VarintSize64(uint64 value) {
+inline size_t CodedOutputStream::VarintSize32PlusOne(uint32_t value) {
+  // Same as above, but one more.
+  uint32_t log2value = Bits::Log2FloorNonZero(value | 0x1);
+  return static_cast<size_t>((log2value * 9 + 73 + 64) / 64);
+}
+
+inline size_t CodedOutputStream::VarintSize64(uint64_t value) {
   // This computes value == 0 ? 1 : floor(log2(value)) / 7 + 1
   // Use an explicit multiplication to implement the divide of
   // a number in the 1..63 range.
   // Explicit OR 0x1 to avoid calling Bits::Log2FloorNonZero(0), which is
   // undefined.
-  uint32 log2value = Bits::Log2FloorNonZero64(value | 0x1);
+  uint32_t log2value = Bits::Log2FloorNonZero64(value | 0x1);
   return static_cast<size_t>((log2value * 9 + 73) / 64);
 }
 
-inline size_t CodedOutputStream::VarintSize32SignExtended(int32 value) {
-  if (value < 0) {
-    return 10;  // TODO(kenton):  Make this a symbolic constant.
-  } else {
-    return VarintSize32(static_cast<uint32>(value));
-  }
+inline size_t CodedOutputStream::VarintSize64PlusOne(uint64_t value) {
+  // Same as above, but one more.
+  uint32_t log2value = Bits::Log2FloorNonZero64(value | 0x1);
+  return static_cast<size_t>((log2value * 9 + 73 + 64) / 64);
+}
+
+inline size_t CodedOutputStream::VarintSize32SignExtended(int32_t value) {
+  return VarintSize64(static_cast<uint64_t>(int64_t{value}));
+}
+
+inline size_t CodedOutputStream::VarintSize32SignExtendedPlusOne(
+    int32_t value) {
+  return VarintSize64PlusOne(static_cast<uint64_t>(int64_t{value}));
 }
 
 inline void CodedOutputStream::WriteString(const std::string& str) {
@@ -1714,14 +1747,14 @@ inline void CodedOutputStream::WriteRawMaybeAliased(const void* data,
   cur_ = impl_.WriteRawMaybeAliased(data, size, cur_);
 }
 
-inline uint8* CodedOutputStream::WriteRawToArray(const void* data, int size,
-                                                 uint8* target) {
+inline uint8_t* CodedOutputStream::WriteRawToArray(const void* data, int size,
+                                                   uint8_t* target) {
   memcpy(target, data, size);
   return target + size;
 }
 
-inline uint8* CodedOutputStream::WriteStringToArray(const std::string& str,
-                                                    uint8* target) {
+inline uint8_t* CodedOutputStream::WriteStringToArray(const std::string& str,
+                                                      uint8_t* target) {
   return WriteRawToArray(str.data(), static_cast<int>(str.size()), target);
 }
 
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format.cc
index c30b7ab..daaa670 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format.cc
@@ -41,20 +41,21 @@
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/stubs/common.h>
 #include <google/protobuf/stubs/stringprintf.h>
-#include <google/protobuf/descriptor.pb.h>
-#include <google/protobuf/parse_context.h>
 #include <google/protobuf/io/coded_stream.h>
 #include <google/protobuf/io/zero_copy_stream.h>
 #include <google/protobuf/io/zero_copy_stream_impl.h>
 #include <google/protobuf/descriptor.h>
+#include <google/protobuf/descriptor.pb.h>
 #include <google/protobuf/dynamic_message.h>
 #include <google/protobuf/map_field.h>
 #include <google/protobuf/map_field_inl.h>
 #include <google/protobuf/message.h>
 #include <google/protobuf/message_lite.h>
+#include <google/protobuf/parse_context.h>
 #include <google/protobuf/unknown_field_set.h>
 
 
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 const size_t kMapEntryTagByteSize = 2;
@@ -70,7 +71,7 @@ static size_t MapValueRefDataOnlyByteSize(const FieldDescriptor* field,
 // ===================================================================
 
 bool UnknownFieldSetFieldSkipper::SkipField(io::CodedInputStream* input,
-                                            uint32 tag) {
+                                            uint32_t tag) {
   return WireFormat::SkipField(input, tag, unknown_fields_);
 }
 
@@ -82,7 +83,7 @@ void UnknownFieldSetFieldSkipper::SkipUnknownEnum(int field_number, int value) {
   unknown_fields_->AddVarint(field_number, value);
 }
 
-bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
+bool WireFormat::SkipField(io::CodedInputStream* input, uint32_t tag,
                            UnknownFieldSet* unknown_fields) {
   int number = WireFormatLite::GetTagFieldNumber(tag);
   // Field number 0 is illegal.
@@ -90,21 +91,21 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
 
   switch (WireFormatLite::GetTagWireType(tag)) {
     case WireFormatLite::WIRETYPE_VARINT: {
-      uint64 value;
+      uint64_t value;
       if (!input->ReadVarint64(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddVarint(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddVarint(number, value);
       return true;
     }
     case WireFormatLite::WIRETYPE_FIXED64: {
-      uint64 value;
+      uint64_t value;
       if (!input->ReadLittleEndian64(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddFixed64(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddFixed64(number, value);
       return true;
     }
     case WireFormatLite::WIRETYPE_LENGTH_DELIMITED: {
-      uint32 length;
+      uint32_t length;
       if (!input->ReadVarint32(&length)) return false;
-      if (unknown_fields == NULL) {
+      if (unknown_fields == nullptr) {
         if (!input->Skip(length)) return false;
       } else {
         if (!input->ReadString(unknown_fields->AddLengthDelimited(number),
@@ -116,8 +117,8 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
     }
     case WireFormatLite::WIRETYPE_START_GROUP: {
       if (!input->IncrementRecursionDepth()) return false;
-      if (!SkipMessage(input, (unknown_fields == NULL)
-                                  ? NULL
+      if (!SkipMessage(input, (unknown_fields == nullptr)
+                                  ? nullptr
                                   : unknown_fields->AddGroup(number))) {
         return false;
       }
@@ -134,9 +135,9 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
       return false;
     }
     case WireFormatLite::WIRETYPE_FIXED32: {
-      uint32 value;
+      uint32_t value;
       if (!input->ReadLittleEndian32(&value)) return false;
-      if (unknown_fields != NULL) unknown_fields->AddFixed32(number, value);
+      if (unknown_fields != nullptr) unknown_fields->AddFixed32(number, value);
       return true;
     }
     default: {
@@ -148,7 +149,7 @@ bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,
 bool WireFormat::SkipMessage(io::CodedInputStream* input,
                              UnknownFieldSet* unknown_fields) {
   while (true) {
-    uint32 tag = input->ReadTag();
+    uint32_t tag = input->ReadTag();
     if (tag == 0) {
       // End of input.  This is a valid place to end, so return true.
       return true;
@@ -166,11 +167,11 @@ bool WireFormat::SkipMessage(io::CodedInputStream* input,
 }
 
 bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
-                                                uint32 field_number,
+                                                uint32_t field_number,
                                                 bool (*is_valid)(int),
                                                 UnknownFieldSet* unknown_fields,
                                                 RepeatedField<int>* values) {
-  uint32 length;
+  uint32_t length;
   if (!input->ReadVarint32(&length)) return false;
   io::CodedInputStream::Limit limit = input->PushLimit(length);
   while (input->BytesUntilLimit() > 0) {
@@ -179,7 +180,7 @@ bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
             input, &value)) {
       return false;
     }
-    if (is_valid == NULL || is_valid(value)) {
+    if (is_valid == nullptr || is_valid(value)) {
       values->Add(value);
     } else {
       unknown_fields->AddVarint(field_number, value);
@@ -189,8 +190,8 @@ bool WireFormat::ReadPackedEnumPreserveUnknowns(io::CodedInputStream* input,
   return true;
 }
 
-uint8* WireFormat::InternalSerializeUnknownFieldsToArray(
-    const UnknownFieldSet& unknown_fields, uint8* target,
+uint8_t* WireFormat::InternalSerializeUnknownFieldsToArray(
+    const UnknownFieldSet& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   for (int i = 0; i < unknown_fields.field_count(); i++) {
     const UnknownField& field = unknown_fields.field(i);
@@ -227,8 +228,8 @@ uint8* WireFormat::InternalSerializeUnknownFieldsToArray(
   return target;
 }
 
-uint8* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(
-    const UnknownFieldSet& unknown_fields, uint8* target,
+uint8_t* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(
+    const UnknownFieldSet& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   for (int i = 0; i < unknown_fields.field_count(); i++) {
     const UnknownField& field = unknown_fields.field(i);
@@ -278,12 +279,12 @@ size_t WireFormat::ComputeUnknownFieldsSize(
       case UnknownField::TYPE_FIXED32:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
             field.number(), WireFormatLite::WIRETYPE_FIXED32));
-        size += sizeof(int32);
+        size += sizeof(int32_t);
         break;
       case UnknownField::TYPE_FIXED64:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
             field.number(), WireFormatLite::WIRETYPE_FIXED64));
-        size += sizeof(int64);
+        size += sizeof(int64_t);
         break;
       case UnknownField::TYPE_LENGTH_DELIMITED:
         size += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
@@ -334,7 +335,7 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
   const Reflection* message_reflection = message->GetReflection();
 
   while (true) {
-    uint32 tag = input->ReadTag();
+    uint32_t tag = input->ReadTag();
     if (tag == 0) {
       // End of input.  This is a valid place to end, so return true.
       return true;
@@ -346,15 +347,15 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
       return true;
     }
 
-    const FieldDescriptor* field = NULL;
+    const FieldDescriptor* field = nullptr;
 
-    if (descriptor != NULL) {
+    if (descriptor != nullptr) {
       int field_number = WireFormatLite::GetTagFieldNumber(tag);
       field = descriptor->FindFieldByNumber(field_number);
 
       // If that failed, check if the field is an extension.
-      if (field == NULL && descriptor->IsExtensionNumber(field_number)) {
-        if (input->GetExtensionPool() == NULL) {
+      if (field == nullptr && descriptor->IsExtensionNumber(field_number)) {
+        if (input->GetExtensionPool() == nullptr) {
           field = message_reflection->FindKnownExtensionByNumber(field_number);
         } else {
           field = input->GetExtensionPool()->FindExtensionByNumber(
@@ -364,7 +365,7 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
 
       // If that failed, but we're a MessageSet, and this is the tag for a
       // MessageSet item, then parse that.
-      if (field == NULL && descriptor->options().message_set_wire_format() &&
+      if (field == nullptr && descriptor->options().message_set_wire_format() &&
           tag == WireFormatLite::kMessageSetItemStartTag) {
         if (!ParseAndMergeMessageSetItem(input, message)) {
           return false;
@@ -380,20 +381,20 @@ bool WireFormat::ParseAndMergePartial(io::CodedInputStream* input,
 }
 
 bool WireFormat::SkipMessageSetField(io::CodedInputStream* input,
-                                     uint32 field_number,
+                                     uint32_t field_number,
                                      UnknownFieldSet* unknown_fields) {
-  uint32 length;
+  uint32_t length;
   if (!input->ReadVarint32(&length)) return false;
   return input->ReadString(unknown_fields->AddLengthDelimited(field_number),
                            length);
 }
 
-bool WireFormat::ParseAndMergeMessageSetField(uint32 field_number,
+bool WireFormat::ParseAndMergeMessageSetField(uint32_t field_number,
                                               const FieldDescriptor* field,
                                               Message* message,
                                               io::CodedInputStream* input) {
   const Reflection* message_reflection = message->GetReflection();
-  if (field == NULL) {
+  if (field == nullptr) {
     // We store unknown MessageSet extensions as groups.
     return SkipMessageSetField(
         input, field_number, message_reflection->MutableUnknownFields(message));
@@ -415,14 +416,14 @@ static bool StrictUtf8Check(const FieldDescriptor* field) {
 }
 
 bool WireFormat::ParseAndMergeField(
-    uint32 tag,
-    const FieldDescriptor* field,  // May be NULL for unknown
+    uint32_t tag,
+    const FieldDescriptor* field,  // May be nullptr for unknown
     Message* message, io::CodedInputStream* input) {
   const Reflection* message_reflection = message->GetReflection();
 
   enum { UNKNOWN, NORMAL_FORMAT, PACKED_FORMAT } value_format;
 
-  if (field == NULL) {
+  if (field == nullptr) {
     value_format = UNKNOWN;
   } else if (WireFormatLite::GetTagWireType(tag) ==
              WireTypeForFieldType(field->type())) {
@@ -441,7 +442,7 @@ bool WireFormat::ParseAndMergeField(
     return SkipField(input, tag,
                      message_reflection->MutableUnknownFields(message));
   } else if (value_format == PACKED_FORMAT) {
-    uint32 length;
+    uint32_t length;
     if (!input->ReadVarint32(&length)) return false;
     io::CodedInputStream::Limit limit = input->PushLimit(length);
 
@@ -459,17 +460,17 @@ bool WireFormat::ParseAndMergeField(
     break;                                                                     \
   }
 
-      HANDLE_PACKED_TYPE(INT32, int32, Int32)
-      HANDLE_PACKED_TYPE(INT64, int64, Int64)
-      HANDLE_PACKED_TYPE(SINT32, int32, Int32)
-      HANDLE_PACKED_TYPE(SINT64, int64, Int64)
-      HANDLE_PACKED_TYPE(UINT32, uint32, UInt32)
-      HANDLE_PACKED_TYPE(UINT64, uint64, UInt64)
+      HANDLE_PACKED_TYPE(INT32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(INT64, int64_t, Int64)
+      HANDLE_PACKED_TYPE(SINT32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(SINT64, int64_t, Int64)
+      HANDLE_PACKED_TYPE(UINT32, uint32_t, UInt32)
+      HANDLE_PACKED_TYPE(UINT64, uint64_t, UInt64)
 
-      HANDLE_PACKED_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_PACKED_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_PACKED_TYPE(SFIXED32, int32, Int32)
-      HANDLE_PACKED_TYPE(SFIXED64, int64, Int64)
+      HANDLE_PACKED_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_PACKED_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_PACKED_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_PACKED_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_PACKED_TYPE(FLOAT, float, Float)
       HANDLE_PACKED_TYPE(DOUBLE, double, Double)
@@ -489,12 +490,12 @@ bool WireFormat::ParseAndMergeField(
           } else {
             const EnumValueDescriptor* enum_value =
                 field->enum_type()->FindValueByNumber(value);
-            if (enum_value != NULL) {
+            if (enum_value != nullptr) {
               message_reflection->AddEnum(message, field, enum_value);
             } else {
               // The enum value is not one of the known values.  Add it to the
               // UnknownFieldSet.
-              int64 sign_extended_value = static_cast<int64>(value);
+              int64_t sign_extended_value = static_cast<int64_t>(value);
               message_reflection->MutableUnknownFields(message)->AddVarint(
                   WireFormatLite::GetTagFieldNumber(tag), sign_extended_value);
             }
@@ -532,17 +533,17 @@ bool WireFormat::ParseAndMergeField(
     break;                                                                    \
   }
 
-      HANDLE_TYPE(INT32, int32, Int32)
-      HANDLE_TYPE(INT64, int64, Int64)
-      HANDLE_TYPE(SINT32, int32, Int32)
-      HANDLE_TYPE(SINT64, int64, Int64)
-      HANDLE_TYPE(UINT32, uint32, UInt32)
-      HANDLE_TYPE(UINT64, uint64, UInt64)
+      HANDLE_TYPE(INT32, int32_t, Int32)
+      HANDLE_TYPE(INT64, int64_t, Int64)
+      HANDLE_TYPE(SINT32, int32_t, Int32)
+      HANDLE_TYPE(SINT64, int64_t, Int64)
+      HANDLE_TYPE(UINT32, uint32_t, UInt32)
+      HANDLE_TYPE(UINT64, uint64_t, UInt64)
 
-      HANDLE_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_TYPE(SFIXED32, int32, Int32)
-      HANDLE_TYPE(SFIXED64, int64, Int64)
+      HANDLE_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_TYPE(FLOAT, float, Float)
       HANDLE_TYPE(DOUBLE, double, Double)
@@ -641,8 +642,8 @@ bool WireFormat::ParseAndMergeMessageSetItem(io::CodedInputStream* input,
       return ParseAndMergeMessageSetField(type_id, field, message, input);
     }
 
-    bool SkipField(uint32 tag, io::CodedInputStream* input) {
-      return WireFormat::SkipField(input, tag, NULL);
+    bool SkipField(uint32_t tag, io::CodedInputStream* input) {
+      return WireFormat::SkipField(input, tag, nullptr);
     }
 
     const Reflection* message_reflection;
@@ -657,19 +658,24 @@ struct WireFormat::MessageSetParser {
   const char* _InternalParse(const char* ptr, internal::ParseContext* ctx) {
     // Parse a MessageSetItem
     auto metadata = reflection->MutableInternalMetadata(msg);
+    enum class State { kNoTag, kHasType, kHasPayload, kDone };
+    State state = State::kNoTag;
+
     std::string payload;
-    uint32 type_id = 0;
-    bool payload_read = false;
+    uint32_t type_id = 0;
     while (!ctx->Done(&ptr)) {
       // We use 64 bit tags in order to allow typeid's that span the whole
       // range of 32 bit numbers.
-      uint32 tag = static_cast<uint8>(*ptr++);
+      uint32_t tag = static_cast<uint8_t>(*ptr++);
       if (tag == WireFormatLite::kMessageSetTypeIdTag) {
-        uint64 tmp;
+        uint64_t tmp;
         ptr = ParseBigVarint(ptr, &tmp);
         GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        type_id = tmp;
-        if (payload_read) {
+        if (state == State::kNoTag) {
+          type_id = tmp;
+          state = State::kHasType;
+        } else if (state == State::kHasPayload) {
+          type_id = tmp;
           const FieldDescriptor* field;
           if (ctx->data().pool == nullptr) {
             field = reflection->FindKnownExtensionByNumber(type_id);
@@ -696,17 +702,17 @@ struct WireFormat::MessageSetParser {
             GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
                                            tmp_ctx.EndedAtLimit());
           }
-          type_id = 0;
+          state = State::kDone;
         }
         continue;
       } else if (tag == WireFormatLite::kMessageSetMessageTag) {
-        if (type_id == 0) {
-          int32 size = ReadSize(&ptr);
+        if (state == State::kNoTag) {
+          int32_t size = ReadSize(&ptr);
           GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
           ptr = ctx->ReadString(ptr, size, &payload);
           GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-          payload_read = true;
-        } else {
+          state = State::kHasPayload;
+        } else if (state == State::kHasType) {
           // We're now parsing the payload
           const FieldDescriptor* field = nullptr;
           if (descriptor->IsExtensionNumber(type_id)) {
@@ -718,9 +724,14 @@ struct WireFormat::MessageSetParser {
             }
           }
           ptr = WireFormat::_InternalParseAndMergeField(
-              msg, ptr, ctx, static_cast<uint64>(type_id) * 8 + 2, reflection,
+              msg, ptr, ctx, static_cast<uint64_t>(type_id) * 8 + 2, reflection,
               field);
-          type_id = 0;
+          state = State::kDone;
+        } else {
+          int32_t size = ReadSize(&ptr);
+          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+          ptr = ctx->Skip(ptr, size);
+          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
         }
       } else {
         // An unknown field in MessageSetItem.
@@ -740,7 +751,7 @@ struct WireFormat::MessageSetParser {
 
   const char* ParseMessageSet(const char* ptr, internal::ParseContext* ctx) {
     while (!ctx->Done(&ptr)) {
-      uint32 tag;
+      uint32_t tag;
       ptr = ReadTag(ptr, &tag);
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr)) return nullptr;
       if (tag == 0 || (tag & 7) == WireFormatLite::WIRETYPE_END_GROUP) {
@@ -786,7 +797,7 @@ const char* WireFormat::_InternalParse(Message* msg, const char* ptr,
     return message_set.ParseMessageSet(ptr, ctx);
   }
   while (!ctx->Done(&ptr)) {
-    uint32 tag;
+    uint32_t tag;
     ptr = ReadTag(ptr, &tag);
     if (PROTOBUF_PREDICT_FALSE(ptr == nullptr)) return nullptr;
     if (tag == 0 || (tag & 7) == WireFormatLite::WIRETYPE_END_GROUP) {
@@ -815,7 +826,7 @@ const char* WireFormat::_InternalParse(Message* msg, const char* ptr,
 }
 
 const char* WireFormat::_InternalParseAndMergeField(
-    Message* msg, const char* ptr, internal::ParseContext* ctx, uint64 tag,
+    Message* msg, const char* ptr, internal::ParseContext* ctx, uint64_t tag,
     const Reflection* reflection, const FieldDescriptor* field) {
   if (field == nullptr) {
     // unknown field set parser takes 64bit tags, because message set type ids
@@ -836,17 +847,17 @@ const char* WireFormat::_InternalParseAndMergeField(
     return ptr;                                                             \
   }
 
-        HANDLE_PACKED_TYPE(INT32, int32, Int32)
-        HANDLE_PACKED_TYPE(INT64, int64, Int64)
-        HANDLE_PACKED_TYPE(SINT32, int32, SInt32)
-        HANDLE_PACKED_TYPE(SINT64, int64, SInt64)
-        HANDLE_PACKED_TYPE(UINT32, uint32, UInt32)
-        HANDLE_PACKED_TYPE(UINT64, uint64, UInt64)
+        HANDLE_PACKED_TYPE(INT32, int32_t, Int32)
+        HANDLE_PACKED_TYPE(INT64, int64_t, Int64)
+        HANDLE_PACKED_TYPE(SINT32, int32_t, SInt32)
+        HANDLE_PACKED_TYPE(SINT64, int64_t, SInt64)
+        HANDLE_PACKED_TYPE(UINT32, uint32_t, UInt32)
+        HANDLE_PACKED_TYPE(UINT64, uint64_t, UInt64)
 
-        HANDLE_PACKED_TYPE(FIXED32, uint32, Fixed32)
-        HANDLE_PACKED_TYPE(FIXED64, uint64, Fixed64)
-        HANDLE_PACKED_TYPE(SFIXED32, int32, SFixed32)
-        HANDLE_PACKED_TYPE(SFIXED64, int64, SFixed64)
+        HANDLE_PACKED_TYPE(FIXED32, uint32_t, Fixed32)
+        HANDLE_PACKED_TYPE(FIXED64, uint64_t, Fixed64)
+        HANDLE_PACKED_TYPE(SFIXED32, int32_t, SFixed32)
+        HANDLE_PACKED_TYPE(SFIXED64, int64_t, SFixed64)
 
         HANDLE_PACKED_TYPE(FLOAT, float, Float)
         HANDLE_PACKED_TYPE(DOUBLE, double, Double)
@@ -863,7 +874,7 @@ const char* WireFormat::_InternalParseAndMergeField(
             ptr = internal::PackedEnumParser(rep_enum, ptr, ctx);
           } else {
             return ctx->ReadPackedVarint(
-                ptr, [rep_enum, field, reflection, msg](uint64 val) {
+                ptr, [rep_enum, field, reflection, msg](uint64_t val) {
                   if (field->enum_type()->FindValueByNumber(val) != nullptr) {
                     rep_enum->Add(val);
                   } else {
@@ -906,14 +917,14 @@ const char* WireFormat::_InternalParseAndMergeField(
     return ptr;                                           \
   }
 
-    HANDLE_TYPE(BOOL, uint64, Bool)
-    HANDLE_TYPE(INT32, uint32, Int32)
-    HANDLE_TYPE(INT64, uint64, Int64)
-    HANDLE_TYPE(UINT32, uint32, UInt32)
-    HANDLE_TYPE(UINT64, uint64, UInt64)
+    HANDLE_TYPE(BOOL, uint64_t, Bool)
+    HANDLE_TYPE(INT32, uint32_t, Int32)
+    HANDLE_TYPE(INT64, uint64_t, Int64)
+    HANDLE_TYPE(UINT32, uint32_t, UInt32)
+    HANDLE_TYPE(UINT64, uint64_t, UInt64)
 
     case FieldDescriptor::TYPE_SINT32: {
-      int32 value = ReadVarintZigZag32(&ptr);
+      int32_t value = ReadVarintZigZag32(&ptr);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
         reflection->AddInt32(msg, field, value);
@@ -923,7 +934,7 @@ const char* WireFormat::_InternalParseAndMergeField(
       return ptr;
     }
     case FieldDescriptor::TYPE_SINT64: {
-      int64 value = ReadVarintZigZag64(&ptr);
+      int64_t value = ReadVarintZigZag64(&ptr);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
         reflection->AddInt64(msg, field, value);
@@ -946,10 +957,10 @@ const char* WireFormat::_InternalParseAndMergeField(
     return ptr;                                           \
   }
 
-      HANDLE_TYPE(FIXED32, uint32, UInt32)
-      HANDLE_TYPE(FIXED64, uint64, UInt64)
-      HANDLE_TYPE(SFIXED32, int32, Int32)
-      HANDLE_TYPE(SFIXED64, int64, Int64)
+      HANDLE_TYPE(FIXED32, uint32_t, UInt32)
+      HANDLE_TYPE(FIXED64, uint64_t, UInt64)
+      HANDLE_TYPE(SFIXED32, int32_t, Int32)
+      HANDLE_TYPE(SFIXED64, int64_t, Int64)
 
       HANDLE_TYPE(FLOAT, float, Float)
       HANDLE_TYPE(DOUBLE, double, Double)
@@ -957,7 +968,7 @@ const char* WireFormat::_InternalParseAndMergeField(
 #undef HANDLE_TYPE
 
     case FieldDescriptor::TYPE_ENUM: {
-      uint32 value;
+      uint32_t value;
       ptr = VarintParse(ptr, &value);
       if (ptr == nullptr) return nullptr;
       if (field->is_repeated()) {
@@ -992,9 +1003,9 @@ const char* WireFormat::_InternalParseAndMergeField(
         }
       }
       if (field->is_repeated()) {
-        reflection->AddString(msg, field, value);
+        reflection->AddString(msg, field, std::move(value));
       } else {
-        reflection->SetString(msg, field, value);
+        reflection->SetString(msg, field, std::move(value));
       }
       return ptr;
     }
@@ -1030,8 +1041,8 @@ const char* WireFormat::_InternalParseAndMergeField(
 
 // ===================================================================
 
-uint8* WireFormat::_InternalSerialize(const Message& message, uint8* target,
-                                      io::EpsCopyOutputStream* stream) {
+uint8_t* WireFormat::_InternalSerialize(const Message& message, uint8_t* target,
+                                        io::EpsCopyOutputStream* stream) {
   const Descriptor* descriptor = message.GetDescriptor();
   const Reflection* message_reflection = message.GetReflection();
 
@@ -1059,9 +1070,9 @@ uint8* WireFormat::_InternalSerialize(const Message& message, uint8* target,
   }
 }
 
-uint8* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
-                                      const MapKey& value, uint8* target,
-                                      io::EpsCopyOutputStream* stream) {
+uint8_t* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
+                                        const MapKey& value, uint8_t* target,
+                                        io::EpsCopyOutputStream* stream) {
   target = stream->EnsureSpace(target);
   switch (field->type()) {
     case FieldDescriptor::TYPE_DOUBLE:
@@ -1096,9 +1107,9 @@ uint8* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,
   return target;
 }
 
-static uint8* SerializeMapValueRefWithCachedSizes(
-    const FieldDescriptor* field, const MapValueConstRef& value, uint8* target,
-    io::EpsCopyOutputStream* stream) {
+static uint8_t* SerializeMapValueRefWithCachedSizes(
+    const FieldDescriptor* field, const MapValueConstRef& value,
+    uint8_t* target, io::EpsCopyOutputStream* stream) {
   target = stream->EnsureSpace(target);
   switch (field->type()) {
 #define CASE_TYPE(FieldType, CamelFieldType, CamelCppType)   \
@@ -1180,11 +1191,11 @@ class MapKeySorter {
   };
 };
 
-static uint8* InternalSerializeMapEntry(const FieldDescriptor* field,
-                                        const MapKey& key,
-                                        const MapValueConstRef& value,
-                                        uint8* target,
-                                        io::EpsCopyOutputStream* stream) {
+static uint8_t* InternalSerializeMapEntry(const FieldDescriptor* field,
+                                          const MapKey& key,
+                                          const MapValueConstRef& value,
+                                          uint8_t* target,
+                                          io::EpsCopyOutputStream* stream) {
   const FieldDescriptor* key_field = field->message_type()->field(0);
   const FieldDescriptor* value_field = field->message_type()->field(1);
 
@@ -1201,9 +1212,10 @@ static uint8* InternalSerializeMapEntry(const FieldDescriptor* field,
   return target;
 }
 
-uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
-                                          const Message& message, uint8* target,
-                                          io::EpsCopyOutputStream* stream) {
+uint8_t* WireFormat::InternalSerializeField(const FieldDescriptor* field,
+                                            const Message& message,
+                                            uint8_t* target,
+                                            io::EpsCopyOutputStream* stream) {
   const Reflection* message_reflection = message.GetReflection();
 
   if (field->is_extension() &&
@@ -1286,12 +1298,12 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     break;                                                                     \
   }
 
-      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)
-      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)
-      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)
-      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(INT32, int32_t, Int32, Int32)
+      HANDLE_PRIMITIVE_TYPE(INT64, int64_t, Int64, Int64)
+      HANDLE_PRIMITIVE_TYPE(SINT32, int32_t, SInt32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SINT64, int64_t, SInt64, Int64)
+      HANDLE_PRIMITIVE_TYPE(UINT32, uint32_t, UInt32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(UINT64, uint64_t, UInt64, UInt64)
       HANDLE_PRIMITIVE_TYPE(ENUM, int, Enum, Enum)
 
 #undef HANDLE_PRIMITIVE_TYPE
@@ -1303,10 +1315,10 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     break;                                                                     \
   }
 
-      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)
-      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)
+      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32_t, Fixed32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64_t, Fixed64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32_t, SFixed32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64_t, SFixed64, Int64)
 
       HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)
       HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)
@@ -1319,6 +1331,16 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     return target;
   }
 
+  auto get_message_from_field = [&message, &map_entries, message_reflection](
+                                    const FieldDescriptor* field, int j) {
+    if (!field->is_repeated()) {
+      return &message_reflection->GetMessage(message, field);
+    }
+    if (!map_entries.empty()) {
+      return map_entries[j];
+    }
+    return &message_reflection->GetRepeatedMessage(message, field, j);
+  };
   for (int j = 0; j < count; j++) {
     target = stream->EnsureSpace(target);
     switch (field->type()) {
@@ -1334,17 +1356,17 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
     break;                                                                    \
   }
 
-      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)
-      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)
-      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)
-      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(INT32, int32_t, Int32, Int32)
+      HANDLE_PRIMITIVE_TYPE(INT64, int64_t, Int64, Int64)
+      HANDLE_PRIMITIVE_TYPE(SINT32, int32_t, SInt32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SINT64, int64_t, SInt64, Int64)
+      HANDLE_PRIMITIVE_TYPE(UINT32, uint32_t, UInt32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(UINT64, uint64_t, UInt64, UInt64)
 
-      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)
-      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)
-      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)
-      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)
+      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32_t, Fixed32, UInt32)
+      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64_t, Fixed64, UInt64)
+      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32_t, SFixed32, Int32)
+      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64_t, SFixed64, Int64)
 
       HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)
       HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)
@@ -1418,8 +1440,8 @@ uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,
   return target;
 }
 
-uint8* WireFormat::InternalSerializeMessageSetItem(
-    const FieldDescriptor* field, const Message& message, uint8* target,
+uint8_t* WireFormat::InternalSerializeMessageSetItem(
+    const FieldDescriptor* field, const Message& message, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   const Reflection* message_reflection = message.GetReflection();
 
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_lite.h protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_lite.h
index c1abaf1..e35c891 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_lite.h
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_lite.h
@@ -40,16 +40,17 @@
 #ifndef GOOGLE_PROTOBUF_WIRE_FORMAT_LITE_H__
 #define GOOGLE_PROTOBUF_WIRE_FORMAT_LITE_H__
 
+
 #include <string>
 
 #include <google/protobuf/stubs/common.h>
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/port.h>
+#include <google/protobuf/stubs/casts.h>
 #include <google/protobuf/arenastring.h>
 #include <google/protobuf/message_lite.h>
-#include <google/protobuf/port.h>
 #include <google/protobuf/repeated_field.h>
-#include <google/protobuf/stubs/casts.h>
 
 // Do UTF-8 validation on string type in Debug build only
 #ifndef NDEBUG
@@ -66,6 +67,8 @@
 // #pragma pop_macro("TYPE_BOOL")
 #undef TYPE_BOOL
 
+
+// Must be included last.
 #include <google/protobuf/port_def.inc>
 
 namespace google {
@@ -157,16 +160,16 @@ class PROTOBUF_EXPORT WireFormatLite {
   // Number of bits in a tag which identify the wire type.
   static constexpr int kTagTypeBits = 3;
   // Mask for those bits.
-  static constexpr uint32 kTagTypeMask = (1 << kTagTypeBits) - 1;
+  static constexpr uint32_t kTagTypeMask = (1 << kTagTypeBits) - 1;
 
   // Helper functions for encoding and decoding tags.  (Inlined below and in
   // _inl.h)
   //
   // This is different from MakeTag(field->number(), field->type()) in the
   // case of packed repeated fields.
-  constexpr static uint32 MakeTag(int field_number, WireType type);
-  static WireType GetTagWireType(uint32 tag);
-  static int GetTagFieldNumber(uint32 tag);
+  constexpr static uint32_t MakeTag(int field_number, WireType type);
+  static WireType GetTagWireType(uint32_t tag);
+  static int GetTagFieldNumber(uint32_t tag);
 
   // Compute the byte size of a tag.  For groups, this includes both the start
   // and end tags.
@@ -177,12 +180,12 @@ class PROTOBUF_EXPORT WireFormatLite {
   // positioned immediately after the tag.  Skipped values are simply
   // discarded, not recorded anywhere.  See WireFormat::SkipField() for a
   // version that records to an UnknownFieldSet.
-  static bool SkipField(io::CodedInputStream* input, uint32 tag);
+  static bool SkipField(io::CodedInputStream* input, uint32_t tag);
 
   // Skips a field value with the given tag.  The input should start
   // positioned immediately after the tag. Skipped values are recorded to a
   // CodedOutputStream.
-  static bool SkipField(io::CodedInputStream* input, uint32 tag,
+  static bool SkipField(io::CodedInputStream* input, uint32_t tag,
                         io::CodedOutputStream* output);
 
   // Reads and ignores a message from the input.  Skipped values are simply
@@ -200,7 +203,7 @@ class PROTOBUF_EXPORT WireFormatLite {
   // as a switch case or a template input.  WireFormatLite::MakeTag() is more
   // type-safe, though, so prefer it if possible.
 #define GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(FIELD_NUMBER, TYPE) \
-  static_cast<uint32>((static_cast<uint32>(FIELD_NUMBER) << 3) | (TYPE))
+  static_cast<uint32_t>((static_cast<uint32_t>(FIELD_NUMBER) << 3) | (TYPE))
 
   // These are the tags for the old MessageSet format, which was defined as:
   //   message MessageSet {
@@ -227,10 +230,10 @@ class PROTOBUF_EXPORT WireFormatLite {
   // Helper functions for converting between floats/doubles and IEEE-754
   // uint32s/uint64s so that they can be written.  (Assumes your platform
   // uses IEEE-754 floats.)
-  static uint32 EncodeFloat(float value);
-  static float DecodeFloat(uint32 value);
-  static uint64 EncodeDouble(double value);
-  static double DecodeDouble(uint64 value);
+  static uint32_t EncodeFloat(float value);
+  static float DecodeFloat(uint32_t value);
+  static uint64_t EncodeDouble(double value);
+  static double DecodeDouble(uint64_t value);
 
   // Helper functions for mapping signed integers to unsigned integers in
   // such a way that numbers with small magnitudes will encode to smaller
@@ -238,10 +241,10 @@ class PROTOBUF_EXPORT WireFormatLite {
   // number and varint-encode it, it will always take 10 bytes, defeating
   // the purpose of varint.  So, for the "sint32" and "sint64" field types,
   // we ZigZag-encode the values.
-  static uint32 ZigZagEncode32(int32 n);
-  static int32 ZigZagDecode32(uint32 n);
-  static uint64 ZigZagEncode64(int64 n);
-  static int64 ZigZagDecode64(uint64 n);
+  static uint32_t ZigZagEncode32(int32_t n);
+  static int32_t ZigZagDecode32(uint32_t n);
+  static uint64_t ZigZagEncode64(int64_t n);
+  static int64_t ZigZagDecode64(uint64_t n);
 
   // =================================================================
   // Methods for reading/writing individual field.
@@ -261,13 +264,13 @@ class PROTOBUF_EXPORT WireFormatLite {
   // protocol compiler.
   template <typename CType, enum FieldType DeclaredType>
   PROTOBUF_NDEBUG_INLINE static bool ReadRepeatedPrimitive(
-      int tag_size, uint32 tag, io::CodedInputStream* input,
+      int tag_size, uint32_t tag, io::CodedInputStream* input,
       RepeatedField<CType>* value);
 
   // Identical to ReadRepeatedPrimitive, except will not inline the
   // implementation.
   template <typename CType, enum FieldType DeclaredType>
-  static bool ReadRepeatedPrimitiveNoInline(int tag_size, uint32 tag,
+  static bool ReadRepeatedPrimitiveNoInline(int tag_size, uint32_t tag,
                                             io::CodedInputStream* input,
                                             RepeatedField<CType>* value);
 
@@ -277,8 +280,8 @@ class PROTOBUF_EXPORT WireFormatLite {
   // This is only implemented for the types with fixed wire size, e.g.
   // float, double, and the (s)fixed* types.
   template <typename CType, enum FieldType DeclaredType>
-  PROTOBUF_NDEBUG_INLINE static const uint8* ReadPrimitiveFromArray(
-      const uint8* buffer, CType* value);
+  PROTOBUF_NDEBUG_INLINE static const uint8_t* ReadPrimitiveFromArray(
+      const uint8_t* buffer, CType* value);
 
   // Reads a primitive packed field.
   //
@@ -293,14 +296,15 @@ class PROTOBUF_EXPORT WireFormatLite {
   static bool ReadPackedPrimitiveNoInline(io::CodedInputStream* input,
                                           RepeatedField<CType>* value);
 
-  // Read a packed enum field. If the is_valid function is not NULL, values for
-  // which is_valid(value) returns false are silently dropped.
+  // Read a packed enum field. If the is_valid function is not nullptr, values
+  // for which is_valid(value) returns false are silently dropped.
   static bool ReadPackedEnumNoInline(io::CodedInputStream* input,
                                      bool (*is_valid)(int),
                                      RepeatedField<int>* values);
 
-  // Read a packed enum field. If the is_valid function is not NULL, values for
-  // which is_valid(value) returns false are appended to unknown_fields_stream.
+  // Read a packed enum field. If the is_valid function is not nullptr, values
+  // for which is_valid(value) returns false are appended to
+  // unknown_fields_stream.
   static bool ReadPackedEnumPreserveUnknowns(
       io::CodedInputStream* input, int field_number, bool (*is_valid)(int),
       io::CodedOutputStream* unknown_fields_stream, RepeatedField<int>* values);
@@ -350,25 +354,25 @@ class PROTOBUF_EXPORT WireFormatLite {
 
   // Write fields, without tags.
   PROTOBUF_NDEBUG_INLINE static void WriteInt32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteInt64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteUInt32NoTag(
-      uint32 value, io::CodedOutputStream* output);
+      uint32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteUInt64NoTag(
-      uint64 value, io::CodedOutputStream* output);
+      uint64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSInt32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSInt64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFixed32NoTag(
-      uint32 value, io::CodedOutputStream* output);
+      uint32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFixed64NoTag(
-      uint64 value, io::CodedOutputStream* output);
+      uint64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSFixed32NoTag(
-      int32 value, io::CodedOutputStream* output);
+      int32_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteSFixed64NoTag(
-      int64 value, io::CodedOutputStream* output);
+      int64_t value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteFloatNoTag(
       float value, io::CodedOutputStream* output);
   PROTOBUF_NDEBUG_INLINE static void WriteDoubleNoTag(
@@ -383,37 +387,37 @@ class PROTOBUF_EXPORT WireFormatLite {
                               io::CodedOutputStream* output);
   static void WriteDoubleArray(const double* a, int n,
                                io::CodedOutputStream* output);
-  static void WriteFixed32Array(const uint32* a, int n,
+  static void WriteFixed32Array(const uint32_t* a, int n,
                                 io::CodedOutputStream* output);
-  static void WriteFixed64Array(const uint64* a, int n,
+  static void WriteFixed64Array(const uint64_t* a, int n,
                                 io::CodedOutputStream* output);
-  static void WriteSFixed32Array(const int32* a, int n,
+  static void WriteSFixed32Array(const int32_t* a, int n,
                                  io::CodedOutputStream* output);
-  static void WriteSFixed64Array(const int64* a, int n,
+  static void WriteSFixed64Array(const int64_t* a, int n,
                                  io::CodedOutputStream* output);
   static void WriteBoolArray(const bool* a, int n,
                              io::CodedOutputStream* output);
 
   // Write fields, including tags.
-  static void WriteInt32(int field_number, int32 value,
+  static void WriteInt32(int field_number, int32_t value,
                          io::CodedOutputStream* output);
-  static void WriteInt64(int field_number, int64 value,
+  static void WriteInt64(int field_number, int64_t value,
                          io::CodedOutputStream* output);
-  static void WriteUInt32(int field_number, uint32 value,
+  static void WriteUInt32(int field_number, uint32_t value,
                           io::CodedOutputStream* output);
-  static void WriteUInt64(int field_number, uint64 value,
+  static void WriteUInt64(int field_number, uint64_t value,
                           io::CodedOutputStream* output);
-  static void WriteSInt32(int field_number, int32 value,
+  static void WriteSInt32(int field_number, int32_t value,
                           io::CodedOutputStream* output);
-  static void WriteSInt64(int field_number, int64 value,
+  static void WriteSInt64(int field_number, int64_t value,
                           io::CodedOutputStream* output);
-  static void WriteFixed32(int field_number, uint32 value,
+  static void WriteFixed32(int field_number, uint32_t value,
                            io::CodedOutputStream* output);
-  static void WriteFixed64(int field_number, uint64 value,
+  static void WriteFixed64(int field_number, uint64_t value,
                            io::CodedOutputStream* output);
-  static void WriteSFixed32(int field_number, int32 value,
+  static void WriteSFixed32(int field_number, int32_t value,
                             io::CodedOutputStream* output);
-  static void WriteSFixed64(int field_number, int64 value,
+  static void WriteSFixed64(int field_number, int64_t value,
                             io::CodedOutputStream* output);
   static void WriteFloat(int field_number, float value,
                          io::CodedOutputStream* output);
@@ -459,161 +463,161 @@ class PROTOBUF_EXPORT WireFormatLite {
                                            io::CodedOutputStream* output);
 
   // Like above, but use only *ToArray methods of CodedOutputStream.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteTagToArray(int field_number,
-                                                       WireType type,
-                                                       uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteTagToArray(int field_number,
+                                                         WireType type,
+                                                         uint8_t* target);
 
   // Write fields, without tags.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32NoTagToArray(int32 value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64NoTagToArray(int64 value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32NoTagToArray(uint32 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64NoTagToArray(uint64 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32NoTagToArray(int32 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64NoTagToArray(int64 value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32NoTagToArray(uint32 value,
-                                                                uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64NoTagToArray(uint64 value,
-                                                                uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32NoTagToArray(int32 value,
-                                                                 uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64NoTagToArray(int64 value,
-                                                                 uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatNoTagToArray(float value,
-                                                              uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleNoTagToArray(double value,
-                                                               uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolNoTagToArray(bool value,
-                                                             uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumNoTagToArray(int value,
-                                                             uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32NoTagToArray(
+      uint32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64NoTagToArray(
+      uint64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32NoTagToArray(
+      uint32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64NoTagToArray(
+      uint64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32NoTagToArray(
+      int32_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64NoTagToArray(
+      int64_t value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatNoTagToArray(
+      float value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleNoTagToArray(
+      double value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolNoTagToArray(bool value,
+                                                               uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumNoTagToArray(int value,
+                                                               uint8_t* target);
 
   // Write fields, without tags.  These require that value.size() > 0.
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WritePrimitiveNoTagToArray(
-      const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*),
-      uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WritePrimitiveNoTagToArray(
+      const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+      uint8_t* target);
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixedNoTagToArray(
-      const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*),
-      uint8* target);
-
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32NoTagToArray(
-      const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64NoTagToArray(
-      const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32NoTagToArray(
-      const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64NoTagToArray(
-      const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32NoTagToArray(
-      const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64NoTagToArray(
-      const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatNoTagToArray(
-      const RepeatedField<float>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleNoTagToArray(
-      const RepeatedField<double>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolNoTagToArray(
-      const RepeatedField<bool>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumNoTagToArray(
-      const RepeatedField<int>& value, uint8* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixedNoTagToArray(
+      const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+      uint8_t* target);
+
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32NoTagToArray(
+      const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64NoTagToArray(
+      const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32NoTagToArray(
+      const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64NoTagToArray(
+      const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32NoTagToArray(
+      const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64NoTagToArray(
+      const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatNoTagToArray(
+      const RepeatedField<float>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleNoTagToArray(
+      const RepeatedField<double>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolNoTagToArray(
+      const RepeatedField<bool>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumNoTagToArray(
+      const RepeatedField<int>& value, uint8_t* output);
 
   // Write fields, including tags.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32ToArray(int field_number,
-                                                         int32 value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64ToArray(int field_number,
-                                                         int64 value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32ToArray(int field_number,
-                                                          uint32 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64ToArray(int field_number,
-                                                          uint64 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32ToArray(int field_number,
-                                                          int32 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64ToArray(int field_number,
-                                                          int64 value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32ToArray(int field_number,
-                                                           uint32 value,
-                                                           uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64ToArray(int field_number,
-                                                           uint64 value,
-                                                           uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32ToArray(int field_number,
-                                                            int32 value,
-                                                            uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64ToArray(int field_number,
-                                                            int64 value,
-                                                            uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatToArray(int field_number,
-                                                         float value,
-                                                         uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleToArray(int field_number,
-                                                          double value,
-                                                          uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolToArray(int field_number,
-                                                        bool value,
-                                                        uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumToArray(int field_number,
-                                                        int value,
-                                                        uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32ToArray(int field_number,
+                                                           int32_t value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64ToArray(int field_number,
+                                                           int64_t value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32ToArray(int field_number,
+                                                            uint32_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64ToArray(int field_number,
+                                                            uint64_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32ToArray(int field_number,
+                                                            int32_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64ToArray(int field_number,
+                                                            int64_t value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32ToArray(int field_number,
+                                                             uint32_t value,
+                                                             uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64ToArray(int field_number,
+                                                             uint64_t value,
+                                                             uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32ToArray(int field_number,
+                                                              int32_t value,
+                                                              uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64ToArray(int field_number,
+                                                              int64_t value,
+                                                              uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatToArray(int field_number,
+                                                           float value,
+                                                           uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleToArray(int field_number,
+                                                            double value,
+                                                            uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolToArray(int field_number,
+                                                          bool value,
+                                                          uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumToArray(int field_number,
+                                                          int value,
+                                                          uint8_t* target);
 
   template <typename T>
-  PROTOBUF_NDEBUG_INLINE static uint8* WritePrimitiveToArray(
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WritePrimitiveToArray(
       int field_number, const RepeatedField<T>& value,
-      uint8* (*Writer)(int, T, uint8*), uint8* target);
-
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteInt64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt32ToArray(
-      int field_number, const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteUInt64ToArray(
-      int field_number, const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSInt64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed32ToArray(
-      int field_number, const RepeatedField<uint32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFixed64ToArray(
-      int field_number, const RepeatedField<uint64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed32ToArray(
-      int field_number, const RepeatedField<int32>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteSFixed64ToArray(
-      int field_number, const RepeatedField<int64>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteFloatToArray(
-      int field_number, const RepeatedField<float>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteDoubleToArray(
-      int field_number, const RepeatedField<double>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBoolToArray(
-      int field_number, const RepeatedField<bool>& value, uint8* output);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteEnumToArray(
-      int field_number, const RepeatedField<int>& value, uint8* output);
-
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteStringToArray(
-      int field_number, const std::string& value, uint8* target);
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteBytesToArray(
-      int field_number, const std::string& value, uint8* target);
+      uint8_t* (*Writer)(int, T, uint8_t*), uint8_t* target);
+
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteInt64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt32ToArray(
+      int field_number, const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteUInt64ToArray(
+      int field_number, const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSInt64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed32ToArray(
+      int field_number, const RepeatedField<uint32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFixed64ToArray(
+      int field_number, const RepeatedField<uint64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed32ToArray(
+      int field_number, const RepeatedField<int32_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteSFixed64ToArray(
+      int field_number, const RepeatedField<int64_t>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteFloatToArray(
+      int field_number, const RepeatedField<float>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteDoubleToArray(
+      int field_number, const RepeatedField<double>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBoolToArray(
+      int field_number, const RepeatedField<bool>& value, uint8_t* output);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteEnumToArray(
+      int field_number, const RepeatedField<int>& value, uint8_t* output);
+
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteStringToArray(
+      int field_number, const std::string& value, uint8_t* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteBytesToArray(
+      int field_number, const std::string& value, uint8_t* target);
 
   // Whether to serialize deterministically (e.g., map keys are
   // sorted) is a property of a CodedOutputStream, and in the process
@@ -633,31 +637,31 @@ class PROTOBUF_EXPORT WireFormatLite {
   // pointer must point at an instance of MessageType, *not* a subclass (or
   // the subclass must not override SerializeWithCachedSizes()).
   template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteGroupNoVirtualToArray(
-      int field_number, const MessageType& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* InternalWriteGroupNoVirtualToArray(
+      int field_number, const MessageType& value, uint8_t* target);
   template <typename MessageType>
-  PROTOBUF_NDEBUG_INLINE static uint8* InternalWriteMessageNoVirtualToArray(
-      int field_number, const MessageType& value, uint8* target);
+  PROTOBUF_NDEBUG_INLINE static uint8_t* InternalWriteMessageNoVirtualToArray(
+      int field_number, const MessageType& value, uint8_t* target);
 
   // For backward-compatibility, the last four methods also have versions
   // that are non-deterministic always.
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteGroupToArray(
-      int field_number, const MessageLite& value, uint8* target) {
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteGroupToArray(
+      int field_number, const MessageLite& value, uint8_t* target) {
     io::EpsCopyOutputStream stream(
         target,
         value.GetCachedSize() +
             static_cast<int>(2 * io::CodedOutputStream::VarintSize32(
-                                     static_cast<uint32>(field_number) << 3)),
+                                     static_cast<uint32_t>(field_number) << 3)),
         io::CodedOutputStream::IsDefaultSerializationDeterministic());
     return InternalWriteGroup(field_number, value, target, &stream);
   }
-  PROTOBUF_NDEBUG_INLINE static uint8* WriteMessageToArray(
-      int field_number, const MessageLite& value, uint8* target) {
+  PROTOBUF_NDEBUG_INLINE static uint8_t* WriteMessageToArray(
+      int field_number, const MessageLite& value, uint8_t* target) {
     int size = value.GetCachedSize();
     io::EpsCopyOutputStream stream(
         target,
         size + static_cast<int>(io::CodedOutputStream::VarintSize32(
-                                    static_cast<uint32>(field_number) << 3) +
+                                    static_cast<uint32_t>(field_number) << 3) +
                                 io::CodedOutputStream::VarintSize32(size)),
         io::CodedOutputStream::IsDefaultSerializationDeterministic());
     return InternalWriteMessage(field_number, value, target, &stream);
@@ -667,20 +671,27 @@ class PROTOBUF_EXPORT WireFormatLite {
   // the tag, so you must also call TagSize().  (This is because, for repeated
   // fields, you should only call TagSize() once and multiply it by the element
   // count, but you may have to call XxSize() for each individual element.)
-  static inline size_t Int32Size(int32 value);
-  static inline size_t Int64Size(int64 value);
-  static inline size_t UInt32Size(uint32 value);
-  static inline size_t UInt64Size(uint64 value);
-  static inline size_t SInt32Size(int32 value);
-  static inline size_t SInt64Size(int64 value);
+  static inline size_t Int32Size(int32_t value);
+  static inline size_t Int64Size(int64_t value);
+  static inline size_t UInt32Size(uint32_t value);
+  static inline size_t UInt64Size(uint64_t value);
+  static inline size_t SInt32Size(int32_t value);
+  static inline size_t SInt64Size(int64_t value);
   static inline size_t EnumSize(int value);
-
-  static size_t Int32Size(const RepeatedField<int32>& value);
-  static size_t Int64Size(const RepeatedField<int64>& value);
-  static size_t UInt32Size(const RepeatedField<uint32>& value);
-  static size_t UInt64Size(const RepeatedField<uint64>& value);
-  static size_t SInt32Size(const RepeatedField<int32>& value);
-  static size_t SInt64Size(const RepeatedField<int64>& value);
+  static inline size_t Int32SizePlusOne(int32_t value);
+  static inline size_t Int64SizePlusOne(int64_t value);
+  static inline size_t UInt32SizePlusOne(uint32_t value);
+  static inline size_t UInt64SizePlusOne(uint64_t value);
+  static inline size_t SInt32SizePlusOne(int32_t value);
+  static inline size_t SInt64SizePlusOne(int64_t value);
+  static inline size_t EnumSizePlusOne(int value);
+
+  static size_t Int32Size(const RepeatedField<int32_t>& value);
+  static size_t Int64Size(const RepeatedField<int64_t>& value);
+  static size_t UInt32Size(const RepeatedField<uint32_t>& value);
+  static size_t UInt64Size(const RepeatedField<uint64_t>& value);
+  static size_t SInt32Size(const RepeatedField<int32_t>& value);
+  static size_t SInt64Size(const RepeatedField<int64_t>& value);
   static size_t EnumSize(const RepeatedField<int>& value);
 
   // These types always have the same size.
@@ -718,7 +729,7 @@ class PROTOBUF_EXPORT WireFormatLite {
   // can be read using potentially faster paths.
   template <typename CType, enum FieldType DeclaredType>
   PROTOBUF_NDEBUG_INLINE static bool ReadRepeatedFixedSizePrimitive(
-      int tag_size, uint32 tag, io::CodedInputStream* input,
+      int tag_size, uint32_t tag, io::CodedInputStream* input,
       RepeatedField<CType>* value);
 
   // Like ReadRepeatedFixedSizePrimitive but for packed primitive fields.
@@ -744,7 +755,7 @@ class PROTOBUF_EXPORT FieldSkipper {
   virtual ~FieldSkipper() {}
 
   // Skip a field whose tag has already been consumed.
-  virtual bool SkipField(io::CodedInputStream* input, uint32 tag);
+  virtual bool SkipField(io::CodedInputStream* input, uint32_t tag);
 
   // Skip an entire message or group, up to an end-group tag (which is consumed)
   // or end-of-stream.
@@ -765,7 +776,7 @@ class PROTOBUF_EXPORT CodedOutputStreamFieldSkipper : public FieldSkipper {
   ~CodedOutputStreamFieldSkipper() override {}
 
   // implements FieldSkipper -----------------------------------------
-  bool SkipField(io::CodedInputStream* input, uint32 tag) override;
+  bool SkipField(io::CodedInputStream* input, uint32_t tag) override;
   bool SkipMessage(io::CodedInputStream* input) override;
   void SkipUnknownEnum(int field_number, int value) override;
 
@@ -780,23 +791,23 @@ inline WireFormatLite::CppType WireFormatLite::FieldTypeToCppType(
   return kFieldTypeToCppTypeMap[type];
 }
 
-constexpr inline uint32 WireFormatLite::MakeTag(int field_number,
-                                                WireType type) {
+constexpr inline uint32_t WireFormatLite::MakeTag(int field_number,
+                                                  WireType type) {
   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);
 }
 
-inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32 tag) {
+inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32_t tag) {
   return static_cast<WireType>(tag & kTagTypeMask);
 }
 
-inline int WireFormatLite::GetTagFieldNumber(uint32 tag) {
+inline int WireFormatLite::GetTagFieldNumber(uint32_t tag) {
   return static_cast<int>(tag >> kTagTypeBits);
 }
 
 inline size_t WireFormatLite::TagSize(int field_number,
                                       WireFormatLite::FieldType type) {
   size_t result = io::CodedOutputStream::VarintSize32(
-      static_cast<uint32>(field_number << kTagTypeBits));
+      static_cast<uint32_t>(field_number << kTagTypeBits));
   if (type == TYPE_GROUP) {
     // Groups have both a start and an end tag.
     return result * 2;
@@ -805,19 +816,19 @@ inline size_t WireFormatLite::TagSize(int field_number,
   }
 }
 
-inline uint32 WireFormatLite::EncodeFloat(float value) {
-  return bit_cast<uint32>(value);
+inline uint32_t WireFormatLite::EncodeFloat(float value) {
+  return bit_cast<uint32_t>(value);
 }
 
-inline float WireFormatLite::DecodeFloat(uint32 value) {
+inline float WireFormatLite::DecodeFloat(uint32_t value) {
   return bit_cast<float>(value);
 }
 
-inline uint64 WireFormatLite::EncodeDouble(double value) {
-  return bit_cast<uint64>(value);
+inline uint64_t WireFormatLite::EncodeDouble(double value) {
+  return bit_cast<uint64_t>(value);
 }
 
-inline double WireFormatLite::DecodeDouble(uint64 value) {
+inline double WireFormatLite::DecodeDouble(uint64_t value) {
   return bit_cast<double>(value);
 }
 
@@ -832,7 +843,7 @@ inline double WireFormatLite::DecodeDouble(uint64 value) {
 // in such a way that those with a small absolute value will have smaller
 // encoded values, making them appropriate for encoding using varint.
 //
-//       int32 ->     uint32
+//       int32_t ->     uint32_t
 // -------------------------
 //           0 ->          0
 //          -1 ->          1
@@ -845,26 +856,26 @@ inline double WireFormatLite::DecodeDouble(uint64 value) {
 //        >> encode >>
 //        << decode <<
 
-inline uint32 WireFormatLite::ZigZagEncode32(int32 n) {
+inline uint32_t WireFormatLite::ZigZagEncode32(int32_t n) {
   // Note:  the right-shift must be arithmetic
   // Note:  left shift must be unsigned because of overflow
-  return (static_cast<uint32>(n) << 1) ^ static_cast<uint32>(n >> 31);
+  return (static_cast<uint32_t>(n) << 1) ^ static_cast<uint32_t>(n >> 31);
 }
 
-inline int32 WireFormatLite::ZigZagDecode32(uint32 n) {
+inline int32_t WireFormatLite::ZigZagDecode32(uint32_t n) {
   // Note:  Using unsigned types prevent undefined behavior
-  return static_cast<int32>((n >> 1) ^ (~(n & 1) + 1));
+  return static_cast<int32_t>((n >> 1) ^ (~(n & 1) + 1));
 }
 
-inline uint64 WireFormatLite::ZigZagEncode64(int64 n) {
+inline uint64_t WireFormatLite::ZigZagEncode64(int64_t n) {
   // Note:  the right-shift must be arithmetic
   // Note:  left shift must be unsigned because of overflow
-  return (static_cast<uint64>(n) << 1) ^ static_cast<uint64>(n >> 63);
+  return (static_cast<uint64_t>(n) << 1) ^ static_cast<uint64_t>(n >> 63);
 }
 
-inline int64 WireFormatLite::ZigZagDecode64(uint64 n) {
+inline int64_t WireFormatLite::ZigZagDecode64(uint64_t n) {
   // Note:  Using unsigned types prevent undefined behavior
-  return static_cast<int64>((n >> 1) ^ (~(n & 1) + 1));
+  return static_cast<int64_t>((n >> 1) ^ (~(n & 1) + 1));
 }
 
 // String is for UTF-8 text only, but, even so, ReadString() can simply
@@ -880,8 +891,8 @@ inline bool WireFormatLite::ReadString(io::CodedInputStream* input,
   return ReadBytes(input, p);
 }
 
-inline uint8* InternalSerializeUnknownMessageSetItemsToArray(
-    const std::string& unknown_fields, uint8* target,
+inline uint8_t* InternalSerializeUnknownMessageSetItemsToArray(
+    const std::string& unknown_fields, uint8_t* target,
     io::EpsCopyOutputStream* stream) {
   return stream->WriteRaw(unknown_fields.data(),
                           static_cast<int>(unknown_fields.size()), target);
@@ -895,77 +906,83 @@ inline size_t ComputeUnknownMessageSetItemsSize(
 // Implementation details of ReadPrimitive.
 
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_INT32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_INT32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_INT64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_INT64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint32, WireFormatLite::TYPE_UINT32>(
-    io::CodedInputStream* input, uint32* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint32_t, WireFormatLite::TYPE_UINT32>(
+    io::CodedInputStream* input, uint32_t* value) {
   return input->ReadVarint32(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint64, WireFormatLite::TYPE_UINT64>(
-    io::CodedInputStream* input, uint64* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint64_t, WireFormatLite::TYPE_UINT64>(
+    io::CodedInputStream* input, uint64_t* value) {
   return input->ReadVarint64(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_SINT32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_SINT32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
   *value = ZigZagDecode32(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_SINT64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_SINT64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
   *value = ZigZagDecode64(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint32, WireFormatLite::TYPE_FIXED32>(
-    io::CodedInputStream* input, uint32* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint32_t, WireFormatLite::TYPE_FIXED32>(
+    io::CodedInputStream* input, uint32_t* value) {
   return input->ReadLittleEndian32(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<uint64, WireFormatLite::TYPE_FIXED64>(
-    io::CodedInputStream* input, uint64* value) {
+inline bool
+WireFormatLite::ReadPrimitive<uint64_t, WireFormatLite::TYPE_FIXED64>(
+    io::CodedInputStream* input, uint64_t* value) {
   return input->ReadLittleEndian64(value);
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int32, WireFormatLite::TYPE_SFIXED32>(
-    io::CodedInputStream* input, int32* value) {
-  uint32 temp;
+inline bool
+WireFormatLite::ReadPrimitive<int32_t, WireFormatLite::TYPE_SFIXED32>(
+    io::CodedInputStream* input, int32_t* value) {
+  uint32_t temp;
   if (!input->ReadLittleEndian32(&temp)) return false;
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return true;
 }
 template <>
-inline bool WireFormatLite::ReadPrimitive<int64, WireFormatLite::TYPE_SFIXED64>(
-    io::CodedInputStream* input, int64* value) {
-  uint64 temp;
+inline bool
+WireFormatLite::ReadPrimitive<int64_t, WireFormatLite::TYPE_SFIXED64>(
+    io::CodedInputStream* input, int64_t* value) {
+  uint64_t temp;
   if (!input->ReadLittleEndian64(&temp)) return false;
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return true;
 }
 template <>
 inline bool WireFormatLite::ReadPrimitive<float, WireFormatLite::TYPE_FLOAT>(
     io::CodedInputStream* input, float* value) {
-  uint32 temp;
+  uint32_t temp;
   if (!input->ReadLittleEndian32(&temp)) return false;
   *value = DecodeFloat(temp);
   return true;
@@ -973,7 +990,7 @@ inline bool WireFormatLite::ReadPrimitive<float, WireFormatLite::TYPE_FLOAT>(
 template <>
 inline bool WireFormatLite::ReadPrimitive<double, WireFormatLite::TYPE_DOUBLE>(
     io::CodedInputStream* input, double* value) {
-  uint64 temp;
+  uint64_t temp;
   if (!input->ReadLittleEndian64(&temp)) return false;
   *value = DecodeDouble(temp);
   return true;
@@ -981,7 +998,7 @@ inline bool WireFormatLite::ReadPrimitive<double, WireFormatLite::TYPE_DOUBLE>(
 template <>
 inline bool WireFormatLite::ReadPrimitive<bool, WireFormatLite::TYPE_BOOL>(
     io::CodedInputStream* input, bool* value) {
-  uint64 temp;
+  uint64_t temp;
   if (!input->ReadVarint64(&temp)) return false;
   *value = temp != 0;
   return true;
@@ -989,56 +1006,56 @@ inline bool WireFormatLite::ReadPrimitive<bool, WireFormatLite::TYPE_BOOL>(
 template <>
 inline bool WireFormatLite::ReadPrimitive<int, WireFormatLite::TYPE_ENUM>(
     io::CodedInputStream* input, int* value) {
-  uint32 temp;
+  uint32_t temp;
   if (!input->ReadVarint32(&temp)) return false;
   *value = static_cast<int>(temp);
   return true;
 }
 
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<uint32, WireFormatLite::TYPE_FIXED32>(
-    const uint8* buffer, uint32* value) {
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<uint32_t, WireFormatLite::TYPE_FIXED32>(
+    const uint8_t* buffer, uint32_t* value) {
   return io::CodedInputStream::ReadLittleEndian32FromArray(buffer, value);
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<uint64, WireFormatLite::TYPE_FIXED64>(
-    const uint8* buffer, uint64* value) {
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<uint64_t, WireFormatLite::TYPE_FIXED64>(
+    const uint8_t* buffer, uint64_t* value) {
   return io::CodedInputStream::ReadLittleEndian64FromArray(buffer, value);
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<int32, WireFormatLite::TYPE_SFIXED32>(
-    const uint8* buffer, int32* value) {
-  uint32 temp;
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<int32_t, WireFormatLite::TYPE_SFIXED32>(
+    const uint8_t* buffer, int32_t* value) {
+  uint32_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian32FromArray(buffer, &temp);
-  *value = static_cast<int32>(temp);
+  *value = static_cast<int32_t>(temp);
   return buffer;
 }
 template <>
-inline const uint8*
-WireFormatLite::ReadPrimitiveFromArray<int64, WireFormatLite::TYPE_SFIXED64>(
-    const uint8* buffer, int64* value) {
-  uint64 temp;
+inline const uint8_t*
+WireFormatLite::ReadPrimitiveFromArray<int64_t, WireFormatLite::TYPE_SFIXED64>(
+    const uint8_t* buffer, int64_t* value) {
+  uint64_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian64FromArray(buffer, &temp);
-  *value = static_cast<int64>(temp);
+  *value = static_cast<int64_t>(temp);
   return buffer;
 }
 template <>
-inline const uint8*
+inline const uint8_t*
 WireFormatLite::ReadPrimitiveFromArray<float, WireFormatLite::TYPE_FLOAT>(
-    const uint8* buffer, float* value) {
-  uint32 temp;
+    const uint8_t* buffer, float* value) {
+  uint32_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian32FromArray(buffer, &temp);
   *value = DecodeFloat(temp);
   return buffer;
 }
 template <>
-inline const uint8*
+inline const uint8_t*
 WireFormatLite::ReadPrimitiveFromArray<double, WireFormatLite::TYPE_DOUBLE>(
-    const uint8* buffer, double* value) {
-  uint64 temp;
+    const uint8_t* buffer, double* value) {
+  uint64_t temp;
   buffer = io::CodedInputStream::ReadLittleEndian64FromArray(buffer, &temp);
   *value = DecodeDouble(temp);
   return buffer;
@@ -1047,7 +1064,7 @@ WireFormatLite::ReadPrimitiveFromArray<double, WireFormatLite::TYPE_DOUBLE>(
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 inline bool WireFormatLite::ReadRepeatedPrimitive(
     int,  // tag_size, unused.
-    uint32 tag, io::CodedInputStream* input, RepeatedField<CType>* values) {
+    uint32_t tag, io::CodedInputStream* input, RepeatedField<CType>* values) {
   CType value;
   if (!ReadPrimitive<CType, DeclaredType>(input, &value)) return false;
   values->Add(value);
@@ -1062,7 +1079,7 @@ inline bool WireFormatLite::ReadRepeatedPrimitive(
 
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
-    int tag_size, uint32 tag, io::CodedInputStream* input,
+    int tag_size, uint32_t tag, io::CodedInputStream* input,
     RepeatedField<CType>* values) {
   GOOGLE_DCHECK_EQ(UInt32Size(tag), static_cast<size_t>(tag_size));
   CType value;
@@ -1082,7 +1099,7 @@ inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
   int size;
   input->GetDirectBufferPointerInline(&void_pointer, &size);
   if (size > 0) {
-    const uint8* buffer = reinterpret_cast<const uint8*>(void_pointer);
+    const uint8_t* buffer = reinterpret_cast<const uint8_t*>(void_pointer);
     // The number of bytes each type occupies on the wire.
     const int per_value_size = tag_size + static_cast<int>(sizeof(value));
 
@@ -1092,7 +1109,7 @@ inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
     int num_read = 0;
     while (num_read < elements_available &&
            (buffer = io::CodedInputStream::ExpectTagFromArray(buffer, tag)) !=
-               NULL) {
+               nullptr) {
       buffer = ReadPrimitiveFromArray<CType, DeclaredType>(buffer, &value);
       values->AddAlreadyReserved(value);
       ++num_read;
@@ -1111,17 +1128,17 @@ inline bool WireFormatLite::ReadRepeatedFixedSizePrimitive(
   template <>                                                             \
   inline bool WireFormatLite::ReadRepeatedPrimitive<                      \
       CPPTYPE, WireFormatLite::DECLARED_TYPE>(                            \
-      int tag_size, uint32 tag, io::CodedInputStream* input,              \
+      int tag_size, uint32_t tag, io::CodedInputStream* input,            \
       RepeatedField<CPPTYPE>* values) {                                   \
     return ReadRepeatedFixedSizePrimitive<CPPTYPE,                        \
                                           WireFormatLite::DECLARED_TYPE>( \
         tag_size, tag, input, values);                                    \
   }
 
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint32, TYPE_FIXED32)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint64, TYPE_FIXED64)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(int32, TYPE_SFIXED32)
-READ_REPEATED_FIXED_SIZE_PRIMITIVE(int64, TYPE_SFIXED64)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint32_t, TYPE_FIXED32)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(uint64_t, TYPE_FIXED64)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(int32_t, TYPE_SFIXED32)
+READ_REPEATED_FIXED_SIZE_PRIMITIVE(int64_t, TYPE_SFIXED64)
 READ_REPEATED_FIXED_SIZE_PRIMITIVE(float, TYPE_FLOAT)
 READ_REPEATED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
@@ -1129,7 +1146,7 @@ READ_REPEATED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
 template <typename CType, enum WireFormatLite::FieldType DeclaredType>
 bool WireFormatLite::ReadRepeatedPrimitiveNoInline(
-    int tag_size, uint32 tag, io::CodedInputStream* input,
+    int tag_size, uint32_t tag, io::CodedInputStream* input,
     RepeatedField<CType>* value) {
   return ReadRepeatedPrimitive<CType, DeclaredType>(tag_size, tag, input,
                                                     value);
@@ -1171,13 +1188,13 @@ inline bool WireFormatLite::ReadPackedFixedSizePrimitive(
   // -1               >= 0   Use fast path if length <= Limit.
   // >= 0             -1     Use slow path.
   // >= 0             >= 0   Use fast path if length <= min(both limits).
-  int64 bytes_limit = input->BytesUntilTotalBytesLimit();
+  int64_t bytes_limit = input->BytesUntilTotalBytesLimit();
   if (bytes_limit == -1) {
     bytes_limit = input->BytesUntilLimit();
   } else {
     // parentheses around (std::min) prevents macro expansion of min(...)
     bytes_limit =
-        (std::min)(bytes_limit, static_cast<int64>(input->BytesUntilLimit()));
+        (std::min)(bytes_limit, static_cast<int64_t>(input->BytesUntilLimit()));
   }
   if (bytes_limit >= new_bytes) {
     // Fast-path that pre-allocates *values to the final size.
@@ -1222,10 +1239,10 @@ inline bool WireFormatLite::ReadPackedFixedSizePrimitive(
         input, values);                                                        \
   }
 
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint32, TYPE_FIXED32)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint64, TYPE_FIXED64)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int32, TYPE_SFIXED32)
-READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int64, TYPE_SFIXED64)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint32_t, TYPE_FIXED32)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(uint64_t, TYPE_FIXED64)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int32_t, TYPE_SFIXED32)
+READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(int64_t, TYPE_SFIXED64)
 READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(float, TYPE_FLOAT)
 READ_REPEATED_PACKED_FIXED_SIZE_PRIMITIVE(double, TYPE_DOUBLE)
 
@@ -1271,45 +1288,45 @@ inline void WireFormatLite::WriteTag(int field_number, WireType type,
   output->WriteTag(MakeTag(field_number, type));
 }
 
-inline void WireFormatLite::WriteInt32NoTag(int32 value,
+inline void WireFormatLite::WriteInt32NoTag(int32_t value,
                                             io::CodedOutputStream* output) {
   output->WriteVarint32SignExtended(value);
 }
-inline void WireFormatLite::WriteInt64NoTag(int64 value,
+inline void WireFormatLite::WriteInt64NoTag(int64_t value,
                                             io::CodedOutputStream* output) {
-  output->WriteVarint64(static_cast<uint64>(value));
+  output->WriteVarint64(static_cast<uint64_t>(value));
 }
-inline void WireFormatLite::WriteUInt32NoTag(uint32 value,
+inline void WireFormatLite::WriteUInt32NoTag(uint32_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint32(value);
 }
-inline void WireFormatLite::WriteUInt64NoTag(uint64 value,
+inline void WireFormatLite::WriteUInt64NoTag(uint64_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint64(value);
 }
-inline void WireFormatLite::WriteSInt32NoTag(int32 value,
+inline void WireFormatLite::WriteSInt32NoTag(int32_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint32(ZigZagEncode32(value));
 }
-inline void WireFormatLite::WriteSInt64NoTag(int64 value,
+inline void WireFormatLite::WriteSInt64NoTag(int64_t value,
                                              io::CodedOutputStream* output) {
   output->WriteVarint64(ZigZagEncode64(value));
 }
-inline void WireFormatLite::WriteFixed32NoTag(uint32 value,
+inline void WireFormatLite::WriteFixed32NoTag(uint32_t value,
                                               io::CodedOutputStream* output) {
   output->WriteLittleEndian32(value);
 }
-inline void WireFormatLite::WriteFixed64NoTag(uint64 value,
+inline void WireFormatLite::WriteFixed64NoTag(uint64_t value,
                                               io::CodedOutputStream* output) {
   output->WriteLittleEndian64(value);
 }
-inline void WireFormatLite::WriteSFixed32NoTag(int32 value,
+inline void WireFormatLite::WriteSFixed32NoTag(int32_t value,
                                                io::CodedOutputStream* output) {
-  output->WriteLittleEndian32(static_cast<uint32>(value));
+  output->WriteLittleEndian32(static_cast<uint32_t>(value));
 }
-inline void WireFormatLite::WriteSFixed64NoTag(int64 value,
+inline void WireFormatLite::WriteSFixed64NoTag(int64_t value,
                                                io::CodedOutputStream* output) {
-  output->WriteLittleEndian64(static_cast<uint64>(value));
+  output->WriteLittleEndian64(static_cast<uint64_t>(value));
 }
 inline void WireFormatLite::WriteFloatNoTag(float value,
                                             io::CodedOutputStream* output) {
@@ -1350,77 +1367,80 @@ inline void WireFormatLite::WriteMessageNoVirtual(
 
 // ===================================================================
 
-inline uint8* WireFormatLite::WriteTagToArray(int field_number, WireType type,
-                                              uint8* target) {
+inline uint8_t* WireFormatLite::WriteTagToArray(int field_number, WireType type,
+                                                uint8_t* target) {
   return io::CodedOutputStream::WriteTagToArray(MakeTag(field_number, type),
                                                 target);
 }
 
-inline uint8* WireFormatLite::WriteInt32NoTagToArray(int32 value,
-                                                     uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(int32_t value,
+                                                       uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32SignExtendedToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteInt64NoTagToArray(int64 value,
-                                                     uint8* target) {
-  return io::CodedOutputStream::WriteVarint64ToArray(static_cast<uint64>(value),
-                                                     target);
+inline uint8_t* WireFormatLite::WriteInt64NoTagToArray(int64_t value,
+                                                       uint8_t* target) {
+  return io::CodedOutputStream::WriteVarint64ToArray(
+      static_cast<uint64_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteUInt32NoTagToArray(uint32 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32NoTagToArray(uint32_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt64NoTagToArray(uint64 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64NoTagToArray(uint64_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint64ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt32NoTagToArray(int32 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32NoTagToArray(int32_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(ZigZagEncode32(value),
                                                      target);
 }
-inline uint8* WireFormatLite::WriteSInt64NoTagToArray(int64 value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64NoTagToArray(int64_t value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteVarint64ToArray(ZigZagEncode64(value),
                                                      target);
 }
-inline uint8* WireFormatLite::WriteFixed32NoTagToArray(uint32 value,
-                                                       uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32NoTagToArray(uint32_t value,
+                                                         uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed64NoTagToArray(uint64 value,
-                                                       uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64NoTagToArray(uint64_t value,
+                                                         uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32NoTagToArray(int32 value,
-                                                        uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32NoTagToArray(int32_t value,
+                                                          uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(
-      static_cast<uint32>(value), target);
+      static_cast<uint32_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteSFixed64NoTagToArray(int64 value,
-                                                        uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64NoTagToArray(int64_t value,
+                                                          uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(
-      static_cast<uint64>(value), target);
+      static_cast<uint64_t>(value), target);
 }
-inline uint8* WireFormatLite::WriteFloatNoTagToArray(float value,
-                                                     uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatNoTagToArray(float value,
+                                                       uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian32ToArray(EncodeFloat(value),
                                                            target);
 }
-inline uint8* WireFormatLite::WriteDoubleNoTagToArray(double value,
-                                                      uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleNoTagToArray(double value,
+                                                        uint8_t* target) {
   return io::CodedOutputStream::WriteLittleEndian64ToArray(EncodeDouble(value),
                                                            target);
 }
-inline uint8* WireFormatLite::WriteBoolNoTagToArray(bool value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolNoTagToArray(bool value,
+                                                      uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32ToArray(value ? 1 : 0, target);
 }
-inline uint8* WireFormatLite::WriteEnumNoTagToArray(int value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumNoTagToArray(int value,
+                                                      uint8_t* target) {
   return io::CodedOutputStream::WriteVarint32SignExtendedToArray(value, target);
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WritePrimitiveNoTagToArray(
-    const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*), uint8* target) {
+inline uint8_t* WireFormatLite::WritePrimitiveNoTagToArray(
+    const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+    uint8_t* target) {
   const int n = value.size();
   GOOGLE_DCHECK_GT(n, 0);
 
@@ -1434,8 +1454,9 @@ inline uint8* WireFormatLite::WritePrimitiveNoTagToArray(
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WriteFixedNoTagToArray(
-    const RepeatedField<T>& value, uint8* (*Writer)(T, uint8*), uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixedNoTagToArray(
+    const RepeatedField<T>& value, uint8_t* (*Writer)(T, uint8_t*),
+    uint8_t* target) {
 #if defined(PROTOBUF_LITTLE_ENDIAN)
   (void)Writer;
 
@@ -1451,138 +1472,149 @@ inline uint8* WireFormatLite::WriteFixedNoTagToArray(
 #endif
 }
 
-inline uint8* WireFormatLite::WriteInt32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteInt64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt32NoTagToArray(
-    const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32NoTagToArray(
+    const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteUInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt64NoTagToArray(
-    const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64NoTagToArray(
+    const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteUInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteSInt32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteSInt64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed32NoTagToArray(
-    const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32NoTagToArray(
+    const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFixed32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed64NoTagToArray(
-    const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64NoTagToArray(
+    const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFixed64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32NoTagToArray(
-    const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32NoTagToArray(
+    const RepeatedField<int32_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteSFixed32NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteSFixed64NoTagToArray(
-    const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64NoTagToArray(
+    const RepeatedField<int64_t>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteSFixed64NoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteFloatNoTagToArray(
-    const RepeatedField<float>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatNoTagToArray(
+    const RepeatedField<float>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteFloatNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteDoubleNoTagToArray(
-    const RepeatedField<double>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleNoTagToArray(
+    const RepeatedField<double>& value, uint8_t* target) {
   return WriteFixedNoTagToArray(value, WriteDoubleNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteBoolNoTagToArray(
-    const RepeatedField<bool>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolNoTagToArray(
+    const RepeatedField<bool>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteBoolNoTagToArray, target);
 }
-inline uint8* WireFormatLite::WriteEnumNoTagToArray(
-    const RepeatedField<int>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumNoTagToArray(
+    const RepeatedField<int>& value, uint8_t* target) {
   return WritePrimitiveNoTagToArray(value, WriteEnumNoTagToArray, target);
 }
 
-inline uint8* WireFormatLite::WriteInt32ToArray(int field_number, int32 value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32ToArray(int field_number,
+                                                  int32_t value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteInt64ToArray(int field_number, int64 value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64ToArray(int field_number,
+                                                  int64_t value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt32ToArray(int field_number, uint32 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32ToArray(int field_number,
+                                                   uint32_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteUInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteUInt64ToArray(int field_number, uint64 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64ToArray(int field_number,
+                                                   uint64_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteUInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt32ToArray(int field_number, int32 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32ToArray(int field_number,
+                                                   int32_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteSInt32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSInt64ToArray(int field_number, int64 value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64ToArray(int field_number,
+                                                   int64_t value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteSInt64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed32ToArray(int field_number,
-                                                  uint32 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32ToArray(int field_number,
+                                                    uint32_t value,
+                                                    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteFixed32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFixed64ToArray(int field_number,
-                                                  uint64 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64ToArray(int field_number,
+                                                    uint64_t value,
+                                                    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteFixed64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed32ToArray(int field_number,
-                                                   int32 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32ToArray(int field_number,
+                                                     int32_t value,
+                                                     uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteSFixed32NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteSFixed64ToArray(int field_number,
-                                                   int64 value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64ToArray(int field_number,
+                                                     int64_t value,
+                                                     uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteSFixed64NoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteFloatToArray(int field_number, float value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatToArray(int field_number, float value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED32, target);
   return WriteFloatNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteDoubleToArray(int field_number, double value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleToArray(int field_number,
+                                                   double value,
+                                                   uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_FIXED64, target);
   return WriteDoubleNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteBoolToArray(int field_number, bool value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolToArray(int field_number, bool value,
+                                                 uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteBoolNoTagToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteEnumToArray(int field_number, int value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumToArray(int field_number, int value,
+                                                 uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);
   return WriteEnumNoTagToArray(value, target);
 }
 
 template <typename T>
-inline uint8* WireFormatLite::WritePrimitiveToArray(
+inline uint8_t* WireFormatLite::WritePrimitiveToArray(
     int field_number, const RepeatedField<T>& value,
-    uint8* (*Writer)(int, T, uint8*), uint8* target) {
+    uint8_t* (*Writer)(int, T, uint8_t*), uint8_t* target) {
   const int n = value.size();
   if (n == 0) {
     return target;
@@ -1597,71 +1629,69 @@ inline uint8* WireFormatLite::WritePrimitiveToArray(
   return target;
 }
 
-inline uint8* WireFormatLite::WriteInt32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteInt64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteInt64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt32ToArray(
-    int field_number, const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt32ToArray(
+    int field_number, const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteUInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteUInt64ToArray(
-    int field_number, const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteUInt64ToArray(
+    int field_number, const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteUInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSInt32ToArray, target);
 }
-inline uint8* WireFormatLite::WriteSInt64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSInt64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSInt64ToArray, target);
 }
-inline uint8* WireFormatLite::WriteFixed32ToArray(
-    int field_number, const RepeatedField<uint32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed32ToArray(
+    int field_number, const RepeatedField<uint32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFixed32ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteFixed64ToArray(
-    int field_number, const RepeatedField<uint64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFixed64ToArray(
+    int field_number, const RepeatedField<uint64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFixed64ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteSFixed32ToArray(
-    int field_number, const RepeatedField<int32>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed32ToArray(
+    int field_number, const RepeatedField<int32_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSFixed32ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteSFixed64ToArray(
-    int field_number, const RepeatedField<int64>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteSFixed64ToArray(
+    int field_number, const RepeatedField<int64_t>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteSFixed64ToArray,
                                target);
 }
-inline uint8* WireFormatLite::WriteFloatToArray(
-    int field_number, const RepeatedField<float>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteFloatToArray(
+    int field_number, const RepeatedField<float>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteFloatToArray, target);
 }
-inline uint8* WireFormatLite::WriteDoubleToArray(
-    int field_number, const RepeatedField<double>& value, uint8* target) {
+inline uint8_t* WireFormatLite::WriteDoubleToArray(
+    int field_number, const RepeatedField<double>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteDoubleToArray, target);
 }
-inline uint8* WireFormatLite::WriteBoolToArray(int field_number,
-                                               const RepeatedField<bool>& value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteBoolToArray(
+    int field_number, const RepeatedField<bool>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteBoolToArray, target);
 }
-inline uint8* WireFormatLite::WriteEnumToArray(int field_number,
-                                               const RepeatedField<int>& value,
-                                               uint8* target) {
+inline uint8_t* WireFormatLite::WriteEnumToArray(
+    int field_number, const RepeatedField<int>& value, uint8_t* target) {
   return WritePrimitiveToArray(field_number, value, WriteEnumToArray, target);
 }
-inline uint8* WireFormatLite::WriteStringToArray(int field_number,
-                                                 const std::string& value,
-                                                 uint8* target) {
+inline uint8_t* WireFormatLite::WriteStringToArray(int field_number,
+                                                   const std::string& value,
+                                                   uint8_t* target) {
   // String is for UTF-8 text only
   // WARNING:  In wire_format.cc, both strings and bytes are handled by
   //   WriteString() to avoid code duplication.  If the implementations become
@@ -1669,9 +1699,9 @@ inline uint8* WireFormatLite::WriteStringToArray(int field_number,
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);
 }
-inline uint8* WireFormatLite::WriteBytesToArray(int field_number,
-                                                const std::string& value,
-                                                uint8* target) {
+inline uint8_t* WireFormatLite::WriteBytesToArray(int field_number,
+                                                  const std::string& value,
+                                                  uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);
 }
@@ -1699,21 +1729,21 @@ inline uint8* WireFormatLite::InternalWriteMessage(
 // See comment on ReadGroupNoVirtual to understand the need for this template
 // parameter name.
 template <typename MessageType_WorkAroundCppLookupDefect>
-inline uint8* WireFormatLite::InternalWriteGroupNoVirtualToArray(
+inline uint8_t* WireFormatLite::InternalWriteGroupNoVirtualToArray(
     int field_number, const MessageType_WorkAroundCppLookupDefect& value,
-    uint8* target) {
+    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_START_GROUP, target);
   target = value.MessageType_WorkAroundCppLookupDefect::
                SerializeWithCachedSizesToArray(target);
   return WriteTagToArray(field_number, WIRETYPE_END_GROUP, target);
 }
 template <typename MessageType_WorkAroundCppLookupDefect>
-inline uint8* WireFormatLite::InternalWriteMessageNoVirtualToArray(
+inline uint8_t* WireFormatLite::InternalWriteMessageNoVirtualToArray(
     int field_number, const MessageType_WorkAroundCppLookupDefect& value,
-    uint8* target) {
+    uint8_t* target) {
   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);
   target = io::CodedOutputStream::WriteVarint32ToArray(
-      static_cast<uint32>(
+      static_cast<uint32_t>(
           value.MessageType_WorkAroundCppLookupDefect::GetCachedSize()),
       target);
   return value
@@ -1723,27 +1753,49 @@ inline uint8* WireFormatLite::InternalWriteMessageNoVirtualToArray(
 
 // ===================================================================
 
-inline size_t WireFormatLite::Int32Size(int32 value) {
+inline size_t WireFormatLite::Int32Size(int32_t value) {
   return io::CodedOutputStream::VarintSize32SignExtended(value);
 }
-inline size_t WireFormatLite::Int64Size(int64 value) {
-  return io::CodedOutputStream::VarintSize64(static_cast<uint64>(value));
+inline size_t WireFormatLite::Int64Size(int64_t value) {
+  return io::CodedOutputStream::VarintSize64(static_cast<uint64_t>(value));
 }
-inline size_t WireFormatLite::UInt32Size(uint32 value) {
+inline size_t WireFormatLite::UInt32Size(uint32_t value) {
   return io::CodedOutputStream::VarintSize32(value);
 }
-inline size_t WireFormatLite::UInt64Size(uint64 value) {
+inline size_t WireFormatLite::UInt64Size(uint64_t value) {
   return io::CodedOutputStream::VarintSize64(value);
 }
-inline size_t WireFormatLite::SInt32Size(int32 value) {
+inline size_t WireFormatLite::SInt32Size(int32_t value) {
   return io::CodedOutputStream::VarintSize32(ZigZagEncode32(value));
 }
-inline size_t WireFormatLite::SInt64Size(int64 value) {
+inline size_t WireFormatLite::SInt64Size(int64_t value) {
   return io::CodedOutputStream::VarintSize64(ZigZagEncode64(value));
 }
 inline size_t WireFormatLite::EnumSize(int value) {
   return io::CodedOutputStream::VarintSize32SignExtended(value);
 }
+inline size_t WireFormatLite::Int32SizePlusOne(int32_t value) {
+  return io::CodedOutputStream::VarintSize32SignExtendedPlusOne(value);
+}
+inline size_t WireFormatLite::Int64SizePlusOne(int64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(
+      static_cast<uint64_t>(value));
+}
+inline size_t WireFormatLite::UInt32SizePlusOne(uint32_t value) {
+  return io::CodedOutputStream::VarintSize32PlusOne(value);
+}
+inline size_t WireFormatLite::UInt64SizePlusOne(uint64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(value);
+}
+inline size_t WireFormatLite::SInt32SizePlusOne(int32_t value) {
+  return io::CodedOutputStream::VarintSize32PlusOne(ZigZagEncode32(value));
+}
+inline size_t WireFormatLite::SInt64SizePlusOne(int64_t value) {
+  return io::CodedOutputStream::VarintSize64PlusOne(ZigZagEncode64(value));
+}
+inline size_t WireFormatLite::EnumSizePlusOne(int value) {
+  return io::CodedOutputStream::VarintSize32SignExtendedPlusOne(value);
+}
 
 inline size_t WireFormatLite::StringSize(const std::string& value) {
   return LengthDelimitedSize(value.size());
@@ -1778,11 +1830,11 @@ inline size_t WireFormatLite::MessageSizeNoVirtual(
 
 inline size_t WireFormatLite::LengthDelimitedSize(size_t length) {
   // The static_cast here prevents an error in certain compiler configurations
-  // but is not technically correct--if length is too large to fit in a uint32
+  // but is not technically correct--if length is too large to fit in a uint32_t
   // then it will be silently truncated. We will need to fix this if we ever
   // decide to start supporting serialized messages greater than 2 GiB in size.
   return length +
-         io::CodedOutputStream::VarintSize32(static_cast<uint32>(length));
+         io::CodedOutputStream::VarintSize32(static_cast<uint32_t>(length));
 }
 
 template <typename MS>
@@ -1791,55 +1843,64 @@ bool ParseMessageSetItemImpl(io::CodedInputStream* input, MS ms) {
   //   required int32 type_id = 2;
   //   required data message = 3;
 
-  uint32 last_type_id = 0;
+  uint32_t last_type_id = 0;
 
   // If we see message data before the type_id, we'll append it to this so
   // we can parse it later.
   std::string message_data;
 
+  enum class State { kNoTag, kHasType, kHasPayload, kDone };
+  State state = State::kNoTag;
+
   while (true) {
-    const uint32 tag = input->ReadTagNoLastTag();
+    const uint32_t tag = input->ReadTagNoLastTag();
     if (tag == 0) return false;
 
     switch (tag) {
       case WireFormatLite::kMessageSetTypeIdTag: {
-        uint32 type_id;
+        uint32_t type_id;
         if (!input->ReadVarint32(&type_id)) return false;
-        last_type_id = type_id;
-
-        if (!message_data.empty()) {
+        if (state == State::kNoTag) {
+          last_type_id = type_id;
+          state = State::kHasType;
+        } else if (state == State::kHasPayload) {
           // We saw some message data before the type_id.  Have to parse it
           // now.
           io::CodedInputStream sub_input(
-              reinterpret_cast<const uint8*>(message_data.data()),
+              reinterpret_cast<const uint8_t*>(message_data.data()),
               static_cast<int>(message_data.size()));
           sub_input.SetRecursionLimit(input->RecursionBudget());
-          if (!ms.ParseField(last_type_id, &sub_input)) {
+          if (!ms.ParseField(type_id, &sub_input)) {
             return false;
           }
           message_data.clear();
+          state = State::kDone;
         }
 
         break;
       }
 
       case WireFormatLite::kMessageSetMessageTag: {
-        if (last_type_id == 0) {
+        if (state == State::kHasType) {
+          // Already saw type_id, so we can parse this directly.
+          if (!ms.ParseField(last_type_id, input)) {
+            return false;
+          }
+          state = State::kDone;
+        } else if (state == State::kNoTag) {
           // We haven't seen a type_id yet.  Append this data to message_data.
-          uint32 length;
+          uint32_t length;
           if (!input->ReadVarint32(&length)) return false;
-          if (static_cast<int32>(length) < 0) return false;
-          uint32 size = static_cast<uint32>(
+          if (static_cast<int32_t>(length) < 0) return false;
+          uint32_t size = static_cast<uint32_t>(
               length + io::CodedOutputStream::VarintSize32(length));
           message_data.resize(size);
-          auto ptr = reinterpret_cast<uint8*>(&message_data[0]);
+          auto ptr = reinterpret_cast<uint8_t*>(&message_data[0]);
           ptr = io::CodedOutputStream::WriteVarint32ToArray(length, ptr);
           if (!input->ReadRaw(ptr, length)) return false;
+          state = State::kHasPayload;
         } else {
-          // Already saw type_id, so we can parse this directly.
-          if (!ms.ParseField(last_type_id, input)) {
-            return false;
-          }
+          if (!ms.SkipField(tag, input)) return false;
         }
 
         break;
diff --git protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_unittest.cc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.cc
index 4393066..f1ed951 100644
--- protobuf-3.17.3protobuf-3.17.3/src/google/protobuf/wire_format_unittest.cc
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.cc
@@ -34,1553 +34,33 @@
 
 #include <google/protobuf/wire_format.h>
 
-#include <google/protobuf/stubs/logging.h>
-#include <google/protobuf/stubs/common.h>
-#include <google/protobuf/test_util.h>
-#include <google/protobuf/test_util2.h>
 #include <google/protobuf/unittest.pb.h>
 #include <google/protobuf/unittest_mset.pb.h>
 #include <google/protobuf/unittest_mset_wire_format.pb.h>
 #include <google/protobuf/unittest_proto3_arena.pb.h>
-#include <google/protobuf/io/coded_stream.h>
-#include <google/protobuf/io/zero_copy_stream_impl.h>
-#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
-#include <google/protobuf/descriptor.h>
-#include <google/protobuf/wire_format_lite.h>
-#include <google/protobuf/testing/googletest.h>
-#include <google/protobuf/stubs/logging.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
-#include <google/protobuf/stubs/casts.h>
-#include <google/protobuf/stubs/strutil.h>
-#include <google/protobuf/stubs/stl_util.h>
 
+#define UNITTEST ::protobuf_unittest
+#define UNITTEST_IMPORT ::protobuf_unittest_import
+#define UNITTEST_PACKAGE_NAME "protobuf_unittest"
+#define PROTO2_WIREFORMAT_UNITTEST ::proto2_wireformat_unittest
+#define PROTO3_ARENA_UNITTEST ::proto3_arena_unittest
+
+// Must include after defining UNITTEST, etc.
 // clang-format off
-#include <google/protobuf/port_def.inc>
+#include <google/protobuf/test_util.inc>
+#include <google/protobuf/wire_format_unittest.inc>
 // clang-format on
 
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
 namespace google {
 namespace protobuf {
 namespace internal {
 namespace {
 
-TEST(WireFormatTest, EnumsInSync) {
-  // Verify that WireFormatLite::FieldType and WireFormatLite::CppType match
-  // FieldDescriptor::Type and FieldDescriptor::CppType.
-
-  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_TYPE),
-            implicit_cast<int>(WireFormatLite::MAX_FIELD_TYPE));
-  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_CPPTYPE),
-            implicit_cast<int>(WireFormatLite::MAX_CPPTYPE));
-
-  for (int i = 1; i <= WireFormatLite::MAX_FIELD_TYPE; i++) {
-    EXPECT_EQ(implicit_cast<int>(FieldDescriptor::TypeToCppType(
-                  static_cast<FieldDescriptor::Type>(i))),
-              implicit_cast<int>(WireFormatLite::FieldTypeToCppType(
-                  static_cast<WireFormatLite::FieldType>(i))));
-  }
-}
-
-TEST(WireFormatTest, MaxFieldNumber) {
-  // Make sure the max field number constant is accurate.
-  EXPECT_EQ((1 << (32 - WireFormatLite::kTagTypeBits)) - 1,
-            FieldDescriptor::kMaxNumber);
-}
-
-TEST(WireFormatTest, Parse) {
-  unittest::TestAllTypes source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetAllFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectAllFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParseExtensions) {
-  unittest::TestAllExtensions source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetAllExtensions(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectAllExtensionsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePacked) {
-  unittest::TestPackedTypes source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetPackedFields(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePackedFromUnpacked) {
-  // Serialize using the generated code.
-  unittest::TestUnpackedTypes source;
-  TestUtil::SetUnpackedFields(&source);
-  std::string data = source.SerializeAsString();
-
-  // Parse using WireFormat.
-  unittest::TestPackedTypes dest;
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParseUnpackedFromPacked) {
-  // Serialize using the generated code.
-  unittest::TestPackedTypes source;
-  TestUtil::SetPackedFields(&source);
-  std::string data = source.SerializeAsString();
-
-  // Parse using WireFormat.
-  unittest::TestUnpackedTypes dest;
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectUnpackedFieldsSet(dest);
-}
-
-TEST(WireFormatTest, ParsePackedExtensions) {
-  unittest::TestPackedExtensions source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetPackedExtensions(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectPackedExtensionsSet(dest);
-}
-
-TEST(WireFormatTest, ParseOneof) {
-  unittest::TestOneof2 source, dest;
-  std::string data;
-
-  // Serialize using the generated code.
-  TestUtil::SetOneof1(&source);
-  source.SerializeToString(&data);
-
-  // Parse using WireFormat.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &dest);
-
-  // Check.
-  TestUtil::ExpectOneofSet1(dest);
-}
-
-TEST(WireFormatTest, OneofOnlySetLast) {
-  unittest::TestOneofBackwardsCompatible source;
-  unittest::TestOneof oneof_dest;
-  std::string data;
-
-  // Set two fields
-  source.set_foo_int(100);
-  source.set_foo_string("101");
-
-  // Serialize and parse to oneof message. Generated serializer may not order
-  // fields in tag order. Use WireFormat::SerializeWithCachedSizes instead as
-  // it sorts fields beforehand.
-  {
-    io::StringOutputStream raw_output(&data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(source, source.ByteSizeLong(),
-                                         &output);
-    ASSERT_FALSE(output.HadError());
-  }
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream input(&raw_input);
-  WireFormat::ParseAndMergePartial(&input, &oneof_dest);
-
-  // Only the last field is set.
-  EXPECT_FALSE(oneof_dest.has_foo_int());
-  EXPECT_TRUE(oneof_dest.has_foo_string());
-}
-
-TEST(WireFormatTest, ByteSize) {
-  unittest::TestAllTypes message;
-  TestUtil::SetAllFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizeExtensions) {
-  unittest::TestAllExtensions message;
-  TestUtil::SetAllExtensions(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizePacked) {
-  unittest::TestPackedTypes message;
-  TestUtil::SetPackedFields(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizePackedExtensions) {
-  unittest::TestPackedExtensions message;
-  TestUtil::SetPackedExtensions(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, ByteSizeOneof) {
-  unittest::TestOneof2 message;
-  TestUtil::SetOneof1(&message);
-
-  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
-  message.Clear();
-
-  EXPECT_EQ(0, message.ByteSizeLong());
-  EXPECT_EQ(0, WireFormat::ByteSize(message));
-}
-
-TEST(WireFormatTest, Serialize) {
-  unittest::TestAllTypes message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllFields(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeExtensions) {
-  unittest::TestAllExtensions message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllExtensions(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeFieldsAndExtensions) {
-  unittest::TestFieldOrderings message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetAllFieldsAndExtensions(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, SerializeOneof) {
-  unittest::TestOneof2 message;
-  std::string generated_data;
-  std::string dynamic_data;
-
-  TestUtil::SetOneof1(&message);
-  size_t size = message.ByteSizeLong();
-
-  // Serialize using the generated code.
-  {
-    io::StringOutputStream raw_output(&generated_data);
-    io::CodedOutputStream output(&raw_output);
-    message.SerializeWithCachedSizes(&output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Serialize using WireFormat.
-  {
-    io::StringOutputStream raw_output(&dynamic_data);
-    io::CodedOutputStream output(&raw_output);
-    WireFormat::SerializeWithCachedSizes(message, size, &output);
-    ASSERT_FALSE(output.HadError());
-  }
-
-  // Should parse to the same message.
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
-  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
-}
-
-TEST(WireFormatTest, ParseMultipleExtensionRanges) {
-  // Make sure we can parse a message that contains multiple extensions ranges.
-  unittest::TestFieldOrderings source;
-  std::string data;
-
-  TestUtil::SetAllFieldsAndExtensions(&source);
-  source.SerializeToString(&data);
-
-  {
-    unittest::TestFieldOrderings dest;
-    EXPECT_TRUE(dest.ParseFromString(data));
-    EXPECT_EQ(source.DebugString(), dest.DebugString());
-  }
-
-  // Also test using reflection-based parsing.
-  {
-    unittest::TestFieldOrderings dest;
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream coded_input(&raw_input);
-    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&coded_input, &dest));
-    EXPECT_EQ(source.DebugString(), dest.DebugString());
-  }
-}
-
-const int kUnknownTypeId = 1550055;
-
-TEST(WireFormatTest, SerializeMessageSet) {
-  // Set up a TestMessageSet with two known messages and an unknown one.
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension)
-      ->set_i(123);
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension2::message_set_extension)
-      ->set_str("foo");
-  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
-                                                           "bar");
-
-  std::string data;
-  ASSERT_TRUE(message_set.SerializeToString(&data));
-
-  // Parse back using RawMessageSet and check the contents.
-  unittest::RawMessageSet raw;
-  ASSERT_TRUE(raw.ParseFromString(data));
-
-  EXPECT_EQ(0, raw.unknown_fields().field_count());
-
-  ASSERT_EQ(3, raw.item_size());
-  EXPECT_EQ(
-      unittest::TestMessageSetExtension1::descriptor()->extension(0)->number(),
-      raw.item(0).type_id());
-  EXPECT_EQ(
-      unittest::TestMessageSetExtension2::descriptor()->extension(0)->number(),
-      raw.item(1).type_id());
-  EXPECT_EQ(kUnknownTypeId, raw.item(2).type_id());
-
-  unittest::TestMessageSetExtension1 message1;
-  EXPECT_TRUE(message1.ParseFromString(raw.item(0).message()));
-  EXPECT_EQ(123, message1.i());
-
-  unittest::TestMessageSetExtension2 message2;
-  EXPECT_TRUE(message2.ParseFromString(raw.item(1).message()));
-  EXPECT_EQ("foo", message2.str());
-
-  EXPECT_EQ("bar", raw.item(2).message());
-}
-
-TEST(WireFormatTest, SerializeMessageSetVariousWaysAreEqual) {
-  // Serialize a MessageSet to a stream and to a flat array using generated
-  // code, and also using WireFormat, and check that the results are equal.
-  // Set up a TestMessageSet with two known messages and an unknown one, as
-  // above.
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension)
-      ->set_i(123);
-  message_set
-      .MutableExtension(
-          unittest::TestMessageSetExtension2::message_set_extension)
-      ->set_str("foo");
-  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
-                                                           "bar");
-
-  size_t size = message_set.ByteSizeLong();
-  EXPECT_EQ(size, message_set.GetCachedSize());
-  ASSERT_EQ(size, WireFormat::ByteSize(message_set));
-
-  std::string flat_data;
-  std::string stream_data;
-  std::string dynamic_data;
-  flat_data.resize(size);
-  stream_data.resize(size);
-
-  // Serialize to flat array
-  {
-    uint8* target = reinterpret_cast<uint8*>(::google::protobuf::string_as_array(&flat_data));
-    uint8* end = message_set.SerializeWithCachedSizesToArray(target);
-    EXPECT_EQ(size, end - target);
-  }
-
-  // Serialize to buffer
-  {
-    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&stream_data), size,
-                                       1);
-    io::CodedOutputStream output_stream(&array_stream);
-    message_set.SerializeWithCachedSizes(&output_stream);
-    ASSERT_FALSE(output_stream.HadError());
-  }
-
-  // Serialize to buffer with WireFormat.
-  {
-    io::StringOutputStream string_stream(&dynamic_data);
-    io::CodedOutputStream output_stream(&string_stream);
-    WireFormat::SerializeWithCachedSizes(message_set, size, &output_stream);
-    ASSERT_FALSE(output_stream.HadError());
-  }
-
-  EXPECT_TRUE(flat_data == stream_data);
-  EXPECT_TRUE(flat_data == dynamic_data);
-}
-
-TEST(WireFormatTest, ParseMessageSet) {
-  // Set up a RawMessageSet with two known messages and an unknown one.
-  unittest::RawMessageSet raw;
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(unittest::TestMessageSetExtension1::descriptor()
-                          ->extension(0)
-                          ->number());
-    unittest::TestMessageSetExtension1 message;
-    message.set_i(123);
-    message.SerializeToString(item->mutable_message());
-  }
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(unittest::TestMessageSetExtension2::descriptor()
-                          ->extension(0)
-                          ->number());
-    unittest::TestMessageSetExtension2 message;
-    message.set_str("foo");
-    message.SerializeToString(item->mutable_message());
-  }
-
-  {
-    unittest::RawMessageSet::Item* item = raw.add_item();
-    item->set_type_id(kUnknownTypeId);
-    item->set_message("bar");
-  }
-
-  std::string data;
-  ASSERT_TRUE(raw.SerializeToString(&data));
-
-  // Parse as a TestMessageSet and check the contents.
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  ASSERT_TRUE(message_set.ParseFromString(data));
-
-  EXPECT_EQ(123,
-            message_set
-                .GetExtension(
-                    unittest::TestMessageSetExtension1::message_set_extension)
-                .i());
-  EXPECT_EQ("foo",
-            message_set
-                .GetExtension(
-                    unittest::TestMessageSetExtension2::message_set_extension)
-                .str());
-
-  ASSERT_EQ(1, message_set.unknown_fields().field_count());
-  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED,
-            message_set.unknown_fields().field(0).type());
-  EXPECT_EQ("bar", message_set.unknown_fields().field(0).length_delimited());
-
-  // Also parse using WireFormat.
-  proto2_wireformat_unittest::TestMessageSet dynamic_message_set;
-  io::CodedInputStream input(reinterpret_cast<const uint8*>(data.data()),
-                             data.size());
-  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &dynamic_message_set));
-  EXPECT_EQ(message_set.DebugString(), dynamic_message_set.DebugString());
-}
-
-TEST(WireFormatTest, ParseMessageSetWithReverseTagOrder) {
-  std::string data;
-  {
-    unittest::TestMessageSetExtension1 message;
-    message.set_i(123);
-    // Build a MessageSet manually with its message content put before its
-    // type_id.
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    coded_output.WriteTag(WireFormatLite::kMessageSetItemStartTag);
-    // Write the message content first.
-    WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
-                             WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                             &coded_output);
-    coded_output.WriteVarint32(message.ByteSizeLong());
-    message.SerializeWithCachedSizes(&coded_output);
-    // Write the type id.
-    uint32 type_id = message.GetDescriptor()->extension(0)->number();
-    WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber,
-                                type_id, &coded_output);
-    coded_output.WriteTag(WireFormatLite::kMessageSetItemEndTag);
-  }
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    ASSERT_TRUE(message_set.ParseFromString(data));
-
-    EXPECT_EQ(123,
-              message_set
-                  .GetExtension(
-                      unittest::TestMessageSetExtension1::message_set_extension)
-                  .i());
-  }
-  {
-    // Test parse the message via Reflection.
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    io::CodedInputStream input(reinterpret_cast<const uint8*>(data.data()),
-                               data.size());
-    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&input, &message_set));
-    EXPECT_TRUE(input.ConsumedEntireMessage());
-
-    EXPECT_EQ(123,
-              message_set
-                  .GetExtension(
-                      unittest::TestMessageSetExtension1::message_set_extension)
-                  .i());
-  }
-}
-
-void SerializeReverseOrder(
-    const proto2_wireformat_unittest::TestMessageSet& mset,
-    io::CodedOutputStream* coded_output);
-
-void SerializeReverseOrder(const unittest::TestMessageSetExtension1& message,
-                           io::CodedOutputStream* coded_output) {
-  WireFormatLite::WriteTag(15,  // i
-                           WireFormatLite::WIRETYPE_VARINT, coded_output);
-  coded_output->WriteVarint64(message.i());
-  WireFormatLite::WriteTag(16,  // recursive
-                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                           coded_output);
-  coded_output->WriteVarint32(message.recursive().GetCachedSize());
-  SerializeReverseOrder(message.recursive(), coded_output);
-}
-
-void SerializeReverseOrder(
-    const proto2_wireformat_unittest::TestMessageSet& mset,
-    io::CodedOutputStream* coded_output) {
-  if (!mset.HasExtension(
-          unittest::TestMessageSetExtension1::message_set_extension))
-    return;
-  coded_output->WriteTag(WireFormatLite::kMessageSetItemStartTag);
-  // Write the message content first.
-  WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
-                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
-                           coded_output);
-  auto& message = mset.GetExtension(
-      unittest::TestMessageSetExtension1::message_set_extension);
-  coded_output->WriteVarint32(message.GetCachedSize());
-  SerializeReverseOrder(message, coded_output);
-  // Write the type id.
-  uint32 type_id = message.GetDescriptor()->extension(0)->number();
-  WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber, type_id,
-                              coded_output);
-  coded_output->WriteTag(WireFormatLite::kMessageSetItemEndTag);
-}
-
-TEST(WireFormatTest, ParseMessageSetWithDeepRecReverseOrder) {
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < 200; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    message_set.ByteSizeLong();
-    // Serialize with reverse payload tag order
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    SerializeReverseOrder(message_set, &coded_output);
-  }
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseFailMalformedMessageSet) {
-  constexpr int kDepth = 5;
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < kDepth; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    auto m = mset->MutableExtension(
-        unittest::TestMessageSetExtension1::message_set_extension);
-    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
-    m->set_i(-1);
-
-    EXPECT_TRUE(message_set.SerializeToString(&data));
-    // Make the proto mal-formed.
-    data[data.size() - 2 - kDepth] = 0xFF;
-  }
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseFailMalformedMessageSetReverseOrder) {
-  constexpr int kDepth = 5;
-  std::string data;
-  {
-    proto2_wireformat_unittest::TestMessageSet message_set;
-    proto2_wireformat_unittest::TestMessageSet* mset = &message_set;
-    for (int i = 0; i < kDepth; i++) {
-      auto m = mset->MutableExtension(
-          unittest::TestMessageSetExtension1::message_set_extension);
-      m->set_i(i);
-      mset = m->mutable_recursive();
-    }
-    auto m = mset->MutableExtension(
-        unittest::TestMessageSetExtension1::message_set_extension);
-    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
-    m->set_i(-1);
-    // SerializeReverseOrder() assumes "recursive" is always present.
-    m->mutable_recursive();
-
-    message_set.ByteSizeLong();
-
-    // Serialize with reverse payload tag order
-    io::StringOutputStream output_stream(&data);
-    io::CodedOutputStream coded_output(&output_stream);
-    SerializeReverseOrder(message_set, &coded_output);
-  }
-
-  // Make varint for -1 malformed.
-  data[data.size() - 5 * (kDepth + 1) - 4] = 0xFF;
-
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  EXPECT_FALSE(message_set.ParseFromString(data));
-}
-
-TEST(WireFormatTest, ParseBrokenMessageSet) {
-  proto2_wireformat_unittest::TestMessageSet message_set;
-  std::string input("goodbye");  // Invalid wire format data.
-  EXPECT_FALSE(message_set.ParseFromString(input));
-}
-
-TEST(WireFormatTest, RecursionLimit) {
-  unittest::TestRecursiveMessage message;
-  message.mutable_a()->mutable_a()->mutable_a()->mutable_a()->set_i(1);
-  std::string data;
-  message.SerializeToString(&data);
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(4);
-    unittest::TestRecursiveMessage message2;
-    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
-  }
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(3);
-    unittest::TestRecursiveMessage message2;
-    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
-  }
-}
-
-TEST(WireFormatTest, UnknownFieldRecursionLimit) {
-  unittest::TestEmptyMessage message;
-  message.mutable_unknown_fields()
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddGroup(1234)
-      ->AddVarint(1234, 123);
-  std::string data;
-  message.SerializeToString(&data);
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(4);
-    unittest::TestEmptyMessage message2;
-    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
-  }
-
-  {
-    io::ArrayInputStream raw_input(data.data(), data.size());
-    io::CodedInputStream input(&raw_input);
-    input.SetRecursionLimit(3);
-    unittest::TestEmptyMessage message2;
-    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
-  }
-}
-
-TEST(WireFormatTest, ZigZag) {
-// avoid line-wrapping
-#define LL(x) static_cast<int64_t>(ULL(x))
-#define ULL(x) uint64_t{x##u}
-#define ZigZagEncode32(x) WireFormatLite::ZigZagEncode32(x)
-#define ZigZagDecode32(x) WireFormatLite::ZigZagDecode32(x)
-#define ZigZagEncode64(x) WireFormatLite::ZigZagEncode64(x)
-#define ZigZagDecode64(x) WireFormatLite::ZigZagDecode64(x)
-
-  EXPECT_EQ(0u, ZigZagEncode32(0));
-  EXPECT_EQ(1u, ZigZagEncode32(-1));
-  EXPECT_EQ(2u, ZigZagEncode32(1));
-  EXPECT_EQ(3u, ZigZagEncode32(-2));
-  EXPECT_EQ(0x7FFFFFFEu, ZigZagEncode32(0x3FFFFFFF));
-  EXPECT_EQ(0x7FFFFFFFu, ZigZagEncode32(0xC0000000));
-  EXPECT_EQ(0xFFFFFFFEu, ZigZagEncode32(0x7FFFFFFF));
-  EXPECT_EQ(0xFFFFFFFFu, ZigZagEncode32(0x80000000));
-
-  EXPECT_EQ(0, ZigZagDecode32(0u));
-  EXPECT_EQ(-1, ZigZagDecode32(1u));
-  EXPECT_EQ(1, ZigZagDecode32(2u));
-  EXPECT_EQ(-2, ZigZagDecode32(3u));
-  EXPECT_EQ(0x3FFFFFFF, ZigZagDecode32(0x7FFFFFFEu));
-  EXPECT_EQ(0xC0000000, ZigZagDecode32(0x7FFFFFFFu));
-  EXPECT_EQ(0x7FFFFFFF, ZigZagDecode32(0xFFFFFFFEu));
-  EXPECT_EQ(0x80000000, ZigZagDecode32(0xFFFFFFFFu));
-
-  EXPECT_EQ(0u, ZigZagEncode64(0));
-  EXPECT_EQ(1u, ZigZagEncode64(-1));
-  EXPECT_EQ(2u, ZigZagEncode64(1));
-  EXPECT_EQ(3u, ZigZagEncode64(-2));
-  EXPECT_EQ(ULL(0x000000007FFFFFFE), ZigZagEncode64(LL(0x000000003FFFFFFF)));
-  EXPECT_EQ(ULL(0x000000007FFFFFFF), ZigZagEncode64(LL(0xFFFFFFFFC0000000)));
-  EXPECT_EQ(ULL(0x00000000FFFFFFFE), ZigZagEncode64(LL(0x000000007FFFFFFF)));
-  EXPECT_EQ(ULL(0x00000000FFFFFFFF), ZigZagEncode64(LL(0xFFFFFFFF80000000)));
-  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFE), ZigZagEncode64(LL(0x7FFFFFFFFFFFFFFF)));
-  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFF), ZigZagEncode64(LL(0x8000000000000000)));
-
-  EXPECT_EQ(0, ZigZagDecode64(0u));
-  EXPECT_EQ(-1, ZigZagDecode64(1u));
-  EXPECT_EQ(1, ZigZagDecode64(2u));
-  EXPECT_EQ(-2, ZigZagDecode64(3u));
-  EXPECT_EQ(LL(0x000000003FFFFFFF), ZigZagDecode64(ULL(0x000000007FFFFFFE)));
-  EXPECT_EQ(LL(0xFFFFFFFFC0000000), ZigZagDecode64(ULL(0x000000007FFFFFFF)));
-  EXPECT_EQ(LL(0x000000007FFFFFFF), ZigZagDecode64(ULL(0x00000000FFFFFFFE)));
-  EXPECT_EQ(LL(0xFFFFFFFF80000000), ZigZagDecode64(ULL(0x00000000FFFFFFFF)));
-  EXPECT_EQ(LL(0x7FFFFFFFFFFFFFFF), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFE)));
-  EXPECT_EQ(LL(0x8000000000000000), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFF)));
-
-  // Some easier-to-verify round-trip tests.  The inputs (other than 0, 1, -1)
-  // were chosen semi-randomly via keyboard bashing.
-  EXPECT_EQ(0, ZigZagDecode32(ZigZagEncode32(0)));
-  EXPECT_EQ(1, ZigZagDecode32(ZigZagEncode32(1)));
-  EXPECT_EQ(-1, ZigZagDecode32(ZigZagEncode32(-1)));
-  EXPECT_EQ(14927, ZigZagDecode32(ZigZagEncode32(14927)));
-  EXPECT_EQ(-3612, ZigZagDecode32(ZigZagEncode32(-3612)));
-
-  EXPECT_EQ(0, ZigZagDecode64(ZigZagEncode64(0)));
-  EXPECT_EQ(1, ZigZagDecode64(ZigZagEncode64(1)));
-  EXPECT_EQ(-1, ZigZagDecode64(ZigZagEncode64(-1)));
-  EXPECT_EQ(14927, ZigZagDecode64(ZigZagEncode64(14927)));
-  EXPECT_EQ(-3612, ZigZagDecode64(ZigZagEncode64(-3612)));
-
-  EXPECT_EQ(LL(856912304801416),
-            ZigZagDecode64(ZigZagEncode64(LL(856912304801416))));
-  EXPECT_EQ(LL(-75123905439571256),
-            ZigZagDecode64(ZigZagEncode64(LL(-75123905439571256))));
-}
-
-TEST(WireFormatTest, RepeatedScalarsDifferentTagSizes) {
-  // At one point checks would trigger when parsing repeated fixed scalar
-  // fields.
-  protobuf_unittest::TestRepeatedScalarDifferentTagSizes msg1, msg2;
-  for (int i = 0; i < 100; ++i) {
-    msg1.add_repeated_fixed32(i);
-    msg1.add_repeated_int32(i);
-    msg1.add_repeated_fixed64(i);
-    msg1.add_repeated_int64(i);
-    msg1.add_repeated_float(i);
-    msg1.add_repeated_uint64(i);
-  }
-
-  // Make sure that we have a variety of tag sizes.
-  const Descriptor* desc = msg1.GetDescriptor();
-  const FieldDescriptor* field;
-  field = desc->FindFieldByName("repeated_fixed32");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_int32");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_fixed64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_int64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_float");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
-  field = desc->FindFieldByName("repeated_uint64");
-  ASSERT_TRUE(field != NULL);
-  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
-
-  EXPECT_TRUE(msg2.ParseFromString(msg1.SerializeAsString()));
-  EXPECT_EQ(msg1.DebugString(), msg2.DebugString());
-}
-
-TEST(WireFormatTest, CompatibleTypes) {
-  const int64 data = 0x100000000LL;
-  unittest::Int64Message msg1;
-  msg1.set_data(data);
-  std::string serialized;
-  msg1.SerializeToString(&serialized);
-
-  // Test int64 is compatible with bool
-  unittest::BoolMessage msg2;
-  ASSERT_TRUE(msg2.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<bool>(data), msg2.data());
-
-  // Test int64 is compatible with uint64
-  unittest::Uint64Message msg3;
-  ASSERT_TRUE(msg3.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<uint64>(data), msg3.data());
-
-  // Test int64 is compatible with int32
-  unittest::Int32Message msg4;
-  ASSERT_TRUE(msg4.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<int32>(data), msg4.data());
-
-  // Test int64 is compatible with uint32
-  unittest::Uint32Message msg5;
-  ASSERT_TRUE(msg5.ParseFromString(serialized));
-  ASSERT_EQ(static_cast<uint32>(data), msg5.data());
-}
-
-class Proto3PrimitiveRepeatedWireFormatTest : public ::testing::Test {
- protected:
-  Proto3PrimitiveRepeatedWireFormatTest()
-      : packedTestAllTypes_(
-            "\xFA\x01\x01\x01"
-            "\x82\x02\x01\x01"
-            "\x8A\x02\x01\x01"
-            "\x92\x02\x01\x01"
-            "\x9A\x02\x01\x02"
-            "\xA2\x02\x01\x02"
-            "\xAA\x02\x04\x01\x00\x00\x00"
-            "\xB2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xBA\x02\x04\x01\x00\x00\x00"
-            "\xC2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xCA\x02\x04\x00\x00\x80\x3f"
-            "\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\xDA\x02\x01\x01"
-            "\x9A\x03\x01\x01",
-            86),
-        packedTestUnpackedTypes_(
-            "\x0A\x01\x01"
-            "\x12\x01\x01"
-            "\x1A\x01\x01"
-            "\x22\x01\x01"
-            "\x2A\x01\x02"
-            "\x32\x01\x02"
-            "\x3A\x04\x01\x00\x00\x00"
-            "\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x4A\x04\x01\x00\x00\x00"
-            "\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x5A\x04\x00\x00\x80\x3f"
-            "\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\x6A\x01\x01"
-            "\x72\x01\x01",
-            72),
-        unpackedTestAllTypes_(
-            "\xF8\x01\x01"
-            "\x80\x02\x01"
-            "\x88\x02\x01"
-            "\x90\x02\x01"
-            "\x98\x02\x02"
-            "\xA0\x02\x02"
-            "\xAD\x02\x01\x00\x00\x00"
-            "\xB1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xBD\x02\x01\x00\x00\x00"
-            "\xC1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\xCD\x02\x00\x00\x80\x3f"
-            "\xD1\x02\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\xD8\x02\x01"
-            "\x98\x03\x01",
-            72),
-        unpackedTestUnpackedTypes_(
-            "\x08\x01"
-            "\x10\x01"
-            "\x18\x01"
-            "\x20\x01"
-            "\x28\x02"
-            "\x30\x02"
-            "\x3D\x01\x00\x00\x00"
-            "\x41\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x4D\x01\x00\x00\x00"
-            "\x51\x01\x00\x00\x00\x00\x00\x00\x00"
-            "\x5D\x00\x00\x80\x3f"
-            "\x61\x00\x00\x00\x00\x00\x00\xf0\x3f"
-            "\x68\x01"
-            "\x70\x01",
-            58) {}
-  template <class Proto>
-  void SetProto3PrimitiveRepeatedFields(Proto* message) {
-    message->add_repeated_int32(1);
-    message->add_repeated_int64(1);
-    message->add_repeated_uint32(1);
-    message->add_repeated_uint64(1);
-    message->add_repeated_sint32(1);
-    message->add_repeated_sint64(1);
-    message->add_repeated_fixed32(1);
-    message->add_repeated_fixed64(1);
-    message->add_repeated_sfixed32(1);
-    message->add_repeated_sfixed64(1);
-    message->add_repeated_float(1.0);
-    message->add_repeated_double(1.0);
-    message->add_repeated_bool(true);
-    message->add_repeated_nested_enum(proto3_arena_unittest::TestAllTypes::FOO);
-  }
-
-  template <class Proto>
-  void ExpectProto3PrimitiveRepeatedFieldsSet(const Proto& message) {
-    EXPECT_EQ(1, message.repeated_int32(0));
-    EXPECT_EQ(1, message.repeated_int64(0));
-    EXPECT_EQ(1, message.repeated_uint32(0));
-    EXPECT_EQ(1, message.repeated_uint64(0));
-    EXPECT_EQ(1, message.repeated_sint32(0));
-    EXPECT_EQ(1, message.repeated_sint64(0));
-    EXPECT_EQ(1, message.repeated_fixed32(0));
-    EXPECT_EQ(1, message.repeated_fixed64(0));
-    EXPECT_EQ(1, message.repeated_sfixed32(0));
-    EXPECT_EQ(1, message.repeated_sfixed64(0));
-    EXPECT_EQ(1.0, message.repeated_float(0));
-    EXPECT_EQ(1.0, message.repeated_double(0));
-    EXPECT_EQ(true, message.repeated_bool(0));
-    EXPECT_EQ(proto3_arena_unittest::TestAllTypes::FOO,
-              message.repeated_nested_enum(0));
-  }
-
-  template <class Proto>
-  void TestSerialization(Proto* message, const std::string& expected) {
-    SetProto3PrimitiveRepeatedFields(message);
-
-    size_t size = message->ByteSizeLong();
-
-    // Serialize using the generated code.
-    std::string generated_data;
-    {
-      io::StringOutputStream raw_output(&generated_data);
-      io::CodedOutputStream output(&raw_output);
-      message->SerializeWithCachedSizes(&output);
-      ASSERT_FALSE(output.HadError());
-    }
-    EXPECT_TRUE(TestUtil::EqualsToSerialized(*message, generated_data));
-
-    // Serialize using the dynamic code.
-    std::string dynamic_data;
-    {
-      io::StringOutputStream raw_output(&dynamic_data);
-      io::CodedOutputStream output(&raw_output);
-      WireFormat::SerializeWithCachedSizes(*message, size, &output);
-      ASSERT_FALSE(output.HadError());
-    }
-    EXPECT_TRUE(expected == dynamic_data);
-  }
-
-  template <class Proto>
-  void TestParsing(Proto* message, const std::string& compatible_data) {
-    message->Clear();
-    message->ParseFromString(compatible_data);
-    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
-
-    message->Clear();
-    io::CodedInputStream input(
-        reinterpret_cast<const uint8*>(compatible_data.data()),
-        compatible_data.size());
-    WireFormat::ParseAndMergePartial(&input, message);
-    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
-  }
-
-  const std::string packedTestAllTypes_;
-  const std::string packedTestUnpackedTypes_;
-  const std::string unpackedTestAllTypes_;
-  const std::string unpackedTestUnpackedTypes_;
-};
-
-TEST_F(Proto3PrimitiveRepeatedWireFormatTest, Proto3PrimitiveRepeated) {
-  proto3_arena_unittest::TestAllTypes packed_message;
-  proto3_arena_unittest::TestUnpackedTypes unpacked_message;
-  TestSerialization(&packed_message, packedTestAllTypes_);
-  TestParsing(&packed_message, packedTestAllTypes_);
-  TestParsing(&packed_message, unpackedTestAllTypes_);
-  TestSerialization(&unpacked_message, unpackedTestUnpackedTypes_);
-  TestParsing(&unpacked_message, packedTestUnpackedTypes_);
-  TestParsing(&unpacked_message, unpackedTestUnpackedTypes_);
-}
-
-class WireFormatInvalidInputTest : public testing::Test {
- protected:
-  // Make a serialized TestAllTypes in which the field optional_nested_message
-  // contains exactly the given bytes, which may be invalid.
-  std::string MakeInvalidEmbeddedMessage(const char* bytes, int size) {
-    const FieldDescriptor* field =
-        unittest::TestAllTypes::descriptor()->FindFieldByName(
-            "optional_nested_message");
-    GOOGLE_CHECK(field != NULL);
-
-    std::string result;
-
-    {
-      io::StringOutputStream raw_output(&result);
-      io::CodedOutputStream output(&raw_output);
-
-      WireFormatLite::WriteBytes(field->number(), std::string(bytes, size),
-                                 &output);
-    }
-
-    return result;
-  }
-
-  // Make a serialized TestAllTypes in which the field optionalgroup
-  // contains exactly the given bytes -- which may be invalid -- and
-  // possibly no end tag.
-  std::string MakeInvalidGroup(const char* bytes, int size,
-                               bool include_end_tag) {
-    const FieldDescriptor* field =
-        unittest::TestAllTypes::descriptor()->FindFieldByName("optionalgroup");
-    GOOGLE_CHECK(field != NULL);
-
-    std::string result;
-
-    {
-      io::StringOutputStream raw_output(&result);
-      io::CodedOutputStream output(&raw_output);
-
-      output.WriteVarint32(WireFormat::MakeTag(field));
-      output.WriteString(std::string(bytes, size));
-      if (include_end_tag) {
-        output.WriteVarint32(WireFormatLite::MakeTag(
-            field->number(), WireFormatLite::WIRETYPE_END_GROUP));
-      }
-    }
-
-    return result;
-  }
-};
-
-TEST_F(WireFormatInvalidInputTest, InvalidSubMessage) {
-  unittest::TestAllTypes message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidEmbeddedMessage("", 0)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\0", 1)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\200", 1)));
-
-  // The byte is an endgroup tag, but we aren't parsing a group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\014", 1)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\017", 1)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidMessageWithExtraZero) {
-  std::string data;
-  {
-    // Serialize a valid proto
-    unittest::TestAllTypes message;
-    message.set_optional_int32(1);
-    message.SerializeToString(&data);
-    data.push_back(0);  // Append invalid zero tag
-  }
-
-  // Control case.
-  {
-    io::ArrayInputStream ais(data.data(), data.size());
-    io::CodedInputStream is(&ais);
-    unittest::TestAllTypes message;
-    // It should fail but currently passes.
-    EXPECT_TRUE(message.MergePartialFromCodedStream(&is));
-    // Parsing from the string should fail.
-    EXPECT_FALSE(message.ParseFromString(data));
-  }
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidGroup) {
-  unittest::TestAllTypes message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
-
-  // Missing end tag.  Groups cannot end at EOF.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
-
-  // The byte is an endgroup tag, but not the right one for this group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidUnknownGroup) {
-  // Use TestEmptyMessage so that the group made by MakeInvalidGroup will not
-  // be a known tag number.
-  unittest::TestEmptyMessage message;
-
-  // Control case.
-  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
-
-  // Missing end tag.  Groups cannot end at EOF.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
-
-  // The byte is a valid varint, but not a valid tag (zero).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
-
-  // The byte is a malformed varint.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
-
-  // The byte is an endgroup tag, but not the right one for this group.
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
-
-  // The byte is a valid varint but not a valid tag (bad wire type).
-  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
-}
-
-TEST_F(WireFormatInvalidInputTest, InvalidStringInUnknownGroup) {
-  // Test a bug fix:  SkipMessage should fail if the message contains a
-  // string whose length would extend beyond the message end.
-
-  unittest::TestAllTypes message;
-  message.set_optional_string("foo foo foo foo");
-  std::string data;
-  message.SerializeToString(&data);
-
-  // Chop some bytes off the end.
-  data.resize(data.size() - 4);
-
-  // Try to skip it.  Note that the bug was only present when parsing to an
-  // UnknownFieldSet.
-  io::ArrayInputStream raw_input(data.data(), data.size());
-  io::CodedInputStream coded_input(&raw_input);
-  UnknownFieldSet unknown_fields;
-  EXPECT_FALSE(WireFormat::SkipMessage(&coded_input, &unknown_fields));
-}
-
-// Test differences between string and bytes.
-// Value of a string type must be valid UTF-8 string.  When UTF-8
-// validation is enabled (GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED):
-// WriteInvalidUTF8String:  see error message.
-// ReadInvalidUTF8String:  see error message.
-// WriteValidUTF8String: fine.
-// ReadValidUTF8String:  fine.
-// WriteAnyBytes: fine.
-// ReadAnyBytes: fine.
-const char* kInvalidUTF8String = "Invalid UTF-8: \xA0\xB0\xC0\xD0";
-// This used to be "Valid UTF-8: \x01\x02\u8C37\u6B4C", but MSVC seems to
-// interpret \u differently from GCC.
-const char* kValidUTF8String = "Valid UTF-8: \x01\x02\350\260\267\346\255\214";
-
-template <typename T>
-bool WriteMessage(const char* value, T* message, std::string* wire_buffer) {
-  message->set_data(value);
-  wire_buffer->clear();
-  message->AppendToString(wire_buffer);
-  return (wire_buffer->size() > 0);
-}
-
-template <typename T>
-bool ReadMessage(const std::string& wire_buffer, T* message) {
-  return message->ParseFromArray(wire_buffer.data(), wire_buffer.size());
-}
-
-class Utf8ValidationTest : public ::testing::Test {
- protected:
-  Utf8ValidationTest() {}
-  virtual ~Utf8ValidationTest() {}
-  virtual void SetUp() {
-  }
-
-};
-
-TEST_F(Utf8ValidationTest, WriteInvalidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field 'protobuf_unittest.OneString.data' "
-                       "contains invalid UTF-8 data when "
-                       "serializing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-}
-
-
-TEST_F(Utf8ValidationTest, ReadInvalidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field 'protobuf_unittest.OneString.data' "
-                       "contains invalid UTF-8 data when "
-                       "parsing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-}
-
-
-TEST_F(Utf8ValidationTest, WriteValidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kValidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-}
-
-TEST_F(Utf8ValidationTest, ReadValidUTF8String) {
-  std::string wire_buffer;
-  protobuf_unittest::OneString input;
-  WriteMessage(kValidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-  EXPECT_EQ(input.data(), output.data());
-}
-
-// Bytes: anything can pass as bytes, use invalid UTF-8 string to test
-TEST_F(Utf8ValidationTest, WriteArbitraryBytes) {
-  std::string wire_buffer;
-  protobuf_unittest::OneBytes input;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-}
-
-TEST_F(Utf8ValidationTest, ReadArbitraryBytes) {
-  std::string wire_buffer;
-  protobuf_unittest::OneBytes input;
-  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
-  protobuf_unittest::OneBytes output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-  ASSERT_EQ(0, errors.size());
-  EXPECT_EQ(input.data(), output.data());
-}
-
-TEST_F(Utf8ValidationTest, ParseRepeatedString) {
-  protobuf_unittest::MoreBytes input;
-  input.add_data(kValidUTF8String);
-  input.add_data(kInvalidUTF8String);
-  input.add_data(kInvalidUTF8String);
-  std::string wire_buffer = input.SerializeAsString();
-
-  protobuf_unittest::MoreString output;
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    ReadMessage(wire_buffer, &output);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(2, errors.size());
-#else
-  ASSERT_EQ(0, errors.size());
-#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  EXPECT_EQ(wire_buffer, output.SerializeAsString());
-}
-
-// Test the old VerifyUTF8String() function, which may still be called by old
-// generated code.
-TEST_F(Utf8ValidationTest, OldVerifyUTF8String) {
-  std::string data(kInvalidUTF8String);
-
-  std::vector<std::string> errors;
-  {
-    ScopedMemoryLog log;
-    WireFormat::VerifyUTF8String(data.data(), data.size(),
-                                 WireFormat::SERIALIZE);
-    errors = log.GetMessages(ERROR);
-  }
-#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
-  ASSERT_EQ(1, errors.size());
-  EXPECT_TRUE(
-      HasPrefixString(errors[0],
-                       "String field contains invalid UTF-8 data when "
-                       "serializing a protocol buffer. Use the "
-                       "'bytes' type if you intend to send raw bytes."));
-#else
-  ASSERT_EQ(0, errors.size());
-#endif
-}
-
-
-TEST(RepeatedVarint, Int32) {
-  RepeatedField<int32> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar Int32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::Int32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::Int32Size(v));
-}
-
-TEST(RepeatedVarint, Int64) {
-  RepeatedField<int64> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar Int64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::Int64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::Int64Size(v));
-}
-
-TEST(RepeatedVarint, SInt32) {
-  RepeatedField<int32> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar SInt32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::SInt32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::SInt32Size(v));
-}
-
-TEST(RepeatedVarint, SInt64) {
-  RepeatedField<int64> v;
-
-  // Insert -2^n, 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(-(1 << n));
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar SInt64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::SInt64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::SInt64Size(v));
-}
-
-TEST(RepeatedVarint, UInt32) {
-  RepeatedField<uint32> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar UInt32Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::UInt32Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::UInt32Size(v));
-}
-
-TEST(RepeatedVarint, UInt64) {
-  RepeatedField<uint64> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar UInt64Size.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::UInt64Size(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::UInt64Size(v));
-}
-
-TEST(RepeatedVarint, Enum) {
-  RepeatedField<int> v;
-
-  // Insert 2^n and 2^n-1.
-  for (int n = 0; n < 10; n++) {
-    v.Add(1 << n);
-    v.Add((1 << n) - 1);
-  }
-
-  // Check consistency with the scalar EnumSize.
-  size_t expected = 0;
-  for (int i = 0; i < v.size(); i++) {
-    expected += WireFormatLite::EnumSize(v[i]);
-  }
-
-  EXPECT_EQ(expected, WireFormatLite::EnumSize(v));
-}
-
 
 }  // namespace
 }  // namespace internal
diff --git protobuf-3.17.3protobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.inc protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.inc
new file mode 100644
index 0000000..4218374
--- /dev/null
+++ protobuf-3.17.3-patchedprotobuf-3.17.3-patched/src/google/protobuf/wire_format_unittest.inc
@@ -0,0 +1,1710 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+
+#include <google/protobuf/wire_format.h>
+
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/test_util2.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/io/zero_copy_stream_impl.h>
+#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/wire_format_lite.h>
+#include <google/protobuf/testing/googletest.h>
+#include <google/protobuf/stubs/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+#include <google/protobuf/stubs/casts.h>
+#include <google/protobuf/stubs/strutil.h>
+#include <google/protobuf/stubs/stl_util.h>
+#include <google/protobuf/dynamic_message.h>
+
+// clang-format off
+#include <google/protobuf/port_def.inc>
+// clang-format on
+
+namespace google {
+namespace protobuf {
+namespace internal {
+namespace {
+
+TEST(WireFormatTest, EnumsInSync) {
+  // Verify that WireFormatLite::FieldType and WireFormatLite::CppType match
+  // FieldDescriptor::Type and FieldDescriptor::CppType.
+
+  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_TYPE),
+            implicit_cast<int>(WireFormatLite::MAX_FIELD_TYPE));
+  EXPECT_EQ(implicit_cast<int>(FieldDescriptor::MAX_CPPTYPE),
+            implicit_cast<int>(WireFormatLite::MAX_CPPTYPE));
+
+  for (int i = 1; i <= WireFormatLite::MAX_FIELD_TYPE; i++) {
+    EXPECT_EQ(implicit_cast<int>(FieldDescriptor::TypeToCppType(
+                  static_cast<FieldDescriptor::Type>(i))),
+              implicit_cast<int>(WireFormatLite::FieldTypeToCppType(
+                  static_cast<WireFormatLite::FieldType>(i))));
+  }
+}
+
+TEST(WireFormatTest, MaxFieldNumber) {
+  // Make sure the max field number constant is accurate.
+  EXPECT_EQ((1 << (32 - WireFormatLite::kTagTypeBits)) - 1,
+            FieldDescriptor::kMaxNumber);
+}
+
+TEST(WireFormatTest, Parse) {
+  UNITTEST::TestAllTypes source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetAllFields(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectAllFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParseExtensions) {
+  UNITTEST::TestAllExtensions source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetAllExtensions(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectAllExtensionsSet(dest);
+}
+
+TEST(WireFormatTest, ParsePacked) {
+  UNITTEST::TestPackedTypes source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetPackedFields(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectPackedFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParsePackedFromUnpacked) {
+  // Serialize using the generated code.
+  UNITTEST::TestUnpackedTypes source;
+  TestUtil::SetUnpackedFields(&source);
+  std::string data = source.SerializeAsString();
+
+  // Parse using WireFormat.
+  UNITTEST::TestPackedTypes dest;
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectPackedFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParseUnpackedFromPacked) {
+  // Serialize using the generated code.
+  UNITTEST::TestPackedTypes source;
+  TestUtil::SetPackedFields(&source);
+  std::string data = source.SerializeAsString();
+
+  // Parse using WireFormat.
+  UNITTEST::TestUnpackedTypes dest;
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectUnpackedFieldsSet(dest);
+}
+
+TEST(WireFormatTest, ParsePackedExtensions) {
+  UNITTEST::TestPackedExtensions source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetPackedExtensions(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectPackedExtensionsSet(dest);
+}
+
+TEST(WireFormatTest, ParseOneof) {
+  UNITTEST::TestOneof2 source, dest;
+  std::string data;
+
+  // Serialize using the generated code.
+  TestUtil::SetOneof1(&source);
+  source.SerializeToString(&data);
+
+  // Parse using WireFormat.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &dest);
+
+  // Check.
+  TestUtil::ExpectOneofSet1(dest);
+}
+
+TEST(WireFormatTest, OneofOnlySetLast) {
+  UNITTEST::TestOneofBackwardsCompatible source;
+  UNITTEST::TestOneof oneof_dest;
+  std::string data;
+
+  // Set two fields
+  source.set_foo_int(100);
+  source.set_foo_string("101");
+
+  // Serialize and parse to oneof message. Generated serializer may not order
+  // fields in tag order. Use WireFormat::SerializeWithCachedSizes instead as
+  // it sorts fields beforehand.
+  {
+    io::StringOutputStream raw_output(&data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(source, source.ByteSizeLong(),
+                                         &output);
+    ASSERT_FALSE(output.HadError());
+  }
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream input(&raw_input);
+  WireFormat::ParseAndMergePartial(&input, &oneof_dest);
+
+  // Only the last field is set.
+  EXPECT_FALSE(oneof_dest.has_foo_int());
+  EXPECT_TRUE(oneof_dest.has_foo_string());
+}
+
+TEST(WireFormatTest, ByteSize) {
+  UNITTEST::TestAllTypes message;
+  TestUtil::SetAllFields(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizeExtensions) {
+  UNITTEST::TestAllExtensions message;
+  TestUtil::SetAllExtensions(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizePacked) {
+  UNITTEST::TestPackedTypes message;
+  TestUtil::SetPackedFields(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizePackedExtensions) {
+  UNITTEST::TestPackedExtensions message;
+  TestUtil::SetPackedExtensions(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, ByteSizeOneof) {
+  UNITTEST::TestOneof2 message;
+  TestUtil::SetOneof1(&message);
+
+  EXPECT_EQ(message.ByteSizeLong(), WireFormat::ByteSize(message));
+  message.Clear();
+
+  EXPECT_EQ(0, message.ByteSizeLong());
+  EXPECT_EQ(0, WireFormat::ByteSize(message));
+}
+
+TEST(WireFormatTest, Serialize) {
+  UNITTEST::TestAllTypes message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetAllFields(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, SerializeExtensions) {
+  UNITTEST::TestAllExtensions message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetAllExtensions(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, SerializeFieldsAndExtensions) {
+  UNITTEST::TestFieldOrderings message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetAllFieldsAndExtensions(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, SerializeOneof) {
+  UNITTEST::TestOneof2 message;
+  std::string generated_data;
+  std::string dynamic_data;
+
+  TestUtil::SetOneof1(&message);
+  size_t size = message.ByteSizeLong();
+
+  // Serialize using the generated code.
+  {
+    io::StringOutputStream raw_output(&generated_data);
+    io::CodedOutputStream output(&raw_output);
+    message.SerializeWithCachedSizes(&output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Serialize using WireFormat.
+  {
+    io::StringOutputStream raw_output(&dynamic_data);
+    io::CodedOutputStream output(&raw_output);
+    WireFormat::SerializeWithCachedSizes(message, size, &output);
+    ASSERT_FALSE(output.HadError());
+  }
+
+  // Should parse to the same message.
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, generated_data));
+  EXPECT_TRUE(TestUtil::EqualsToSerialized(message, dynamic_data));
+}
+
+TEST(WireFormatTest, ParseMultipleExtensionRanges) {
+  // Make sure we can parse a message that contains multiple extensions ranges.
+  UNITTEST::TestFieldOrderings source;
+  std::string data;
+
+  TestUtil::SetAllFieldsAndExtensions(&source);
+  source.SerializeToString(&data);
+
+  {
+    UNITTEST::TestFieldOrderings dest;
+    EXPECT_TRUE(dest.ParseFromString(data));
+    EXPECT_EQ(source.DebugString(), dest.DebugString());
+  }
+
+  // Also test using reflection-based parsing.
+  {
+    UNITTEST::TestFieldOrderings dest;
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream coded_input(&raw_input);
+    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&coded_input, &dest));
+    EXPECT_EQ(source.DebugString(), dest.DebugString());
+  }
+}
+
+const int kUnknownTypeId = 1550055;
+
+TEST(WireFormatTest, SerializeMessageSet) {
+  // Set up a TestMessageSet with two known messages and an unknown one.
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension)
+      ->set_i(123);
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension2::message_set_extension)
+      ->set_str("foo");
+  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
+                                                           "bar");
+
+  std::string data;
+  ASSERT_TRUE(message_set.SerializeToString(&data));
+
+  // Parse back using RawMessageSet and check the contents.
+  UNITTEST::RawMessageSet raw;
+  ASSERT_TRUE(raw.ParseFromString(data));
+
+  EXPECT_EQ(0, raw.unknown_fields().field_count());
+
+  ASSERT_EQ(3, raw.item_size());
+  EXPECT_EQ(
+      UNITTEST::TestMessageSetExtension1::descriptor()->extension(0)->number(),
+      raw.item(0).type_id());
+  EXPECT_EQ(
+      UNITTEST::TestMessageSetExtension2::descriptor()->extension(0)->number(),
+      raw.item(1).type_id());
+  EXPECT_EQ(kUnknownTypeId, raw.item(2).type_id());
+
+  UNITTEST::TestMessageSetExtension1 message1;
+  EXPECT_TRUE(message1.ParseFromString(raw.item(0).message()));
+  EXPECT_EQ(123, message1.i());
+
+  UNITTEST::TestMessageSetExtension2 message2;
+  EXPECT_TRUE(message2.ParseFromString(raw.item(1).message()));
+  EXPECT_EQ("foo", message2.str());
+
+  EXPECT_EQ("bar", raw.item(2).message());
+}
+
+TEST(WireFormatTest, SerializeMessageSetVariousWaysAreEqual) {
+  // Serialize a MessageSet to a stream and to a flat array using generated
+  // code, and also using WireFormat, and check that the results are equal.
+  // Set up a TestMessageSet with two known messages and an unknown one, as
+  // above.
+
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension)
+      ->set_i(123);
+  message_set
+      .MutableExtension(
+          UNITTEST::TestMessageSetExtension2::message_set_extension)
+      ->set_str("foo");
+  message_set.mutable_unknown_fields()->AddLengthDelimited(kUnknownTypeId,
+                                                           "bar");
+
+  size_t size = message_set.ByteSizeLong();
+  EXPECT_EQ(size, message_set.GetCachedSize());
+  ASSERT_EQ(size, WireFormat::ByteSize(message_set));
+
+  std::string flat_data;
+  std::string stream_data;
+  std::string dynamic_data;
+  flat_data.resize(size);
+  stream_data.resize(size);
+
+  // Serialize to flat array
+  {
+    uint8_t* target =
+        reinterpret_cast<uint8_t*>(::google::protobuf::string_as_array(&flat_data));
+    uint8_t* end = message_set.SerializeWithCachedSizesToArray(target);
+    EXPECT_EQ(size, end - target);
+  }
+
+  // Serialize to buffer
+  {
+    io::ArrayOutputStream array_stream(::google::protobuf::string_as_array(&stream_data), size,
+                                       1);
+    io::CodedOutputStream output_stream(&array_stream);
+    message_set.SerializeWithCachedSizes(&output_stream);
+    ASSERT_FALSE(output_stream.HadError());
+  }
+
+  // Serialize to buffer with WireFormat.
+  {
+    io::StringOutputStream string_stream(&dynamic_data);
+    io::CodedOutputStream output_stream(&string_stream);
+    WireFormat::SerializeWithCachedSizes(message_set, size, &output_stream);
+    ASSERT_FALSE(output_stream.HadError());
+  }
+
+  EXPECT_TRUE(flat_data == stream_data);
+  EXPECT_TRUE(flat_data == dynamic_data);
+}
+
+TEST(WireFormatTest, ParseMessageSet) {
+  // Set up a RawMessageSet with two known messages and an unknown one.
+  UNITTEST::RawMessageSet raw;
+
+  {
+    UNITTEST::RawMessageSet::Item* item = raw.add_item();
+    item->set_type_id(UNITTEST::TestMessageSetExtension1::descriptor()
+                          ->extension(0)
+                          ->number());
+    UNITTEST::TestMessageSetExtension1 message;
+    message.set_i(123);
+    message.SerializeToString(item->mutable_message());
+  }
+
+  {
+    UNITTEST::RawMessageSet::Item* item = raw.add_item();
+    item->set_type_id(UNITTEST::TestMessageSetExtension2::descriptor()
+                          ->extension(0)
+                          ->number());
+    UNITTEST::TestMessageSetExtension2 message;
+    message.set_str("foo");
+    message.SerializeToString(item->mutable_message());
+  }
+
+  {
+    UNITTEST::RawMessageSet::Item* item = raw.add_item();
+    item->set_type_id(kUnknownTypeId);
+    item->set_message("bar");
+  }
+
+  std::string data;
+  ASSERT_TRUE(raw.SerializeToString(&data));
+
+  // Parse as a TestMessageSet and check the contents.
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  ASSERT_TRUE(message_set.ParseFromString(data));
+
+  EXPECT_EQ(123,
+            message_set
+                .GetExtension(
+                    UNITTEST::TestMessageSetExtension1::message_set_extension)
+                .i());
+  EXPECT_EQ("foo",
+            message_set
+                .GetExtension(
+                    UNITTEST::TestMessageSetExtension2::message_set_extension)
+                .str());
+
+  ASSERT_EQ(1, message_set.unknown_fields().field_count());
+  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED,
+            message_set.unknown_fields().field(0).type());
+  EXPECT_EQ("bar", message_set.unknown_fields().field(0).length_delimited());
+
+  // Also parse using WireFormat.
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet dynamic_message_set;
+  io::CodedInputStream input(reinterpret_cast<const uint8_t*>(data.data()),
+                             data.size());
+  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &dynamic_message_set));
+  EXPECT_EQ(message_set.DebugString(), dynamic_message_set.DebugString());
+}
+
+namespace {
+std::string BuildMessageSetItemStart() {
+  std::string data;
+  {
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    coded_output.WriteTag(WireFormatLite::kMessageSetItemStartTag);
+  }
+  return data;
+}
+std::string BuildMessageSetItemEnd() {
+  std::string data;
+  {
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    coded_output.WriteTag(WireFormatLite::kMessageSetItemEndTag);
+  }
+  return data;
+}
+std::string BuildMessageSetTestExtension1(int value = 123) {
+  std::string data;
+  {
+    UNITTEST::TestMessageSetExtension1 message;
+    message.set_i(value);
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    // Write the message content first.
+    WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
+                             WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
+                             &coded_output);
+    coded_output.WriteVarint32(message.ByteSizeLong());
+    message.SerializeWithCachedSizes(&coded_output);
+  }
+  return data;
+}
+std::string BuildMessageSetItemTypeId(int extension_number) {
+  std::string data;
+  {
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber,
+                                extension_number, &coded_output);
+  }
+  return data;
+}
+void ValidateTestMessageSet(const std::string& test_case,
+                            const std::string& data) {
+  SCOPED_TRACE(test_case);
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    ASSERT_TRUE(message_set.ParseFromString(data));
+
+    EXPECT_EQ(123,
+              message_set
+                  .GetExtension(
+                      UNITTEST::TestMessageSetExtension1::message_set_extension)
+                  .i());
+
+    // Make sure it does not contain anything else.
+    message_set.ClearExtension(
+        UNITTEST::TestMessageSetExtension1::message_set_extension);
+    EXPECT_EQ(message_set.SerializeAsString(), "");
+  }
+  {
+    // Test parse the message via Reflection.
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    io::CodedInputStream input(reinterpret_cast<const uint8_t*>(data.data()),
+                               data.size());
+    EXPECT_TRUE(WireFormat::ParseAndMergePartial(&input, &message_set));
+    EXPECT_TRUE(input.ConsumedEntireMessage());
+
+    EXPECT_EQ(123,
+              message_set
+                  .GetExtension(
+                      UNITTEST::TestMessageSetExtension1::message_set_extension)
+                  .i());
+  }
+  {
+    // Test parse the message via DynamicMessage.
+    DynamicMessageFactory factory;
+    std::unique_ptr<Message> msg(
+        factory
+            .GetPrototype(
+                PROTO2_WIREFORMAT_UNITTEST::TestMessageSet::descriptor())
+            ->New());
+    msg->ParseFromString(data);
+    auto* reflection = msg->GetReflection();
+    std::vector<const FieldDescriptor*> fields;
+    reflection->ListFields(*msg, &fields);
+    ASSERT_EQ(fields.size(), 1);
+    const auto& sub = reflection->GetMessage(*msg, fields[0]);
+    reflection = sub.GetReflection();
+    EXPECT_EQ(123, reflection->GetInt32(
+                       sub, sub.GetDescriptor()->FindFieldByName("i")));
+  }
+}
+}  // namespace
+
+TEST(WireFormatTest, ParseMessageSetWithAnyTagOrder) {
+  std::string start = BuildMessageSetItemStart();
+  std::string end = BuildMessageSetItemEnd();
+  std::string id = BuildMessageSetItemTypeId(
+      UNITTEST::TestMessageSetExtension1::descriptor()->extension(0)->number());
+  std::string message = BuildMessageSetTestExtension1();
+
+  ValidateTestMessageSet("id + message", start + id + message + end);
+  ValidateTestMessageSet("message + id", start + message + id + end);
+}
+
+TEST(WireFormatTest, ParseMessageSetWithDuplicateTags) {
+  std::string start = BuildMessageSetItemStart();
+  std::string end = BuildMessageSetItemEnd();
+  std::string id = BuildMessageSetItemTypeId(
+      UNITTEST::TestMessageSetExtension1::descriptor()->extension(0)->number());
+  std::string other_id = BuildMessageSetItemTypeId(123456);
+  std::string message = BuildMessageSetTestExtension1();
+  std::string other_message = BuildMessageSetTestExtension1(321);
+
+  // Double id
+  ValidateTestMessageSet("id + other_id + message",
+                         start + id + other_id + message + end);
+  ValidateTestMessageSet("id + message + other_id",
+                         start + id + message + other_id + end);
+  ValidateTestMessageSet("message + id + other_id",
+                         start + message + id + other_id + end);
+  // Double message
+  ValidateTestMessageSet("id + message + other_message",
+                         start + id + message + other_message + end);
+  ValidateTestMessageSet("message + id + other_message",
+                         start + message + id + other_message + end);
+  ValidateTestMessageSet("message + other_message + id",
+                         start + message + other_message + id + end);
+}
+
+void SerializeReverseOrder(
+    const PROTO2_WIREFORMAT_UNITTEST::TestMessageSet& mset,
+    io::CodedOutputStream* coded_output);
+
+void SerializeReverseOrder(const UNITTEST::TestMessageSetExtension1& message,
+                           io::CodedOutputStream* coded_output) {
+  WireFormatLite::WriteTag(15,  // i
+                           WireFormatLite::WIRETYPE_VARINT, coded_output);
+  coded_output->WriteVarint64(message.i());
+  WireFormatLite::WriteTag(16,  // recursive
+                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
+                           coded_output);
+  coded_output->WriteVarint32(message.recursive().GetCachedSize());
+  SerializeReverseOrder(message.recursive(), coded_output);
+}
+
+void SerializeReverseOrder(
+    const PROTO2_WIREFORMAT_UNITTEST::TestMessageSet& mset,
+    io::CodedOutputStream* coded_output) {
+  if (!mset.HasExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension))
+    return;
+  coded_output->WriteTag(WireFormatLite::kMessageSetItemStartTag);
+  // Write the message content first.
+  WireFormatLite::WriteTag(WireFormatLite::kMessageSetMessageNumber,
+                           WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
+                           coded_output);
+  auto& message = mset.GetExtension(
+      UNITTEST::TestMessageSetExtension1::message_set_extension);
+  coded_output->WriteVarint32(message.GetCachedSize());
+  SerializeReverseOrder(message, coded_output);
+  // Write the type id.
+  uint32_t type_id = message.GetDescriptor()->extension(0)->number();
+  WireFormatLite::WriteUInt32(WireFormatLite::kMessageSetTypeIdNumber, type_id,
+                              coded_output);
+  coded_output->WriteTag(WireFormatLite::kMessageSetItemEndTag);
+}
+
+TEST(WireFormatTest, ParseMessageSetWithDeepRecReverseOrder) {
+  std::string data;
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet* mset = &message_set;
+    for (int i = 0; i < 200; i++) {
+      auto m = mset->MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension);
+      m->set_i(i);
+      mset = m->mutable_recursive();
+    }
+    message_set.ByteSizeLong();
+    // Serialize with reverse payload tag order
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    SerializeReverseOrder(message_set, &coded_output);
+  }
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  EXPECT_FALSE(message_set.ParseFromString(data));
+}
+
+TEST(WireFormatTest, ParseFailMalformedMessageSet) {
+  constexpr int kDepth = 5;
+  std::string data;
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet* mset = &message_set;
+    for (int i = 0; i < kDepth; i++) {
+      auto m = mset->MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension);
+      m->set_i(i);
+      mset = m->mutable_recursive();
+    }
+    auto m = mset->MutableExtension(
+        UNITTEST::TestMessageSetExtension1::message_set_extension);
+    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
+    m->set_i(-1);
+
+    EXPECT_TRUE(message_set.SerializeToString(&data));
+    // Make the proto mal-formed.
+    data[data.size() - 2 - kDepth] = 0xFF;
+  }
+
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  EXPECT_FALSE(message_set.ParseFromString(data));
+}
+
+TEST(WireFormatTest, ParseFailMalformedMessageSetReverseOrder) {
+  constexpr int kDepth = 5;
+  std::string data;
+  {
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+    PROTO2_WIREFORMAT_UNITTEST::TestMessageSet* mset = &message_set;
+    for (int i = 0; i < kDepth; i++) {
+      auto m = mset->MutableExtension(
+          UNITTEST::TestMessageSetExtension1::message_set_extension);
+      m->set_i(i);
+      mset = m->mutable_recursive();
+    }
+    auto m = mset->MutableExtension(
+        UNITTEST::TestMessageSetExtension1::message_set_extension);
+    // -1 becomes \xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x1
+    m->set_i(-1);
+    // SerializeReverseOrder() assumes "recursive" is always present.
+    m->mutable_recursive();
+
+    message_set.ByteSizeLong();
+
+    // Serialize with reverse payload tag order
+    io::StringOutputStream output_stream(&data);
+    io::CodedOutputStream coded_output(&output_stream);
+    SerializeReverseOrder(message_set, &coded_output);
+  }
+
+  // Make varint for -1 malformed.
+  data[data.size() - 5 * (kDepth + 1) - 4] = 0xFF;
+
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  EXPECT_FALSE(message_set.ParseFromString(data));
+}
+
+TEST(WireFormatTest, ParseBrokenMessageSet) {
+  PROTO2_WIREFORMAT_UNITTEST::TestMessageSet message_set;
+  std::string input("goodbye");  // Invalid wire format data.
+  EXPECT_FALSE(message_set.ParseFromString(input));
+}
+
+TEST(WireFormatTest, RecursionLimit) {
+  UNITTEST::TestRecursiveMessage message;
+  message.mutable_a()->mutable_a()->mutable_a()->mutable_a()->set_i(1);
+  std::string data;
+  message.SerializeToString(&data);
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(4);
+    UNITTEST::TestRecursiveMessage message2;
+    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
+  }
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(3);
+    UNITTEST::TestRecursiveMessage message2;
+    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
+  }
+}
+
+TEST(WireFormatTest, LargeRecursionLimit) {
+  const int kLargeLimit = io::CodedInputStream::GetDefaultRecursionLimit() + 50;
+  UNITTEST::TestRecursiveMessage src, dst, *a;
+  a = src.mutable_a();
+  for (int i = 0; i < kLargeLimit - 1; i++) {
+    a = a->mutable_a();
+  }
+  a->set_i(1);
+
+  std::string data = src.SerializeAsString();
+  {
+    // Parse with default recursion limit. Should fail.
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    ASSERT_FALSE(dst.ParseFromCodedStream(&input));
+  }
+
+  {
+    // Parse with custom recursion limit. Should pass.
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(kLargeLimit);
+    ASSERT_TRUE(dst.ParseFromCodedStream(&input));
+  }
+
+  // Verifies the recursion depth.
+  int depth = 1;
+  a = dst.mutable_a();
+  while (a->has_a()) {
+    a = a->mutable_a();
+    depth++;
+  }
+
+  EXPECT_EQ(a->i(), 1);
+  EXPECT_EQ(depth, kLargeLimit);
+}
+
+TEST(WireFormatTest, UnknownFieldRecursionLimit) {
+  UNITTEST::TestEmptyMessage message;
+  message.mutable_unknown_fields()
+      ->AddGroup(1234)
+      ->AddGroup(1234)
+      ->AddGroup(1234)
+      ->AddGroup(1234)
+      ->AddVarint(1234, 123);
+  std::string data;
+  message.SerializeToString(&data);
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(4);
+    UNITTEST::TestEmptyMessage message2;
+    EXPECT_TRUE(message2.ParseFromCodedStream(&input));
+  }
+
+  {
+    io::ArrayInputStream raw_input(data.data(), data.size());
+    io::CodedInputStream input(&raw_input);
+    input.SetRecursionLimit(3);
+    UNITTEST::TestEmptyMessage message2;
+    EXPECT_FALSE(message2.ParseFromCodedStream(&input));
+  }
+}
+
+TEST(WireFormatTest, ZigZag) {
+// avoid line-wrapping
+#define LL(x) static_cast<int64_t>(ULL(x))
+#define ULL(x) uint64_t{x##u}
+#define ZigZagEncode32(x) WireFormatLite::ZigZagEncode32(x)
+#define ZigZagDecode32(x) WireFormatLite::ZigZagDecode32(x)
+#define ZigZagEncode64(x) WireFormatLite::ZigZagEncode64(x)
+#define ZigZagDecode64(x) WireFormatLite::ZigZagDecode64(x)
+
+  EXPECT_EQ(0u, ZigZagEncode32(0));
+  EXPECT_EQ(1u, ZigZagEncode32(-1));
+  EXPECT_EQ(2u, ZigZagEncode32(1));
+  EXPECT_EQ(3u, ZigZagEncode32(-2));
+  EXPECT_EQ(0x7FFFFFFEu, ZigZagEncode32(0x3FFFFFFF));
+  EXPECT_EQ(0x7FFFFFFFu, ZigZagEncode32(0xC0000000));
+  EXPECT_EQ(0xFFFFFFFEu, ZigZagEncode32(0x7FFFFFFF));
+  EXPECT_EQ(0xFFFFFFFFu, ZigZagEncode32(0x80000000));
+
+  EXPECT_EQ(0, ZigZagDecode32(0u));
+  EXPECT_EQ(-1, ZigZagDecode32(1u));
+  EXPECT_EQ(1, ZigZagDecode32(2u));
+  EXPECT_EQ(-2, ZigZagDecode32(3u));
+  EXPECT_EQ(0x3FFFFFFF, ZigZagDecode32(0x7FFFFFFEu));
+  EXPECT_EQ(0xC0000000, ZigZagDecode32(0x7FFFFFFFu));
+  EXPECT_EQ(0x7FFFFFFF, ZigZagDecode32(0xFFFFFFFEu));
+  EXPECT_EQ(0x80000000, ZigZagDecode32(0xFFFFFFFFu));
+
+  EXPECT_EQ(0u, ZigZagEncode64(0));
+  EXPECT_EQ(1u, ZigZagEncode64(-1));
+  EXPECT_EQ(2u, ZigZagEncode64(1));
+  EXPECT_EQ(3u, ZigZagEncode64(-2));
+  EXPECT_EQ(ULL(0x000000007FFFFFFE), ZigZagEncode64(LL(0x000000003FFFFFFF)));
+  EXPECT_EQ(ULL(0x000000007FFFFFFF), ZigZagEncode64(LL(0xFFFFFFFFC0000000)));
+  EXPECT_EQ(ULL(0x00000000FFFFFFFE), ZigZagEncode64(LL(0x000000007FFFFFFF)));
+  EXPECT_EQ(ULL(0x00000000FFFFFFFF), ZigZagEncode64(LL(0xFFFFFFFF80000000)));
+  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFE), ZigZagEncode64(LL(0x7FFFFFFFFFFFFFFF)));
+  EXPECT_EQ(ULL(0xFFFFFFFFFFFFFFFF), ZigZagEncode64(LL(0x8000000000000000)));
+
+  EXPECT_EQ(0, ZigZagDecode64(0u));
+  EXPECT_EQ(-1, ZigZagDecode64(1u));
+  EXPECT_EQ(1, ZigZagDecode64(2u));
+  EXPECT_EQ(-2, ZigZagDecode64(3u));
+  EXPECT_EQ(LL(0x000000003FFFFFFF), ZigZagDecode64(ULL(0x000000007FFFFFFE)));
+  EXPECT_EQ(LL(0xFFFFFFFFC0000000), ZigZagDecode64(ULL(0x000000007FFFFFFF)));
+  EXPECT_EQ(LL(0x000000007FFFFFFF), ZigZagDecode64(ULL(0x00000000FFFFFFFE)));
+  EXPECT_EQ(LL(0xFFFFFFFF80000000), ZigZagDecode64(ULL(0x00000000FFFFFFFF)));
+  EXPECT_EQ(LL(0x7FFFFFFFFFFFFFFF), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFE)));
+  EXPECT_EQ(LL(0x8000000000000000), ZigZagDecode64(ULL(0xFFFFFFFFFFFFFFFF)));
+
+  // Some easier-to-verify round-trip tests.  The inputs (other than 0, 1, -1)
+  // were chosen semi-randomly via keyboard bashing.
+  EXPECT_EQ(0, ZigZagDecode32(ZigZagEncode32(0)));
+  EXPECT_EQ(1, ZigZagDecode32(ZigZagEncode32(1)));
+  EXPECT_EQ(-1, ZigZagDecode32(ZigZagEncode32(-1)));
+  EXPECT_EQ(14927, ZigZagDecode32(ZigZagEncode32(14927)));
+  EXPECT_EQ(-3612, ZigZagDecode32(ZigZagEncode32(-3612)));
+
+  EXPECT_EQ(0, ZigZagDecode64(ZigZagEncode64(0)));
+  EXPECT_EQ(1, ZigZagDecode64(ZigZagEncode64(1)));
+  EXPECT_EQ(-1, ZigZagDecode64(ZigZagEncode64(-1)));
+  EXPECT_EQ(14927, ZigZagDecode64(ZigZagEncode64(14927)));
+  EXPECT_EQ(-3612, ZigZagDecode64(ZigZagEncode64(-3612)));
+
+  EXPECT_EQ(LL(856912304801416),
+            ZigZagDecode64(ZigZagEncode64(LL(856912304801416))));
+  EXPECT_EQ(LL(-75123905439571256),
+            ZigZagDecode64(ZigZagEncode64(LL(-75123905439571256))));
+}
+
+TEST(WireFormatTest, RepeatedScalarsDifferentTagSizes) {
+  // At one point checks would trigger when parsing repeated fixed scalar
+  // fields.
+  UNITTEST::TestRepeatedScalarDifferentTagSizes msg1, msg2;
+  for (int i = 0; i < 100; ++i) {
+    msg1.add_repeated_fixed32(i);
+    msg1.add_repeated_int32(i);
+    msg1.add_repeated_fixed64(i);
+    msg1.add_repeated_int64(i);
+    msg1.add_repeated_float(i);
+    msg1.add_repeated_uint64(i);
+  }
+
+  // Make sure that we have a variety of tag sizes.
+  const Descriptor* desc = msg1.GetDescriptor();
+  const FieldDescriptor* field;
+  field = desc->FindFieldByName("repeated_fixed32");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_int32");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_fixed64");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_int64");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_float");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
+  field = desc->FindFieldByName("repeated_uint64");
+  ASSERT_TRUE(field != nullptr);
+  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));
+
+  EXPECT_TRUE(msg2.ParseFromString(msg1.SerializeAsString()));
+  EXPECT_EQ(msg1.DebugString(), msg2.DebugString());
+}
+
+TEST(WireFormatTest, CompatibleTypes) {
+  const int64_t data = 0x100000000LL;
+  UNITTEST::Int64Message msg1;
+  msg1.set_data(data);
+  std::string serialized;
+  msg1.SerializeToString(&serialized);
+
+  // Test int64 is compatible with bool
+  UNITTEST::BoolMessage msg2;
+  ASSERT_TRUE(msg2.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<bool>(data), msg2.data());
+
+  // Test int64 is compatible with uint64
+  UNITTEST::Uint64Message msg3;
+  ASSERT_TRUE(msg3.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<uint64_t>(data), msg3.data());
+
+  // Test int64 is compatible with int32
+  UNITTEST::Int32Message msg4;
+  ASSERT_TRUE(msg4.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<int32_t>(data), msg4.data());
+
+  // Test int64 is compatible with uint32
+  UNITTEST::Uint32Message msg5;
+  ASSERT_TRUE(msg5.ParseFromString(serialized));
+  ASSERT_EQ(static_cast<uint32_t>(data), msg5.data());
+}
+
+class Proto3PrimitiveRepeatedWireFormatTest : public ::testing::Test {
+ protected:
+  Proto3PrimitiveRepeatedWireFormatTest()
+      : packedTestAllTypes_(
+            "\xFA\x01\x01\x01"
+            "\x82\x02\x01\x01"
+            "\x8A\x02\x01\x01"
+            "\x92\x02\x01\x01"
+            "\x9A\x02\x01\x02"
+            "\xA2\x02\x01\x02"
+            "\xAA\x02\x04\x01\x00\x00\x00"
+            "\xB2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xBA\x02\x04\x01\x00\x00\x00"
+            "\xC2\x02\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xCA\x02\x04\x00\x00\x80\x3f"
+            "\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\xDA\x02\x01\x01"
+            "\x9A\x03\x01\x01",
+            86),
+        packedTestUnpackedTypes_(
+            "\x0A\x01\x01"
+            "\x12\x01\x01"
+            "\x1A\x01\x01"
+            "\x22\x01\x01"
+            "\x2A\x01\x02"
+            "\x32\x01\x02"
+            "\x3A\x04\x01\x00\x00\x00"
+            "\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x4A\x04\x01\x00\x00\x00"
+            "\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x5A\x04\x00\x00\x80\x3f"
+            "\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\x6A\x01\x01"
+            "\x72\x01\x01",
+            72),
+        unpackedTestAllTypes_(
+            "\xF8\x01\x01"
+            "\x80\x02\x01"
+            "\x88\x02\x01"
+            "\x90\x02\x01"
+            "\x98\x02\x02"
+            "\xA0\x02\x02"
+            "\xAD\x02\x01\x00\x00\x00"
+            "\xB1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xBD\x02\x01\x00\x00\x00"
+            "\xC1\x02\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\xCD\x02\x00\x00\x80\x3f"
+            "\xD1\x02\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\xD8\x02\x01"
+            "\x98\x03\x01",
+            72),
+        unpackedTestUnpackedTypes_(
+            "\x08\x01"
+            "\x10\x01"
+            "\x18\x01"
+            "\x20\x01"
+            "\x28\x02"
+            "\x30\x02"
+            "\x3D\x01\x00\x00\x00"
+            "\x41\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x4D\x01\x00\x00\x00"
+            "\x51\x01\x00\x00\x00\x00\x00\x00\x00"
+            "\x5D\x00\x00\x80\x3f"
+            "\x61\x00\x00\x00\x00\x00\x00\xf0\x3f"
+            "\x68\x01"
+            "\x70\x01",
+            58) {}
+  template <class Proto>
+  void SetProto3PrimitiveRepeatedFields(Proto* message) {
+    message->add_repeated_int32(1);
+    message->add_repeated_int64(1);
+    message->add_repeated_uint32(1);
+    message->add_repeated_uint64(1);
+    message->add_repeated_sint32(1);
+    message->add_repeated_sint64(1);
+    message->add_repeated_fixed32(1);
+    message->add_repeated_fixed64(1);
+    message->add_repeated_sfixed32(1);
+    message->add_repeated_sfixed64(1);
+    message->add_repeated_float(1.0);
+    message->add_repeated_double(1.0);
+    message->add_repeated_bool(true);
+    message->add_repeated_nested_enum(PROTO3_ARENA_UNITTEST::TestAllTypes::FOO);
+  }
+
+  template <class Proto>
+  void ExpectProto3PrimitiveRepeatedFieldsSet(const Proto& message) {
+    EXPECT_EQ(1, message.repeated_int32(0));
+    EXPECT_EQ(1, message.repeated_int64(0));
+    EXPECT_EQ(1, message.repeated_uint32(0));
+    EXPECT_EQ(1, message.repeated_uint64(0));
+    EXPECT_EQ(1, message.repeated_sint32(0));
+    EXPECT_EQ(1, message.repeated_sint64(0));
+    EXPECT_EQ(1, message.repeated_fixed32(0));
+    EXPECT_EQ(1, message.repeated_fixed64(0));
+    EXPECT_EQ(1, message.repeated_sfixed32(0));
+    EXPECT_EQ(1, message.repeated_sfixed64(0));
+    EXPECT_EQ(1.0, message.repeated_float(0));
+    EXPECT_EQ(1.0, message.repeated_double(0));
+    EXPECT_EQ(true, message.repeated_bool(0));
+    EXPECT_EQ(PROTO3_ARENA_UNITTEST::TestAllTypes::FOO,
+              message.repeated_nested_enum(0));
+  }
+
+  template <class Proto>
+  void TestSerialization(Proto* message, const std::string& expected) {
+    SetProto3PrimitiveRepeatedFields(message);
+
+    size_t size = message->ByteSizeLong();
+
+    // Serialize using the generated code.
+    std::string generated_data;
+    {
+      io::StringOutputStream raw_output(&generated_data);
+      io::CodedOutputStream output(&raw_output);
+      message->SerializeWithCachedSizes(&output);
+      ASSERT_FALSE(output.HadError());
+    }
+    EXPECT_TRUE(TestUtil::EqualsToSerialized(*message, generated_data));
+
+    // Serialize using the dynamic code.
+    std::string dynamic_data;
+    {
+      io::StringOutputStream raw_output(&dynamic_data);
+      io::CodedOutputStream output(&raw_output);
+      WireFormat::SerializeWithCachedSizes(*message, size, &output);
+      ASSERT_FALSE(output.HadError());
+    }
+    EXPECT_TRUE(expected == dynamic_data);
+  }
+
+  template <class Proto>
+  void TestParsing(Proto* message, const std::string& compatible_data) {
+    message->Clear();
+    message->ParseFromString(compatible_data);
+    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
+
+    message->Clear();
+    io::CodedInputStream input(
+        reinterpret_cast<const uint8_t*>(compatible_data.data()),
+        compatible_data.size());
+    WireFormat::ParseAndMergePartial(&input, message);
+    ExpectProto3PrimitiveRepeatedFieldsSet(*message);
+  }
+
+  const std::string packedTestAllTypes_;
+  const std::string packedTestUnpackedTypes_;
+  const std::string unpackedTestAllTypes_;
+  const std::string unpackedTestUnpackedTypes_;
+};
+
+TEST_F(Proto3PrimitiveRepeatedWireFormatTest, Proto3PrimitiveRepeated) {
+  PROTO3_ARENA_UNITTEST::TestAllTypes packed_message;
+  PROTO3_ARENA_UNITTEST::TestUnpackedTypes unpacked_message;
+  TestSerialization(&packed_message, packedTestAllTypes_);
+  TestParsing(&packed_message, packedTestAllTypes_);
+  TestParsing(&packed_message, unpackedTestAllTypes_);
+  TestSerialization(&unpacked_message, unpackedTestUnpackedTypes_);
+  TestParsing(&unpacked_message, packedTestUnpackedTypes_);
+  TestParsing(&unpacked_message, unpackedTestUnpackedTypes_);
+}
+
+class WireFormatInvalidInputTest : public testing::Test {
+ protected:
+  // Make a serialized TestAllTypes in which the field optional_nested_message
+  // contains exactly the given bytes, which may be invalid.
+  std::string MakeInvalidEmbeddedMessage(const char* bytes, int size) {
+    const FieldDescriptor* field =
+        UNITTEST::TestAllTypes::descriptor()->FindFieldByName(
+            "optional_nested_message");
+    GOOGLE_CHECK(field != nullptr);
+
+    std::string result;
+
+    {
+      io::StringOutputStream raw_output(&result);
+      io::CodedOutputStream output(&raw_output);
+
+      WireFormatLite::WriteBytes(field->number(), std::string(bytes, size),
+                                 &output);
+    }
+
+    return result;
+  }
+
+  // Make a serialized TestAllTypes in which the field optionalgroup
+  // contains exactly the given bytes -- which may be invalid -- and
+  // possibly no end tag.
+  std::string MakeInvalidGroup(const char* bytes, int size,
+                               bool include_end_tag) {
+    const FieldDescriptor* field =
+        UNITTEST::TestAllTypes::descriptor()->FindFieldByName("optionalgroup");
+    GOOGLE_CHECK(field != nullptr);
+
+    std::string result;
+
+    {
+      io::StringOutputStream raw_output(&result);
+      io::CodedOutputStream output(&raw_output);
+
+      output.WriteVarint32(WireFormat::MakeTag(field));
+      output.WriteString(std::string(bytes, size));
+      if (include_end_tag) {
+        output.WriteVarint32(WireFormatLite::MakeTag(
+            field->number(), WireFormatLite::WIRETYPE_END_GROUP));
+      }
+    }
+
+    return result;
+  }
+};
+
+TEST_F(WireFormatInvalidInputTest, InvalidSubMessage) {
+  UNITTEST::TestAllTypes message;
+
+  // Control case.
+  EXPECT_TRUE(message.ParseFromString(MakeInvalidEmbeddedMessage("", 0)));
+
+  // The byte is a valid varint, but not a valid tag (zero).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\0", 1)));
+
+  // The byte is a malformed varint.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\200", 1)));
+
+  // The byte is an endgroup tag, but we aren't parsing a group.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\014", 1)));
+
+  // The byte is a valid varint but not a valid tag (bad wire type).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidEmbeddedMessage("\017", 1)));
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidMessageWithExtraZero) {
+  std::string data;
+  {
+    // Serialize a valid proto
+    UNITTEST::TestAllTypes message;
+    message.set_optional_int32(1);
+    message.SerializeToString(&data);
+    data.push_back(0);  // Append invalid zero tag
+  }
+
+  // Control case.
+  {
+    io::ArrayInputStream ais(data.data(), data.size());
+    io::CodedInputStream is(&ais);
+    UNITTEST::TestAllTypes message;
+    // It should fail but currently passes.
+    EXPECT_TRUE(message.MergePartialFromCodedStream(&is));
+    // Parsing from the string should fail.
+    EXPECT_FALSE(message.ParseFromString(data));
+  }
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidGroup) {
+  UNITTEST::TestAllTypes message;
+
+  // Control case.
+  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
+
+  // Missing end tag.  Groups cannot end at EOF.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
+
+  // The byte is a valid varint, but not a valid tag (zero).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
+
+  // The byte is a malformed varint.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
+
+  // The byte is an endgroup tag, but not the right one for this group.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
+
+  // The byte is a valid varint but not a valid tag (bad wire type).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidUnknownGroup) {
+  // Use TestEmptyMessage so that the group made by MakeInvalidGroup will not
+  // be a known tag number.
+  UNITTEST::TestEmptyMessage message;
+
+  // Control case.
+  EXPECT_TRUE(message.ParseFromString(MakeInvalidGroup("", 0, true)));
+
+  // Missing end tag.  Groups cannot end at EOF.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("", 0, false)));
+
+  // The byte is a valid varint, but not a valid tag (zero).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\0", 1, false)));
+
+  // The byte is a malformed varint.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\200", 1, false)));
+
+  // The byte is an endgroup tag, but not the right one for this group.
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\014", 1, false)));
+
+  // The byte is a valid varint but not a valid tag (bad wire type).
+  EXPECT_FALSE(message.ParseFromString(MakeInvalidGroup("\017", 1, true)));
+}
+
+TEST_F(WireFormatInvalidInputTest, InvalidStringInUnknownGroup) {
+  // Test a bug fix:  SkipMessage should fail if the message contains a
+  // string whose length would extend beyond the message end.
+
+  UNITTEST::TestAllTypes message;
+  message.set_optional_string("foo foo foo foo");
+  std::string data;
+  message.SerializeToString(&data);
+
+  // Chop some bytes off the end.
+  data.resize(data.size() - 4);
+
+  // Try to skip it.  Note that the bug was only present when parsing to an
+  // UnknownFieldSet.
+  io::ArrayInputStream raw_input(data.data(), data.size());
+  io::CodedInputStream coded_input(&raw_input);
+  UnknownFieldSet unknown_fields;
+  EXPECT_FALSE(WireFormat::SkipMessage(&coded_input, &unknown_fields));
+}
+
+// Test differences between string and bytes.
+// Value of a string type must be valid UTF-8 string.  When UTF-8
+// validation is enabled (GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED):
+// WriteInvalidUTF8String:  see error message.
+// ReadInvalidUTF8String:  see error message.
+// WriteValidUTF8String: fine.
+// ReadValidUTF8String:  fine.
+// WriteAnyBytes: fine.
+// ReadAnyBytes: fine.
+const char* kInvalidUTF8String = "Invalid UTF-8: \xA0\xB0\xC0\xD0";
+// This used to be "Valid UTF-8: \x01\x02\u8C37\u6B4C", but MSVC seems to
+// interpret \u differently from GCC.
+const char* kValidUTF8String = "Valid UTF-8: \x01\x02\350\260\267\346\255\214";
+
+template <typename T>
+bool WriteMessage(const char* value, T* message, std::string* wire_buffer) {
+  message->set_data(value);
+  wire_buffer->clear();
+  message->AppendToString(wire_buffer);
+  return (wire_buffer->size() > 0);
+}
+
+template <typename T>
+bool ReadMessage(const std::string& wire_buffer, T* message) {
+  return message->ParseFromArray(wire_buffer.data(), wire_buffer.size());
+}
+
+class Utf8ValidationTest : public ::testing::Test {
+ protected:
+  Utf8ValidationTest() {}
+  ~Utf8ValidationTest() override {}
+  void SetUp() override {
+  }
+
+};
+
+TEST_F(Utf8ValidationTest, WriteInvalidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  EXPECT_THAT(errors,
+              testing::ElementsAre(
+                  "String field '" + std::string(UNITTEST_PACKAGE_NAME) +
+                  ".OneString.data' "
+                  "contains invalid UTF-8 data when "
+                  "serializing a protocol buffer. Use the "
+                  "'bytes' type if you intend to send raw bytes. "));
+#else
+  ASSERT_EQ(0, errors.size());
+#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+}
+
+
+TEST_F(Utf8ValidationTest, ReadInvalidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+  UNITTEST::OneString output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  EXPECT_THAT(errors,
+              testing::ElementsAre(
+                  "String field '" + std::string(UNITTEST_PACKAGE_NAME) +
+                  ".OneString.data' "
+                  "contains invalid UTF-8 data when "
+                  "parsing a protocol buffer. Use the "
+                  "'bytes' type if you intend to send raw bytes. "));
+
+#else
+  ASSERT_EQ(0, errors.size());
+#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+}
+
+
+TEST_F(Utf8ValidationTest, WriteValidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WriteMessage(kValidUTF8String, &input, &wire_buffer);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+}
+
+TEST_F(Utf8ValidationTest, ReadValidUTF8String) {
+  std::string wire_buffer;
+  UNITTEST::OneString input;
+  WriteMessage(kValidUTF8String, &input, &wire_buffer);
+  UNITTEST::OneString output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+  EXPECT_EQ(input.data(), output.data());
+}
+
+// Bytes: anything can pass as bytes, use invalid UTF-8 string to test
+TEST_F(Utf8ValidationTest, WriteArbitraryBytes) {
+  std::string wire_buffer;
+  UNITTEST::OneBytes input;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+}
+
+TEST_F(Utf8ValidationTest, ReadArbitraryBytes) {
+  std::string wire_buffer;
+  UNITTEST::OneBytes input;
+  WriteMessage(kInvalidUTF8String, &input, &wire_buffer);
+  UNITTEST::OneBytes output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+  ASSERT_EQ(0, errors.size());
+  EXPECT_EQ(input.data(), output.data());
+}
+
+TEST_F(Utf8ValidationTest, ParseRepeatedString) {
+  UNITTEST::MoreBytes input;
+  input.add_data(kValidUTF8String);
+  input.add_data(kInvalidUTF8String);
+  input.add_data(kInvalidUTF8String);
+  std::string wire_buffer = input.SerializeAsString();
+
+  UNITTEST::MoreString output;
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    ReadMessage(wire_buffer, &output);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  ASSERT_EQ(2, errors.size());
+#else
+  ASSERT_EQ(0, errors.size());
+#endif  // GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  EXPECT_EQ(wire_buffer, output.SerializeAsString());
+}
+
+// Test the old VerifyUTF8String() function, which may still be called by old
+// generated code.
+TEST_F(Utf8ValidationTest, OldVerifyUTF8String) {
+  std::string data(kInvalidUTF8String);
+
+  std::vector<std::string> errors;
+  {
+    ScopedMemoryLog log;
+    WireFormat::VerifyUTF8String(data.data(), data.size(),
+                                 WireFormat::SERIALIZE);
+    errors = log.GetMessages(ERROR);
+  }
+#ifdef GOOGLE_PROTOBUF_UTF8_VALIDATION_ENABLED
+  ASSERT_EQ(1, errors.size());
+  EXPECT_TRUE(
+      HasPrefixString(errors[0],
+                       "String field contains invalid UTF-8 data when "
+                       "serializing a protocol buffer. Use the "
+                       "'bytes' type if you intend to send raw bytes."));
+#else
+  ASSERT_EQ(0, errors.size());
+#endif
+}
+
+
+TEST(RepeatedVarint, Int32) {
+  RepeatedField<int32_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar Int32Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::Int32Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::Int32Size(v));
+}
+
+TEST(RepeatedVarint, Int64) {
+  RepeatedField<int64_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar Int64Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::Int64Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::Int64Size(v));
+}
+
+TEST(RepeatedVarint, SInt32) {
+  RepeatedField<int32_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar SInt32Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::SInt32Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::SInt32Size(v));
+}
+
+TEST(RepeatedVarint, SInt64) {
+  RepeatedField<int64_t> v;
+
+  // Insert -2^n, 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(-(1 << n));
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar SInt64Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::SInt64Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::SInt64Size(v));
+}
+
+TEST(RepeatedVarint, UInt32) {
+  RepeatedField<uint32_t> v;
+
+  // Insert 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar UInt32Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::UInt32Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::UInt32Size(v));
+}
+
+TEST(RepeatedVarint, UInt64) {
+  RepeatedField<uint64_t> v;
+
+  // Insert 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar UInt64Size.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::UInt64Size(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::UInt64Size(v));
+}
+
+TEST(RepeatedVarint, Enum) {
+  RepeatedField<int> v;
+
+  // Insert 2^n and 2^n-1.
+  for (int n = 0; n < 10; n++) {
+    v.Add(1 << n);
+    v.Add((1 << n) - 1);
+  }
+
+  // Check consistency with the scalar EnumSize.
+  size_t expected = 0;
+  for (int i = 0; i < v.size(); i++) {
+    expected += WireFormatLite::EnumSize(v[i]);
+  }
+
+  EXPECT_EQ(expected, WireFormatLite::EnumSize(v));
+}
+
+
+}  // namespace
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
